const me = {
  context: void 0,
  registry: void 0,
  effects: void 0,
  done: !1,
  getContextId() {
    return $d(this.context.count);
  },
  getNextContextId() {
    return $d(this.context.count++);
  }
};
function $d(i) {
  const e = String(i), t = e.length - 1;
  return me.context.id + (t ? String.fromCharCode(96 + t) : "") + e;
}
function Fs(i) {
  me.context = i;
}
const Vy = !1, Uy = (i, e) => i === e, Ut = Symbol("solid-proxy"), Lm = typeof Proxy == "function", Oh = Symbol("solid-track"), $a = {
  equals: Uy
};
let Mm = Zm;
const jt = 1, gn = 2, Dm = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
}, Jl = {};
var Oe = null;
let J = null, jy = null, we = null, lt = null, st = null, Sl = 0;
function es(i, e) {
  const t = we, r = Oe, s = i.length === 0, n = e === void 0 ? r : e, o = s ? Dm : {
    owned: null,
    cleanups: null,
    context: n ? n.context : null,
    owner: n
  }, a = s ? i : () => i(() => pt(() => sr(o)));
  Oe = o, we = null;
  try {
    return Rt(a, !0);
  } finally {
    we = t, Oe = r;
  }
}
function ie(i, e) {
  e = e ? Object.assign({}, $a, e) : $a;
  const t = {
    value: i,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, r = (s) => (typeof s == "function" && (J && J.running && J.sources.has(t) ? s = s(t.tValue) : s = s(t.value)), Im(t, s));
  return [Xm.bind(t), r];
}
function Td(i, e, t) {
  const r = _l(i, e, !0, jt);
  ys(r);
}
function ce(i, e, t) {
  const r = _l(i, e, !1, jt);
  ys(r);
}
function Tr(i, e, t) {
  Mm = Ky;
  const r = _l(i, e, !1, jt), s = Rr && Ir(Rr);
  s && (r.suspense = s), r.user = !0, st ? st.push(r) : ys(r);
}
function Qe(i, e, t) {
  t = t ? Object.assign({}, $a, t) : $a;
  const r = _l(i, e, !0, 0);
  return r.observers = null, r.observerSlots = null, r.comparator = t.equals || void 0, ys(r), Xm.bind(r);
}
function Ny(i) {
  return i && typeof i == "object" && "then" in i;
}
function qm(i, e, t) {
  let r, s, n;
  r = !0, s = i, n = {};
  let o = null, a = Jl, l = null, c = !1, h = !1, f = "initialValue" in n, u = typeof r == "function" && Qe(r);
  const g = /* @__PURE__ */ new Set(), [S, v] = (n.storage || ie)(n.initialValue), [d, O] = ie(void 0), [p, m] = ie(void 0, {
    equals: !1
  }), [_, b] = ie(f ? "ready" : "unresolved");
  me.context && (l = me.getNextContextId(), n.ssrLoadFrom === "initial" ? a = n.initialValue : me.load && me.has(l) && (a = me.load(l)));
  function w(R, $, E, D) {
    return o === R && (o = null, D !== void 0 && (f = !0), (R === a || $ === a) && n.onHydrated && queueMicrotask(() => n.onHydrated(D, {
      value: $
    })), a = Jl, J && R && c ? (J.promises.delete(R), c = !1, Rt(() => {
      J.running = !0, x($, E);
    }, !1)) : x($, E)), $;
  }
  function x(R, $) {
    Rt(() => {
      $ === void 0 && v(() => R), b($ !== void 0 ? "errored" : f ? "ready" : "unresolved"), O($);
      for (const E of g.keys()) E.decrement();
      g.clear();
    }, !1);
  }
  function y() {
    const R = Rr && Ir(Rr), $ = S(), E = d();
    if (E !== void 0 && !o) throw E;
    return we && !we.user && R && Td(() => {
      p(), o && (R.resolved && J && c ? J.promises.add(o) : g.has(R) || (R.increment(), g.add(R)));
    }), $;
  }
  function k(R = !0) {
    if (R !== !1 && h) return;
    h = !1;
    const $ = u ? u() : r;
    if (c = J && J.running, $ == null || $ === !1) {
      w(o, pt(S));
      return;
    }
    J && o && J.promises.delete(o);
    let E;
    const D = a !== Jl ? a : pt(() => {
      try {
        return s($, {
          value: S(),
          refetching: R
        });
      } catch (q) {
        E = q;
      }
    });
    if (E !== void 0) {
      w(o, void 0, ta(E), $);
      return;
    } else if (!Ny(D))
      return w(o, D, void 0, $), D;
    return o = D, "v" in D ? (D.s === 1 ? w(o, D.v, void 0, $) : w(o, void 0, ta(D.v), $), D) : (h = !0, queueMicrotask(() => h = !1), Rt(() => {
      b(f ? "refreshing" : "pending"), m();
    }, !1), D.then((q) => w(D, q, void 0, $), (q) => w(D, void 0, ta(q), $)));
  }
  Object.defineProperties(y, {
    state: {
      get: () => _()
    },
    error: {
      get: () => d()
    },
    loading: {
      get() {
        const R = _();
        return R === "pending" || R === "refreshing";
      }
    },
    latest: {
      get() {
        if (!f) return y();
        const R = d();
        if (R && !o) throw R;
        return S();
      }
    }
  });
  let T = Oe;
  return u ? Td(() => (T = Oe, k(!1))) : k(!1), [y, {
    refetch: (R) => nu(T, () => k(R)),
    mutate: v
  }];
}
function Bm(i) {
  return Rt(i, !1);
}
function pt(i) {
  if (we === null) return i();
  const e = we;
  we = null;
  try {
    return i();
  } finally {
    we = e;
  }
}
function su(i, e, t) {
  const r = Array.isArray(i);
  let s, n = t && t.defer;
  return (o) => {
    let a;
    if (r) {
      a = Array(i.length);
      for (let c = 0; c < i.length; c++) a[c] = i[c]();
    } else a = i();
    if (n)
      return n = !1, o;
    const l = pt(() => e(a, s, o));
    return s = a, l;
  };
}
function kt(i) {
  Tr(() => pt(i));
}
function ft(i) {
  return Oe === null || (Oe.cleanups === null ? Oe.cleanups = [i] : Oe.cleanups.push(i)), i;
}
function ph() {
  return we;
}
function eo() {
  return Oe;
}
function nu(i, e) {
  const t = Oe, r = we;
  Oe = i, we = null;
  try {
    return Rt(e, !0);
  } catch (s) {
    au(s);
  } finally {
    Oe = t, we = r;
  }
}
function Yy(i) {
  if (J && J.running)
    return i(), J.done;
  const e = we, t = Oe;
  return Promise.resolve().then(() => {
    we = e, Oe = t;
    let r;
    return Rr && (r = J || (J = {
      sources: /* @__PURE__ */ new Set(),
      effects: [],
      promises: /* @__PURE__ */ new Set(),
      disposed: /* @__PURE__ */ new Set(),
      queue: /* @__PURE__ */ new Set(),
      running: !0
    }), r.done || (r.done = new Promise((s) => r.resolve = s)), r.running = !0), Rt(i, !1), we = Oe = null, r ? r.done : void 0;
  });
}
const [H3, Rd] = /* @__PURE__ */ ie(!1);
function Fy(i) {
  st.push.apply(st, i), i.length = 0;
}
function to(i, e) {
  const t = Symbol("context");
  return {
    id: t,
    Provider: Jy(t),
    defaultValue: i
  };
}
function Ir(i) {
  let e;
  return Oe && Oe.context && (e = Oe.context[i.id]) !== void 0 ? e : i.defaultValue;
}
function ou(i) {
  const e = Qe(i), t = Qe(() => gh(e()));
  return t.toArray = () => {
    const r = t();
    return Array.isArray(r) ? r : r != null ? [r] : [];
  }, t;
}
let Rr;
function Hy() {
  return Rr || (Rr = to());
}
function Xm() {
  const i = J && J.running;
  if (this.sources && (i ? this.tState : this.state))
    if ((i ? this.tState : this.state) === jt) ys(this);
    else {
      const e = lt;
      lt = null, Rt(() => Ra(this), !1), lt = e;
    }
  if (we) {
    const e = this.observers ? this.observers.length : 0;
    we.sources ? (we.sources.push(this), we.sourceSlots.push(e)) : (we.sources = [this], we.sourceSlots = [e]), this.observers ? (this.observers.push(we), this.observerSlots.push(we.sources.length - 1)) : (this.observers = [we], this.observerSlots = [we.sources.length - 1]);
  }
  return i && J.sources.has(this) ? this.tValue : this.value;
}
function Im(i, e, t) {
  let r = J && J.running && J.sources.has(i) ? i.tValue : i.value;
  if (!i.comparator || !i.comparator(r, e)) {
    if (J) {
      const s = J.running;
      (s || !t && J.sources.has(i)) && (J.sources.add(i), i.tValue = e), s || (i.value = e);
    } else i.value = e;
    i.observers && i.observers.length && Rt(() => {
      for (let s = 0; s < i.observers.length; s += 1) {
        const n = i.observers[s], o = J && J.running;
        o && J.disposed.has(n) || ((o ? !n.tState : !n.state) && (n.pure ? lt.push(n) : st.push(n), n.observers && Wm(n)), o ? n.tState = jt : n.state = jt);
      }
      if (lt.length > 1e6)
        throw lt = [], new Error();
    }, !1);
  }
  return e;
}
function ys(i) {
  if (!i.fn) return;
  sr(i);
  const e = Sl;
  Ed(i, J && J.running && J.sources.has(i) ? i.tValue : i.value, e), J && !J.running && J.sources.has(i) && queueMicrotask(() => {
    Rt(() => {
      J && (J.running = !0), we = Oe = i, Ed(i, i.tValue, e), we = Oe = null;
    }, !1);
  });
}
function Ed(i, e, t) {
  let r;
  const s = Oe, n = we;
  we = Oe = i;
  try {
    r = i.fn(e);
  } catch (o) {
    return i.pure && (J && J.running ? (i.tState = jt, i.tOwned && i.tOwned.forEach(sr), i.tOwned = void 0) : (i.state = jt, i.owned && i.owned.forEach(sr), i.owned = null)), i.updatedAt = t + 1, au(o);
  } finally {
    we = n, Oe = s;
  }
  (!i.updatedAt || i.updatedAt <= t) && (i.updatedAt != null && "observers" in i ? Im(i, r, !0) : J && J.running && i.pure ? (J.sources.add(i), i.tValue = r) : i.value = r, i.updatedAt = t);
}
function _l(i, e, t, r = jt, s) {
  const n = {
    fn: i,
    state: r,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: Oe,
    context: Oe ? Oe.context : null,
    pure: t
  };
  return J && J.running && (n.state = 0, n.tState = r), Oe === null || Oe !== Dm && (J && J.running && Oe.pure ? Oe.tOwned ? Oe.tOwned.push(n) : Oe.tOwned = [n] : Oe.owned ? Oe.owned.push(n) : Oe.owned = [n]), n;
}
function Ta(i) {
  const e = J && J.running;
  if ((e ? i.tState : i.state) === 0) return;
  if ((e ? i.tState : i.state) === gn) return Ra(i);
  if (i.suspense && pt(i.suspense.inFallback)) return i.suspense.effects.push(i);
  const t = [i];
  for (; (i = i.owner) && (!i.updatedAt || i.updatedAt < Sl); ) {
    if (e && J.disposed.has(i)) return;
    (e ? i.tState : i.state) && t.push(i);
  }
  for (let r = t.length - 1; r >= 0; r--) {
    if (i = t[r], e) {
      let s = i, n = t[r + 1];
      for (; (s = s.owner) && s !== n; )
        if (J.disposed.has(s)) return;
    }
    if ((e ? i.tState : i.state) === jt)
      ys(i);
    else if ((e ? i.tState : i.state) === gn) {
      const s = lt;
      lt = null, Rt(() => Ra(i, t[0]), !1), lt = s;
    }
  }
}
function Rt(i, e) {
  if (lt) return i();
  let t = !1;
  e || (lt = []), st ? t = !0 : st = [], Sl++;
  try {
    const r = i();
    return Gy(t), r;
  } catch (r) {
    t || (st = null), lt = null, au(r);
  }
}
function Gy(i) {
  if (lt && (Zm(lt), lt = null), i) return;
  let e;
  if (J) {
    if (!J.promises.size && !J.queue.size) {
      const r = J.sources, s = J.disposed;
      st.push.apply(st, J.effects), e = J.resolve;
      for (const n of st)
        "tState" in n && (n.state = n.tState), delete n.tState;
      J = null, Rt(() => {
        for (const n of s) sr(n);
        for (const n of r) {
          if (n.value = n.tValue, n.owned)
            for (let o = 0, a = n.owned.length; o < a; o++) sr(n.owned[o]);
          n.tOwned && (n.owned = n.tOwned), delete n.tValue, delete n.tOwned, n.tState = 0;
        }
        Rd(!1);
      }, !1);
    } else if (J.running) {
      J.running = !1, J.effects.push.apply(J.effects, st), st = null, Rd(!0);
      return;
    }
  }
  const t = st;
  st = null, t.length && Rt(() => Mm(t), !1), e && e();
}
function Zm(i) {
  for (let e = 0; e < i.length; e++) Ta(i[e]);
}
function Ky(i) {
  let e, t = 0;
  for (e = 0; e < i.length; e++) {
    const r = i[e];
    r.user ? i[t++] = r : Ta(r);
  }
  if (me.context) {
    if (me.count) {
      me.effects || (me.effects = []), me.effects.push(...i.slice(0, t));
      return;
    }
    Fs();
  }
  for (me.effects && (me.done || !me.count) && (i = [...me.effects, ...i], t += me.effects.length, delete me.effects), e = 0; e < t; e++) Ta(i[e]);
}
function Ra(i, e) {
  const t = J && J.running;
  t ? i.tState = 0 : i.state = 0;
  for (let r = 0; r < i.sources.length; r += 1) {
    const s = i.sources[r];
    if (s.sources) {
      const n = t ? s.tState : s.state;
      n === jt ? s !== e && (!s.updatedAt || s.updatedAt < Sl) && Ta(s) : n === gn && Ra(s, e);
    }
  }
}
function Wm(i) {
  const e = J && J.running;
  for (let t = 0; t < i.observers.length; t += 1) {
    const r = i.observers[t];
    (e ? !r.tState : !r.state) && (e ? r.tState = gn : r.state = gn, r.pure ? lt.push(r) : st.push(r), r.observers && Wm(r));
  }
}
function sr(i) {
  let e;
  if (i.sources)
    for (; i.sources.length; ) {
      const t = i.sources.pop(), r = i.sourceSlots.pop(), s = t.observers;
      if (s && s.length) {
        const n = s.pop(), o = t.observerSlots.pop();
        r < s.length && (n.sourceSlots[o] = r, s[r] = n, t.observerSlots[r] = o);
      }
    }
  if (i.tOwned) {
    for (e = i.tOwned.length - 1; e >= 0; e--) sr(i.tOwned[e]);
    delete i.tOwned;
  }
  if (J && J.running && i.pure)
    zm(i, !0);
  else if (i.owned) {
    for (e = i.owned.length - 1; e >= 0; e--) sr(i.owned[e]);
    i.owned = null;
  }
  if (i.cleanups) {
    for (e = i.cleanups.length - 1; e >= 0; e--) i.cleanups[e]();
    i.cleanups = null;
  }
  J && J.running ? i.tState = 0 : i.state = 0;
}
function zm(i, e) {
  if (e || (i.tState = 0, J.disposed.add(i)), i.owned)
    for (let t = 0; t < i.owned.length; t++) zm(i.owned[t]);
}
function ta(i) {
  return i instanceof Error ? i : new Error(typeof i == "string" ? i : "Unknown error", {
    cause: i
  });
}
function au(i, e = Oe) {
  throw ta(i);
}
function gh(i) {
  if (typeof i == "function" && !i.length) return gh(i());
  if (Array.isArray(i)) {
    const e = [];
    for (let t = 0; t < i.length; t++) {
      const r = gh(i[t]);
      Array.isArray(r) ? e.push.apply(e, r) : e.push(r);
    }
    return e;
  }
  return i;
}
function Jy(i, e) {
  return function(r) {
    let s;
    return ce(() => s = pt(() => (Oe.context = {
      ...Oe.context,
      [i]: r.value
    }, ou(() => r.children))), void 0), s;
  };
}
const e1 = Symbol("fallback");
function Ad(i) {
  for (let e = 0; e < i.length; e++) i[e]();
}
function t1(i, e, t = {}) {
  let r = [], s = [], n = [], o = 0, a = e.length > 1 ? [] : null;
  return ft(() => Ad(n)), () => {
    let l = i() || [], c = l.length, h, f;
    return l[Oh], pt(() => {
      let g, S, v, d, O, p, m, _, b;
      if (c === 0)
        o !== 0 && (Ad(n), n = [], r = [], s = [], o = 0, a && (a = [])), t.fallback && (r = [e1], s[0] = es((w) => (n[0] = w, t.fallback())), o = 1);
      else if (o === 0) {
        for (s = new Array(c), f = 0; f < c; f++)
          r[f] = l[f], s[f] = es(u);
        o = c;
      } else {
        for (v = new Array(c), d = new Array(c), a && (O = new Array(c)), p = 0, m = Math.min(o, c); p < m && r[p] === l[p]; p++) ;
        for (m = o - 1, _ = c - 1; m >= p && _ >= p && r[m] === l[_]; m--, _--)
          v[_] = s[m], d[_] = n[m], a && (O[_] = a[m]);
        for (g = /* @__PURE__ */ new Map(), S = new Array(_ + 1), f = _; f >= p; f--)
          b = l[f], h = g.get(b), S[f] = h === void 0 ? -1 : h, g.set(b, f);
        for (h = p; h <= m; h++)
          b = r[h], f = g.get(b), f !== void 0 && f !== -1 ? (v[f] = s[h], d[f] = n[h], a && (O[f] = a[h]), f = S[f], g.set(b, f)) : n[h]();
        for (f = p; f < c; f++)
          f in v ? (s[f] = v[f], n[f] = d[f], a && (a[f] = O[f], a[f](f))) : s[f] = es(u);
        s = s.slice(0, o = c), r = l.slice(0);
      }
      return s;
    });
    function u(g) {
      if (n[f] = g, a) {
        const [S, v] = ie(f);
        return a[f] = v, e(l[f], S);
      }
      return e(l[f]);
    }
  };
}
function B(i, e) {
  return pt(() => i(e || {}));
}
function wo() {
  return !0;
}
const mh = {
  get(i, e, t) {
    return e === Ut ? t : i.get(e);
  },
  has(i, e) {
    return e === Ut ? !0 : i.has(e);
  },
  set: wo,
  deleteProperty: wo,
  getOwnPropertyDescriptor(i, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return i.get(e);
      },
      set: wo,
      deleteProperty: wo
    };
  },
  ownKeys(i) {
    return i.keys();
  }
};
function ec(i) {
  return (i = typeof i == "function" ? i() : i) ? i : {};
}
function i1() {
  for (let i = 0, e = this.length; i < e; ++i) {
    const t = this[i]();
    if (t !== void 0) return t;
  }
}
function mn(...i) {
  let e = !1;
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    e = e || !!a && Ut in a, i[o] = typeof a == "function" ? (e = !0, Qe(a)) : a;
  }
  if (Lm && e)
    return new Proxy({
      get(o) {
        for (let a = i.length - 1; a >= 0; a--) {
          const l = ec(i[a])[o];
          if (l !== void 0) return l;
        }
      },
      has(o) {
        for (let a = i.length - 1; a >= 0; a--)
          if (o in ec(i[a])) return !0;
        return !1;
      },
      keys() {
        const o = [];
        for (let a = 0; a < i.length; a++) o.push(...Object.keys(ec(i[a])));
        return [...new Set(o)];
      }
    }, mh);
  const t = {}, r = /* @__PURE__ */ Object.create(null);
  for (let o = i.length - 1; o >= 0; o--) {
    const a = i[o];
    if (!a) continue;
    const l = Object.getOwnPropertyNames(a);
    for (let c = l.length - 1; c >= 0; c--) {
      const h = l[c];
      if (h === "__proto__" || h === "constructor") continue;
      const f = Object.getOwnPropertyDescriptor(a, h);
      if (!r[h])
        r[h] = f.get ? {
          enumerable: !0,
          configurable: !0,
          get: i1.bind(t[h] = [f.get.bind(a)])
        } : f.value !== void 0 ? f : void 0;
      else {
        const u = t[h];
        u && (f.get ? u.push(f.get.bind(a)) : f.value !== void 0 && u.push(() => f.value));
      }
    }
  }
  const s = {}, n = Object.keys(r);
  for (let o = n.length - 1; o >= 0; o--) {
    const a = n[o], l = r[a];
    l && l.get ? Object.defineProperty(s, a, l) : s[a] = l ? l.value : void 0;
  }
  return s;
}
function lu(i, ...e) {
  if (Lm && Ut in i) {
    const s = new Set(e.length > 1 ? e.flat() : e[0]), n = e.map((o) => new Proxy({
      get(a) {
        return o.includes(a) ? i[a] : void 0;
      },
      has(a) {
        return o.includes(a) && a in i;
      },
      keys() {
        return o.filter((a) => a in i);
      }
    }, mh));
    return n.push(new Proxy({
      get(o) {
        return s.has(o) ? void 0 : i[o];
      },
      has(o) {
        return s.has(o) ? !1 : o in i;
      },
      keys() {
        return Object.keys(i).filter((o) => !s.has(o));
      }
    }, mh)), n;
  }
  const t = {}, r = e.map(() => ({}));
  for (const s of Object.getOwnPropertyNames(i)) {
    const n = Object.getOwnPropertyDescriptor(i, s), o = !n.get && !n.set && n.enumerable && n.writable && n.configurable;
    let a = !1, l = 0;
    for (const c of e)
      c.includes(s) && (a = !0, o ? r[l][s] = n.value : Object.defineProperty(r[l], s, n)), ++l;
    a || (o ? t[s] = n.value : Object.defineProperty(t, s, n));
  }
  return [...r, t];
}
const r1 = (i) => `Stale read from <${i}>.`;
function rt(i) {
  const e = "fallback" in i && {
    fallback: () => i.fallback
  };
  return Qe(t1(() => i.each, i.children, e || void 0));
}
function pe(i) {
  const e = i.keyed, t = Qe(() => i.when, void 0, void 0), r = e ? t : Qe(t, void 0, {
    equals: (s, n) => !s == !n
  });
  return Qe(() => {
    const s = r();
    if (s) {
      const n = i.children;
      return typeof n == "function" && n.length > 0 ? pt(() => n(e ? s : () => {
        if (!pt(r)) throw r1("Show");
        return t();
      })) : n;
    }
    return i.fallback;
  }, void 0, void 0);
}
const s1 = /* @__PURE__ */ to();
function n1(i) {
  let e = 0, t, r, s, n, o;
  const [a, l] = ie(!1), c = Hy(), h = {
    increment: () => {
      ++e === 1 && l(!0);
    },
    decrement: () => {
      --e === 0 && l(!1);
    },
    inFallback: a,
    effects: [],
    resolved: !1
  }, f = eo();
  if (me.context && me.load) {
    const S = me.getContextId();
    let v = me.load(S);
    if (v && (typeof v != "object" || v.s !== 1 ? s = v : me.gather(S)), s && s !== "$$f") {
      const [d, O] = ie(void 0, {
        equals: !1
      });
      n = d, s.then(() => {
        if (me.done) return O();
        me.gather(S), Fs(r), O(), Fs();
      }, (p) => {
        o = p, O();
      });
    }
  }
  const u = Ir(s1);
  u && (t = u.register(h.inFallback));
  let g;
  return ft(() => g && g()), B(c.Provider, {
    value: h,
    get children() {
      return Qe(() => {
        if (o) throw o;
        if (r = me.context, n)
          return n(), n = void 0;
        r && s === "$$f" && Fs();
        const S = Qe(() => i.children);
        return Qe((v) => {
          const d = h.inFallback(), {
            showContent: O = !0,
            showFallback: p = !0
          } = t ? t() : {};
          if ((!d || s && s !== "$$f") && O)
            return h.resolved = !0, g && g(), g = r = s = void 0, Fy(h.effects), S();
          if (p)
            return g ? v : es((m) => (g = m, r && (Fs({
              id: r.id + "F",
              count: 0
            }), r = void 0), i.fallback), f);
        });
      });
    }
  });
}
const o1 = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"], a1 = /* @__PURE__ */ new Set(["className", "value", "readOnly", "noValidate", "formNoValidate", "isMap", "noModule", "playsInline", ...o1]), l1 = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]), c1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
}), h1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  novalidate: {
    $: "noValidate",
    FORM: 1
  },
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function f1(i, e) {
  const t = h1[i];
  return typeof t == "object" ? t[e] ? t.$ : void 0 : t;
}
const u1 = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]), ct = (i) => Qe(() => i());
function d1(i, e, t) {
  let r = t.length, s = e.length, n = r, o = 0, a = 0, l = e[s - 1].nextSibling, c = null;
  for (; o < s || a < n; ) {
    if (e[o] === t[a]) {
      o++, a++;
      continue;
    }
    for (; e[s - 1] === t[n - 1]; )
      s--, n--;
    if (s === o) {
      const h = n < r ? a ? t[a - 1].nextSibling : t[n - a] : l;
      for (; a < n; ) i.insertBefore(t[a++], h);
    } else if (n === a)
      for (; o < s; )
        (!c || !c.has(e[o])) && e[o].remove(), o++;
    else if (e[o] === t[n - 1] && t[a] === e[s - 1]) {
      const h = e[--s].nextSibling;
      i.insertBefore(t[a++], e[o++].nextSibling), i.insertBefore(t[--n], h), e[s] = t[n];
    } else {
      if (!c) {
        c = /* @__PURE__ */ new Map();
        let f = a;
        for (; f < n; ) c.set(t[f], f++);
      }
      const h = c.get(e[o]);
      if (h != null)
        if (a < h && h < n) {
          let f = o, u = 1, g;
          for (; ++f < s && f < n && !((g = c.get(e[f])) == null || g !== h + u); )
            u++;
          if (u > h - a) {
            const S = e[o];
            for (; a < h; ) i.insertBefore(t[a++], S);
          } else i.replaceChild(t[a++], e[o++]);
        } else o++;
      else e[o++].remove();
    }
  }
}
const Ld = "_$DX_DELEGATE";
function O1(i, e, t, r = {}) {
  let s;
  return es((n) => {
    s = n, e === document ? i() : X(e, i(), e.firstChild ? null : void 0, t);
  }, r.owner), () => {
    s(), e.textContent = "";
  };
}
function Y(i, e, t, r) {
  let s;
  const n = () => {
    const a = r ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
    return a.innerHTML = i, t ? a.content.firstChild.firstChild : r ? a.firstChild : a.content.firstChild;
  }, o = e ? () => pt(() => document.importNode(s || (s = n()), !0)) : () => (s || (s = n())).cloneNode(!0);
  return o.cloneNode = o, o;
}
function He(i, e = window.document) {
  const t = e[Ld] || (e[Ld] = /* @__PURE__ */ new Set());
  for (let r = 0, s = i.length; r < s; r++) {
    const n = i[r];
    t.has(n) || (t.add(n), e.addEventListener(n, v1));
  }
}
function Ee(i, e, t) {
  io(i) || (t == null ? i.removeAttribute(e) : i.setAttribute(e, t));
}
function p1(i, e, t) {
  io(i) || (t ? i.setAttribute(e, "") : i.removeAttribute(e));
}
function Fe(i, e) {
  io(i) || (e == null ? i.removeAttribute("class") : i.className = e);
}
function cu(i, e, t, r) {
  if (r)
    Array.isArray(t) ? (i[`$$${e}`] = t[0], i[`$$${e}Data`] = t[1]) : i[`$$${e}`] = t;
  else if (Array.isArray(t)) {
    const s = t[0];
    i.addEventListener(e, t[0] = (n) => s.call(i, t[1], n));
  } else i.addEventListener(e, t, typeof t != "function" && t);
}
function vn(i, e, t = {}) {
  const r = Object.keys(e || {}), s = Object.keys(t);
  let n, o;
  for (n = 0, o = s.length; n < o; n++) {
    const a = s[n];
    !a || a === "undefined" || e[a] || (Md(i, a, !1), delete t[a]);
  }
  for (n = 0, o = r.length; n < o; n++) {
    const a = r[n], l = !!e[a];
    !a || a === "undefined" || t[a] === l || !l || (Md(i, a, !0), t[a] = l);
  }
  return t;
}
function Sn(i, e, t) {
  if (!e) return t ? Ee(i, "style") : e;
  const r = i.style;
  if (typeof e == "string") return r.cssText = e;
  typeof t == "string" && (r.cssText = t = void 0), t || (t = {}), e || (e = {});
  let s, n;
  for (n in t)
    e[n] == null && r.removeProperty(n), delete t[n];
  for (n in e)
    s = e[n], s !== t[n] && (r.setProperty(n, s), t[n] = s);
  return t;
}
function bl(i, e = {}, t, r) {
  const s = {};
  return r || ce(() => s.children = _n(i, e.children, s.children)), ce(() => typeof e.ref == "function" && mi(e.ref, i)), ce(() => g1(i, e, t, !0, s, !0)), s;
}
function mi(i, e, t) {
  return pt(() => i(e, t));
}
function X(i, e, t, r) {
  if (t !== void 0 && !r && (r = []), typeof e != "function") return _n(i, e, r, t);
  ce((s) => _n(i, e(), s, t), r);
}
function g1(i, e, t, r, s = {}, n = !1) {
  e || (e = {});
  for (const o in s)
    if (!(o in e)) {
      if (o === "children") continue;
      s[o] = Dd(i, o, null, s[o], t, n, e);
    }
  for (const o in e) {
    if (o === "children")
      continue;
    const a = e[o];
    s[o] = Dd(i, o, a, s[o], t, n, e);
  }
}
function io(i) {
  return !!me.context && !me.done && (!i || i.isConnected);
}
function m1(i) {
  return i.toLowerCase().replace(/-([a-z])/g, (e, t) => t.toUpperCase());
}
function Md(i, e, t) {
  const r = e.trim().split(/\s+/);
  for (let s = 0, n = r.length; s < n; s++) i.classList.toggle(r[s], t);
}
function Dd(i, e, t, r, s, n, o) {
  let a, l, c, h, f;
  if (e === "style") return Sn(i, t, r);
  if (e === "classList") return vn(i, t, r);
  if (t === r) return r;
  if (e === "ref")
    n || t(i);
  else if (e.slice(0, 3) === "on:") {
    const u = e.slice(3);
    r && i.removeEventListener(u, r, typeof r != "function" && r), t && i.addEventListener(u, t, typeof t != "function" && t);
  } else if (e.slice(0, 10) === "oncapture:") {
    const u = e.slice(10);
    r && i.removeEventListener(u, r, !0), t && i.addEventListener(u, t, !0);
  } else if (e.slice(0, 2) === "on") {
    const u = e.slice(2).toLowerCase(), g = u1.has(u);
    if (!g && r) {
      const S = Array.isArray(r) ? r[0] : r;
      i.removeEventListener(u, S);
    }
    (g || t) && (cu(i, u, t, g), g && He([u]));
  } else if (e.slice(0, 5) === "attr:")
    Ee(i, e.slice(5), t);
  else if (e.slice(0, 5) === "bool:")
    p1(i, e.slice(5), t);
  else if ((f = e.slice(0, 5) === "prop:") || (c = l1.has(e)) || (h = f1(e, i.tagName)) || (l = a1.has(e)) || (a = i.nodeName.includes("-") || "is" in o)) {
    if (f)
      e = e.slice(5), l = !0;
    else if (io(i)) return t;
    e === "class" || e === "className" ? Fe(i, t) : a && !l && !c ? i[m1(e)] = t : i[h || e] = t;
  } else
    Ee(i, c1[e] || e, t);
  return t;
}
function v1(i) {
  if (me.registry && me.events && me.events.find(([l, c]) => c === i))
    return;
  let e = i.target;
  const t = `$$${i.type}`, r = i.target, s = i.currentTarget, n = (l) => Object.defineProperty(i, "target", {
    configurable: !0,
    value: l
  }), o = () => {
    const l = e[t];
    if (l && !e.disabled) {
      const c = e[`${t}Data`];
      if (c !== void 0 ? l.call(e, c, i) : l.call(e, i), i.cancelBubble) return;
    }
    return e.host && typeof e.host != "string" && !e.host._$host && e.contains(i.target) && n(e.host), !0;
  }, a = () => {
    for (; o() && (e = e._$host || e.parentNode || e.host); ) ;
  };
  if (Object.defineProperty(i, "currentTarget", {
    configurable: !0,
    get() {
      return e || document;
    }
  }), me.registry && !me.done && (me.done = _$HY.done = !0), i.composedPath) {
    const l = i.composedPath();
    n(l[0]);
    for (let c = 0; c < l.length - 2 && (e = l[c], !!o()); c++) {
      if (e._$host) {
        e = e._$host, a();
        break;
      }
      if (e.parentNode === s)
        break;
    }
  } else a();
  n(r);
}
function _n(i, e, t, r, s) {
  const n = io(i);
  if (n) {
    !t && (t = [...i.childNodes]);
    let l = [];
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.nodeType === 8 && h.data.slice(0, 2) === "!$" ? h.remove() : l.push(h);
    }
    t = l;
  }
  for (; typeof t == "function"; ) t = t();
  if (e === t) return t;
  const o = typeof e, a = r !== void 0;
  if (i = a && t[0] && t[0].parentNode || i, o === "string" || o === "number") {
    if (n || o === "number" && (e = e.toString(), e === t))
      return t;
    if (a) {
      let l = t[0];
      l && l.nodeType === 3 ? l.data !== e && (l.data = e) : l = document.createTextNode(e), t = Wr(i, t, r, l);
    } else
      t !== "" && typeof t == "string" ? t = i.firstChild.data = e : t = i.textContent = e;
  } else if (e == null || o === "boolean") {
    if (n) return t;
    t = Wr(i, t, r);
  } else {
    if (o === "function")
      return ce(() => {
        let l = e();
        for (; typeof l == "function"; ) l = l();
        t = _n(i, l, t, r);
      }), () => t;
    if (Array.isArray(e)) {
      const l = [], c = t && Array.isArray(t);
      if (vh(l, e, t, s))
        return ce(() => t = _n(i, l, t, r, !0)), () => t;
      if (n) {
        if (!l.length) return t;
        if (r === void 0) return t = [...i.childNodes];
        let h = l[0];
        if (h.parentNode !== i) return t;
        const f = [h];
        for (; (h = h.nextSibling) !== r; ) f.push(h);
        return t = f;
      }
      if (l.length === 0) {
        if (t = Wr(i, t, r), a) return t;
      } else c ? t.length === 0 ? qd(i, l, r) : d1(i, t, l) : (t && Wr(i), qd(i, l));
      t = l;
    } else if (e.nodeType) {
      if (n && e.parentNode) return t = a ? [e] : e;
      if (Array.isArray(t)) {
        if (a) return t = Wr(i, t, r, e);
        Wr(i, t, null, e);
      } else t == null || t === "" || !i.firstChild ? i.appendChild(e) : i.replaceChild(e, i.firstChild);
      t = e;
    }
  }
  return t;
}
function vh(i, e, t, r) {
  let s = !1;
  for (let n = 0, o = e.length; n < o; n++) {
    let a = e[n], l = t && t[i.length], c;
    if (!(a == null || a === !0 || a === !1)) if ((c = typeof a) == "object" && a.nodeType)
      i.push(a);
    else if (Array.isArray(a))
      s = vh(i, a, l) || s;
    else if (c === "function")
      if (r) {
        for (; typeof a == "function"; ) a = a();
        s = vh(i, Array.isArray(a) ? a : [a], Array.isArray(l) ? l : [l]) || s;
      } else
        i.push(a), s = !0;
    else {
      const h = String(a);
      l && l.nodeType === 3 && l.data === h ? i.push(l) : i.push(document.createTextNode(h));
    }
  }
  return s;
}
function qd(i, e, t = null) {
  for (let r = 0, s = e.length; r < s; r++) i.insertBefore(e[r], t);
}
function Wr(i, e, t, r) {
  if (t === void 0) return i.textContent = "";
  const s = r || document.createTextNode("");
  if (e.length) {
    let n = !1;
    for (let o = e.length - 1; o >= 0; o--) {
      const a = e[o];
      if (s !== a) {
        const l = a.parentNode === i;
        !n && !o ? l ? i.replaceChild(s, a) : i.insertBefore(s, t) : l && a.remove();
      } else n = !0;
    }
  } else i.insertBefore(s, t);
  return [s];
}
const S1 = !1;
function Vm() {
  let i = /* @__PURE__ */ new Set();
  function e(s) {
    return i.add(s), () => i.delete(s);
  }
  let t = !1;
  function r(s, n) {
    if (t)
      return !(t = !1);
    const o = {
      to: s,
      options: n,
      defaultPrevented: !1,
      preventDefault: () => o.defaultPrevented = !0
    };
    for (const a of i)
      a.listener({
        ...o,
        from: a.location,
        retry: (l) => {
          l && (t = !0), a.navigate(s, { ...n, resolve: !1 });
        }
      });
    return !o.defaultPrevented;
  }
  return {
    subscribe: e,
    confirm: r
  };
}
let Sh;
function hu() {
  (!window.history.state || window.history.state._depth == null) && window.history.replaceState({ ...window.history.state, _depth: window.history.length - 1 }, ""), Sh = window.history.state._depth;
}
hu();
function _1(i) {
  return {
    ...i,
    _depth: window.history.state && window.history.state._depth
  };
}
function b1(i, e) {
  let t = !1;
  return () => {
    const r = Sh;
    hu();
    const s = r == null ? null : Sh - r;
    if (t) {
      t = !1;
      return;
    }
    s && e(s) ? (t = !0, window.history.go(-s)) : i();
  };
}
const y1 = /^(?:[a-z0-9]+:)?\/\//i, w1 = /^\/+|(\/)\/+$/g, Um = "http://sr";
function Cr(i, e = !1) {
  const t = i.replace(w1, "$1");
  return t ? e || /^[?#]/.test(t) ? t : "/" + t : "";
}
function ia(i, e, t) {
  if (y1.test(e))
    return;
  const r = Cr(i), s = t && Cr(t);
  let n = "";
  return !s || e.startsWith("/") ? n = r : s.toLowerCase().indexOf(r.toLowerCase()) !== 0 ? n = r + s : n = s, (n || "/") + Cr(e, !n);
}
function x1(i, e) {
  if (i == null)
    throw new Error(e);
  return i;
}
function k1(i, e) {
  return Cr(i).replace(/\/*(\*.*)?$/g, "") + Cr(e);
}
function jm(i) {
  const e = {};
  return i.searchParams.forEach((t, r) => {
    r in e ? Array.isArray(e[r]) ? e[r].push(t) : e[r] = [e[r], t] : e[r] = t;
  }), e;
}
function C1(i, e, t) {
  const [r, s] = i.split("/*", 2), n = r.split("/").filter(Boolean), o = n.length;
  return (a) => {
    const l = a.split("/").filter(Boolean), c = l.length - o;
    if (c < 0 || c > 0 && s === void 0 && !e)
      return null;
    const h = {
      path: o ? "" : "/",
      params: {}
    }, f = (u) => t === void 0 ? void 0 : t[u];
    for (let u = 0; u < o; u++) {
      const g = n[u], S = g[0] === ":", v = S ? l[u] : l[u].toLowerCase(), d = S ? g.slice(1) : g.toLowerCase();
      if (S && tc(v, f(d)))
        h.params[d] = v;
      else if (S || !tc(v, d))
        return null;
      h.path += `/${v}`;
    }
    if (s) {
      const u = c ? l.slice(-c).join("/") : "";
      if (tc(u, f(s)))
        h.params[s] = u;
      else
        return null;
    }
    return h;
  };
}
function tc(i, e) {
  const t = (r) => r === i;
  return e === void 0 ? !0 : typeof e == "string" ? t(e) : typeof e == "function" ? e(i) : Array.isArray(e) ? e.some(t) : e instanceof RegExp ? e.test(i) : !1;
}
function Q1(i) {
  const [e, t] = i.pattern.split("/*", 2), r = e.split("/").filter(Boolean);
  return r.reduce((s, n) => s + (n.startsWith(":") ? 2 : 3), r.length - (t === void 0 ? 0 : 1));
}
function Nm(i) {
  const e = /* @__PURE__ */ new Map(), t = eo();
  return new Proxy({}, {
    get(r, s) {
      return e.has(s) || nu(t, () => e.set(s, Qe(() => i()[s]))), e.get(s)();
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    },
    ownKeys() {
      return Reflect.ownKeys(i());
    }
  });
}
function Ym(i) {
  let e = /(\/?\:[^\/]+)\?/.exec(i);
  if (!e)
    return [i];
  let t = i.slice(0, e.index), r = i.slice(e.index + e[0].length);
  const s = [t, t += e[1]];
  for (; e = /^(\/\:[^\/]+)\?/.exec(r); )
    s.push(t += e[1]), r = r.slice(e[0].length);
  return Ym(r).reduce((n, o) => [...n, ...s.map((a) => a + o)], []);
}
const P1 = 100, Fm = to(), fu = to(), yl = () => x1(Ir(Fm), "<A> and 'use' router primitives can be only used inside a Route."), $1 = () => Ir(fu) || yl().base, T1 = (i) => {
  const e = $1();
  return Qe(() => e.resolvePath(i()));
}, R1 = (i) => {
  const e = yl();
  return Qe(() => {
    const t = i();
    return t !== void 0 ? e.renderPath(t) : t;
  });
}, hr = () => yl().navigatorFactory(), Hm = () => yl().location;
function E1(i, e = "") {
  const { component: t, preload: r, load: s, children: n, info: o } = i, a = !n || Array.isArray(n) && !n.length, l = {
    key: i,
    component: t,
    preload: r || s,
    info: o
  };
  return Gm(i.path).reduce((c, h) => {
    for (const f of Ym(h)) {
      const u = k1(e, f);
      let g = a ? u : u.split("/*", 1)[0];
      g = g.split("/").map((S) => S.startsWith(":") || S.startsWith("*") ? S : encodeURIComponent(S)).join("/"), c.push({
        ...l,
        originalPath: h,
        pattern: g,
        matcher: C1(g, !a, i.matchFilters)
      });
    }
    return c;
  }, []);
}
function A1(i, e = 0) {
  return {
    routes: i,
    score: Q1(i[i.length - 1]) * 1e4 - e,
    matcher(t) {
      const r = [];
      for (let s = i.length - 1; s >= 0; s--) {
        const n = i[s], o = n.matcher(t);
        if (!o)
          return null;
        r.unshift({
          ...o,
          route: n
        });
      }
      return r;
    }
  };
}
function Gm(i) {
  return Array.isArray(i) ? i : [i];
}
function Km(i, e = "", t = [], r = []) {
  const s = Gm(i);
  for (let n = 0, o = s.length; n < o; n++) {
    const a = s[n];
    if (a && typeof a == "object") {
      a.hasOwnProperty("path") || (a.path = "");
      const l = E1(a, e);
      for (const c of l) {
        t.push(c);
        const h = Array.isArray(a.children) && a.children.length === 0;
        if (a.children && !h)
          Km(a.children, c.pattern, t, r);
        else {
          const f = A1([...t], r.length);
          r.push(f);
        }
        t.pop();
      }
    }
  }
  return t.length ? r : r.sort((n, o) => o.score - n.score);
}
function ic(i, e) {
  for (let t = 0, r = i.length; t < r; t++) {
    const s = i[t].matcher(e);
    if (s)
      return s;
  }
  return [];
}
function L1(i, e, t) {
  const r = new URL(Um), s = Qe((h) => {
    const f = i();
    try {
      return new URL(f, r);
    } catch {
      return console.error(`Invalid path ${f}`), h;
    }
  }, r, {
    equals: (h, f) => h.href === f.href
  }), n = Qe(() => s().pathname), o = Qe(() => s().search, !0), a = Qe(() => s().hash), l = () => "", c = su(o, () => jm(s()));
  return {
    get pathname() {
      return n();
    },
    get search() {
      return o();
    },
    get hash() {
      return a();
    },
    get state() {
      return e();
    },
    get key() {
      return l();
    },
    query: t ? t(c) : Nm(c)
  };
}
let mr;
function M1() {
  return mr;
}
function D1(i, e, t, r = {}) {
  const { signal: [s, n], utils: o = {} } = i, a = o.parsePath || ((D) => D), l = o.renderPath || ((D) => D), c = o.beforeLeave || Vm(), h = ia("", r.base || "");
  if (h === void 0)
    throw new Error(`${h} is not a valid base path`);
  h && !s().value && n({ value: h, replace: !0, scroll: !1 });
  const [f, u] = ie(!1);
  let g;
  const S = (D, q) => {
    q.value === v() && q.state === O() || (g === void 0 && u(!0), mr = D, g = q, Yy(() => {
      g === q && (d(g.value), p(g.state), b[1]((W) => W.filter((z) => z.pending)));
    }).finally(() => {
      g === q && Bm(() => {
        mr = void 0, D === "navigate" && $(g), u(!1), g = void 0;
      });
    }));
  }, [v, d] = ie(s().value), [O, p] = ie(s().state), m = L1(v, O, o.queryWrapper), _ = [], b = ie([]), w = Qe(() => typeof r.transformUrl == "function" ? ic(e(), r.transformUrl(m.pathname)) : ic(e(), m.pathname)), x = () => {
    const D = w(), q = {};
    for (let W = 0; W < D.length; W++)
      Object.assign(q, D[W].params);
    return q;
  }, y = o.paramsWrapper ? o.paramsWrapper(x, e) : Nm(x), k = {
    pattern: h,
    path: () => h,
    outlet: () => null,
    resolvePath(D) {
      return ia(h, D);
    }
  };
  return ce(su(s, (D) => S("native", D), { defer: !0 })), {
    base: k,
    location: m,
    params: y,
    isRouting: f,
    renderPath: l,
    parsePath: a,
    navigatorFactory: R,
    matches: w,
    beforeLeave: c,
    preloadRoute: E,
    singleFlight: r.singleFlight === void 0 ? !0 : r.singleFlight,
    submissions: b
  };
  function T(D, q, W) {
    pt(() => {
      if (typeof q == "number") {
        q && (o.go ? o.go(q) : console.warn("Router integration does not support relative routing"));
        return;
      }
      const z = !q || q[0] === "?", { replace: Q, resolve: A, scroll: L, state: M } = {
        replace: !1,
        resolve: !z,
        scroll: !0,
        ...W
      }, U = A ? D.resolvePath(q) : ia(z && m.pathname || "", q);
      if (U === void 0)
        throw new Error(`Path '${q}' is not a routable path`);
      if (_.length >= P1)
        throw new Error("Too many redirects");
      const F = v();
      (U !== F || M !== O()) && (S1 || c.confirm(U, W) && (_.push({ value: F, replace: Q, scroll: L, state: O() }), S("navigate", {
        value: U,
        state: M
      })));
    });
  }
  function R(D) {
    return D = D || Ir(fu) || k, (q, W) => T(D, q, W);
  }
  function $(D) {
    const q = _[0];
    q && (n({
      ...D,
      replace: q.replace,
      scroll: q.scroll
    }), _.length = 0);
  }
  function E(D, q) {
    const W = ic(e(), D.pathname), z = mr;
    mr = "preload";
    for (let Q in W) {
      const { route: A, params: L } = W[Q];
      A.component && A.component.preload && A.component.preload();
      const { preload: M } = A;
      q && M && nu(t(), () => M({
        params: L,
        location: {
          pathname: D.pathname,
          search: D.search,
          hash: D.hash,
          query: jm(D),
          state: null,
          key: ""
        },
        intent: "preload"
      }));
    }
    mr = z;
  }
}
function q1(i, e, t, r) {
  const { base: s, location: n, params: o } = i, { pattern: a, component: l, preload: c } = r().route, h = Qe(() => r().path);
  l && l.preload && l.preload();
  const f = c ? c({ params: o, location: n, intent: mr || "initial" }) : void 0;
  return {
    parent: e,
    pattern: a,
    path: h,
    outlet: () => l ? B(l, {
      params: o,
      location: n,
      data: f,
      get children() {
        return t();
      }
    }) : t(),
    resolvePath(g) {
      return ia(s.path(), g, h());
    }
  };
}
const B1 = (i) => (e) => {
  const {
    base: t
  } = e, r = ou(() => e.children), s = Qe(() => Km(r(), e.base || ""));
  let n;
  const o = D1(i, s, () => n, {
    base: t,
    singleFlight: e.singleFlight,
    transformUrl: e.transformUrl
  });
  return i.create && i.create(o), B(Fm.Provider, {
    value: o,
    get children() {
      return B(X1, {
        routerState: o,
        get root() {
          return e.root;
        },
        get preload() {
          return e.rootPreload || e.rootLoad;
        },
        get children() {
          return [ct(() => (n = eo()) && null), B(I1, {
            routerState: o,
            get branches() {
              return s();
            }
          })];
        }
      });
    }
  });
};
function X1(i) {
  const e = i.routerState.location, t = i.routerState.params, r = Qe(() => i.preload && pt(() => {
    i.preload({
      params: t,
      location: e,
      intent: M1() || "initial"
    });
  }));
  return B(pe, {
    get when() {
      return i.root;
    },
    keyed: !0,
    get fallback() {
      return i.children;
    },
    children: (s) => B(s, {
      params: t,
      location: e,
      get data() {
        return r();
      },
      get children() {
        return i.children;
      }
    })
  });
}
function I1(i) {
  const e = [];
  let t;
  const r = Qe(su(i.routerState.matches, (s, n, o) => {
    let a = n && s.length === n.length;
    const l = [];
    for (let c = 0, h = s.length; c < h; c++) {
      const f = n && n[c], u = s[c];
      o && f && u.route.key === f.route.key ? l[c] = o[c] : (a = !1, e[c] && e[c](), es((g) => {
        e[c] = g, l[c] = q1(i.routerState, l[c - 1] || i.routerState.base, Bd(() => r()[c + 1]), () => i.routerState.matches()[c]);
      }));
    }
    return e.splice(s.length).forEach((c) => c()), o && a ? o : (t = l[0], l);
  }));
  return Bd(() => r() && t)();
}
const Bd = (i) => () => B(pe, {
  get when() {
    return i();
  },
  keyed: !0,
  children: (e) => B(fu.Provider, {
    value: e,
    get children() {
      return e.outlet();
    }
  })
}), Qi = (i) => {
  const e = ou(() => i.children);
  return mn(i, {
    get children() {
      return e();
    }
  });
};
function Z1([i, e], t, r) {
  return [i, r ? (s) => e(r(s)) : e];
}
function W1(i) {
  let e = !1;
  const t = (s) => typeof s == "string" ? { value: s } : s, r = Z1(ie(t(i.get()), {
    equals: (s, n) => s.value === n.value && s.state === n.state
  }), void 0, (s) => (!e && i.set(s), me.registry && !me.done && (me.done = !0), s));
  return i.init && ft(i.init((s = i.get()) => {
    e = !0, r[1](t(s)), e = !1;
  })), B1({
    signal: r,
    create: i.create,
    utils: i.utils
  });
}
function z1(i, e, t) {
  return i.addEventListener(e, t), () => i.removeEventListener(e, t);
}
function V1(i, e) {
  const t = i && document.getElementById(i);
  t ? t.scrollIntoView() : e && window.scrollTo(0, 0);
}
const U1 = /* @__PURE__ */ new Map();
function j1(i = !0, e = !1, t = "/_server", r) {
  return (s) => {
    const n = s.base.path(), o = s.navigatorFactory(s.base);
    let a, l;
    function c(v) {
      return v.namespaceURI === "http://www.w3.org/2000/svg";
    }
    function h(v) {
      if (v.defaultPrevented || v.button !== 0 || v.metaKey || v.altKey || v.ctrlKey || v.shiftKey)
        return;
      const d = v.composedPath().find((w) => w instanceof Node && w.nodeName.toUpperCase() === "A");
      if (!d || e && !d.hasAttribute("link"))
        return;
      const O = c(d), p = O ? d.href.baseVal : d.href;
      if ((O ? d.target.baseVal : d.target) || !p && !d.hasAttribute("state"))
        return;
      const _ = (d.getAttribute("rel") || "").split(/\s+/);
      if (d.hasAttribute("download") || _ && _.includes("external"))
        return;
      const b = O ? new URL(p, document.baseURI) : new URL(p);
      if (!(b.origin !== window.location.origin || n && b.pathname && !b.pathname.toLowerCase().startsWith(n.toLowerCase())))
        return [d, b];
    }
    function f(v) {
      const d = h(v);
      if (!d)
        return;
      const [O, p] = d, m = s.parsePath(p.pathname + p.search + p.hash), _ = O.getAttribute("state");
      v.preventDefault(), o(m, {
        resolve: !1,
        replace: O.hasAttribute("replace"),
        scroll: !O.hasAttribute("noscroll"),
        state: _ ? JSON.parse(_) : void 0
      });
    }
    function u(v) {
      const d = h(v);
      if (!d)
        return;
      const [O, p] = d;
      r && (p.pathname = r(p.pathname)), s.preloadRoute(p, O.getAttribute("preload") !== "false");
    }
    function g(v) {
      clearTimeout(a);
      const d = h(v);
      if (!d)
        return l = null;
      const [O, p] = d;
      l !== O && (r && (p.pathname = r(p.pathname)), a = setTimeout(() => {
        s.preloadRoute(p, O.getAttribute("preload") !== "false"), l = O;
      }, 20));
    }
    function S(v) {
      if (v.defaultPrevented)
        return;
      let d = v.submitter && v.submitter.hasAttribute("formaction") ? v.submitter.getAttribute("formaction") : v.target.getAttribute("action");
      if (!d)
        return;
      if (!d.startsWith("https://action/")) {
        const p = new URL(d, Um);
        if (d = s.parsePath(p.pathname + p.search), !d.startsWith(t))
          return;
      }
      if (v.target.method.toUpperCase() !== "POST")
        throw new Error("Only POST forms are supported for Actions");
      const O = U1.get(d);
      if (O) {
        v.preventDefault();
        const p = new FormData(v.target, v.submitter);
        O.call({ r: s, f: v.target }, v.target.enctype === "multipart/form-data" ? p : new URLSearchParams(p));
      }
    }
    He(["click", "submit"]), document.addEventListener("click", f), i && (document.addEventListener("mousemove", g, { passive: !0 }), document.addEventListener("focusin", u, { passive: !0 }), document.addEventListener("touchstart", u, { passive: !0 })), document.addEventListener("submit", S), ft(() => {
      document.removeEventListener("click", f), i && (document.removeEventListener("mousemove", g), document.removeEventListener("focusin", u), document.removeEventListener("touchstart", u)), document.removeEventListener("submit", S);
    });
  };
}
function N1(i) {
  const e = () => {
    const r = window.location.pathname.replace(/^\/+/, "/") + window.location.search, s = window.history.state && window.history.state._depth && Object.keys(window.history.state).length === 1 ? void 0 : window.history.state;
    return {
      value: r + window.location.hash,
      state: s
    };
  }, t = Vm();
  return W1({
    get: e,
    set({ value: r, replace: s, scroll: n, state: o }) {
      s ? window.history.replaceState(_1(o), "", r) : window.history.pushState(o, "", r), V1(decodeURIComponent(window.location.hash.slice(1)), n), hu();
    },
    init: (r) => z1(window, "popstate", b1(r, (s) => {
      if (s && s < 0)
        return !t.confirm(s);
      {
        const n = e();
        return !t.confirm(n.value, { state: n.state });
      }
    })),
    create: j1(i.preload, i.explicitLinks, i.actionBase, i.transformUrl),
    utils: {
      go: (r) => window.history.go(r),
      beforeLeave: t
    }
  })(i);
}
var Y1 = /* @__PURE__ */ Y("<a>");
function bn(i) {
  i = mn({
    inactiveClass: "inactive",
    activeClass: "active"
  }, i);
  const [, e] = lu(i, ["href", "state", "class", "activeClass", "inactiveClass", "end"]), t = T1(() => i.href), r = R1(t), s = Hm(), n = Qe(() => {
    const o = t();
    if (o === void 0) return [!1, !1];
    const a = Cr(o.split(/[?#]/, 1)[0]).toLowerCase(), l = decodeURI(Cr(s.pathname).toLowerCase());
    return [i.end ? a === l : l.startsWith(a + "/") || l === a, a === l];
  });
  return (() => {
    var o = Y1();
    return bl(o, mn(e, {
      get href() {
        return r() || i.href;
      },
      get state() {
        return JSON.stringify(i.state);
      },
      get classList() {
        return {
          ...i.class && {
            [i.class]: !0
          },
          [i.inactiveClass]: !n()[0],
          [i.activeClass]: n()[0],
          ...e.classList
        };
      },
      link: "",
      get "aria-current"() {
        return n()[1] ? "page" : void 0;
      }
    }), !1, !1), o;
  })();
}
const Ea = Symbol("store-raw"), ts = Symbol("store-node"), Ai = Symbol("store-has"), Jm = Symbol("store-self");
function e0(i) {
  let e = i[Ut];
  if (!e && (Object.defineProperty(i, Ut, {
    value: e = new Proxy(i, G1)
  }), !Array.isArray(i))) {
    const t = Object.keys(i), r = Object.getOwnPropertyDescriptors(i);
    for (let s = 0, n = t.length; s < n; s++) {
      const o = t[s];
      r[o].get && Object.defineProperty(i, o, {
        enumerable: r[o].enumerable,
        get: r[o].get.bind(e)
      });
    }
  }
  return e;
}
function vi(i) {
  let e;
  return i != null && typeof i == "object" && (i[Ut] || !(e = Object.getPrototypeOf(i)) || e === Object.prototype || Array.isArray(i));
}
function Er(i, e = /* @__PURE__ */ new Set()) {
  let t, r, s, n;
  if (t = i != null && i[Ea]) return t;
  if (!vi(i) || e.has(i)) return i;
  if (Array.isArray(i)) {
    Object.isFrozen(i) ? i = i.slice(0) : e.add(i);
    for (let o = 0, a = i.length; o < a; o++)
      s = i[o], (r = Er(s, e)) !== s && (i[o] = r);
  } else {
    Object.isFrozen(i) ? i = Object.assign({}, i) : e.add(i);
    const o = Object.keys(i), a = Object.getOwnPropertyDescriptors(i);
    for (let l = 0, c = o.length; l < c; l++)
      n = o[l], !a[n].get && (s = i[n], (r = Er(s, e)) !== s && (i[n] = r));
  }
  return i;
}
function Aa(i, e) {
  let t = i[e];
  return t || Object.defineProperty(i, e, {
    value: t = /* @__PURE__ */ Object.create(null)
  }), t;
}
function yn(i, e, t) {
  if (i[e]) return i[e];
  const [r, s] = ie(t, {
    equals: !1,
    internal: !0
  });
  return r.$ = s, i[e] = r;
}
function F1(i, e) {
  const t = Reflect.getOwnPropertyDescriptor(i, e);
  return !t || t.get || !t.configurable || e === Ut || e === ts || (delete t.value, delete t.writable, t.get = () => i[Ut][e]), t;
}
function t0(i) {
  ph() && yn(Aa(i, ts), Jm)();
}
function H1(i) {
  return t0(i), Reflect.ownKeys(i);
}
const G1 = {
  get(i, e, t) {
    if (e === Ea) return i;
    if (e === Ut) return t;
    if (e === Oh)
      return t0(i), t;
    const r = Aa(i, ts), s = r[e];
    let n = s ? s() : i[e];
    if (e === ts || e === Ai || e === "__proto__") return n;
    if (!s) {
      const o = Object.getOwnPropertyDescriptor(i, e);
      ph() && (typeof n != "function" || i.hasOwnProperty(e)) && !(o && o.get) && (n = yn(r, e, n)());
    }
    return vi(n) ? e0(n) : n;
  },
  has(i, e) {
    return e === Ea || e === Ut || e === Oh || e === ts || e === Ai || e === "__proto__" ? !0 : (ph() && yn(Aa(i, Ai), e)(), e in i);
  },
  set() {
    return !0;
  },
  deleteProperty() {
    return !0;
  },
  ownKeys: H1,
  getOwnPropertyDescriptor: F1
};
function mt(i, e, t, r = !1) {
  if (!r && i[e] === t) return;
  const s = i[e], n = i.length;
  t === void 0 ? (delete i[e], i[Ai] && i[Ai][e] && s !== void 0 && i[Ai][e].$()) : (i[e] = t, i[Ai] && i[Ai][e] && s === void 0 && i[Ai][e].$());
  let o = Aa(i, ts), a;
  if ((a = yn(o, e, s)) && a.$(() => t), Array.isArray(i) && i.length !== n) {
    for (let l = i.length; l < n; l++) (a = o[l]) && a.$();
    (a = yn(o, "length", n)) && a.$(i.length);
  }
  (a = o[Jm]) && a.$();
}
function i0(i, e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r += 1) {
    const s = t[r];
    mt(i, s, e[s]);
  }
}
function K1(i, e) {
  if (typeof e == "function" && (e = e(i)), e = Er(e), Array.isArray(e)) {
    if (i === e) return;
    let t = 0, r = e.length;
    for (; t < r; t++) {
      const s = e[t];
      i[t] !== s && mt(i, t, s);
    }
    mt(i, "length", r);
  } else i0(i, e);
}
function Hs(i, e, t = []) {
  let r, s = i;
  if (e.length > 1) {
    r = e.shift();
    const o = typeof r, a = Array.isArray(i);
    if (Array.isArray(r)) {
      for (let l = 0; l < r.length; l++)
        Hs(i, [r[l]].concat(e), t);
      return;
    } else if (a && o === "function") {
      for (let l = 0; l < i.length; l++)
        r(i[l], l) && Hs(i, [l].concat(e), t);
      return;
    } else if (a && o === "object") {
      const {
        from: l = 0,
        to: c = i.length - 1,
        by: h = 1
      } = r;
      for (let f = l; f <= c; f += h)
        Hs(i, [f].concat(e), t);
      return;
    } else if (e.length > 1) {
      Hs(i[r], e, [r].concat(t));
      return;
    }
    s = i[r], t = [r].concat(t);
  }
  let n = e[0];
  typeof n == "function" && (n = n(s, t), n === s) || r === void 0 && n == null || (n = Er(n), r === void 0 || vi(s) && vi(n) && !Array.isArray(n) ? i0(s, n) : mt(i, r, n));
}
function uu(...[i, e]) {
  const t = Er(i || {}), r = Array.isArray(t), s = e0(t);
  function n(...o) {
    Bm(() => {
      r && o.length === 1 ? K1(t, o[0]) : Hs(t, o);
    });
  }
  return [s, n];
}
const _h = Symbol("store-root");
function Ur(i, e, t, r, s) {
  const n = e[t];
  if (i === n) return;
  const o = Array.isArray(i);
  if (t !== _h && (!vi(i) || !vi(n) || o !== Array.isArray(n) || s && i[s] !== n[s])) {
    mt(e, t, i);
    return;
  }
  if (o) {
    if (i.length && n.length && (!r || s && i[0] && i[0][s] != null)) {
      let c, h, f, u, g, S, v, d;
      for (f = 0, u = Math.min(n.length, i.length); f < u && (n[f] === i[f] || s && n[f] && i[f] && n[f][s] === i[f][s]); f++)
        Ur(i[f], n, f, r, s);
      const O = new Array(i.length), p = /* @__PURE__ */ new Map();
      for (u = n.length - 1, g = i.length - 1; u >= f && g >= f && (n[u] === i[g] || s && n[u] && i[g] && n[u][s] === i[g][s]); u--, g--)
        O[g] = n[u];
      if (f > g || f > u) {
        for (h = f; h <= g; h++) mt(n, h, i[h]);
        for (; h < i.length; h++)
          mt(n, h, O[h]), Ur(i[h], n, h, r, s);
        n.length > i.length && mt(n, "length", i.length);
        return;
      }
      for (v = new Array(g + 1), h = g; h >= f; h--)
        S = i[h], d = s && S ? S[s] : S, c = p.get(d), v[h] = c === void 0 ? -1 : c, p.set(d, h);
      for (c = f; c <= u; c++)
        S = n[c], d = s && S ? S[s] : S, h = p.get(d), h !== void 0 && h !== -1 && (O[h] = n[c], h = v[h], p.set(d, h));
      for (h = f; h < i.length; h++)
        h in O ? (mt(n, h, O[h]), Ur(i[h], n, h, r, s)) : mt(n, h, i[h]);
    } else
      for (let c = 0, h = i.length; c < h; c++)
        Ur(i[c], n, c, r, s);
    n.length > i.length && mt(n, "length", i.length);
    return;
  }
  const a = Object.keys(i);
  for (let c = 0, h = a.length; c < h; c++)
    Ur(i[a[c]], n, a[c], r, s);
  const l = Object.keys(n);
  for (let c = 0, h = l.length; c < h; c++)
    i[l[c]] === void 0 && mt(n, l[c], void 0);
}
function J1(i, e = {}) {
  const {
    merge: t,
    key: r = "id"
  } = e, s = Er(i);
  return (n) => {
    if (!vi(n) || !vi(s)) return s;
    const o = Ur(s, {
      [_h]: n
    }, _h, t, r);
    return o === void 0 ? n : o;
  };
}
const La = /* @__PURE__ */ new WeakMap(), r0 = {
  get(i, e) {
    if (e === Ea) return i;
    const t = i[e];
    let r;
    return vi(t) ? La.get(t) || (La.set(t, r = new Proxy(t, r0)), r) : t;
  },
  set(i, e, t) {
    return mt(i, e, Er(t)), !0;
  },
  deleteProperty(i, e) {
    return mt(i, e, void 0, !0), !0;
  }
};
function ew(i) {
  return (e) => {
    if (vi(e)) {
      let t;
      (t = La.get(e)) || La.set(e, t = new Proxy(e, r0)), i(t);
    }
    return e;
  };
}
function s0(i, e) {
  return function() {
    return i.apply(e, arguments);
  };
}
const { toString: tw } = Object.prototype, { getPrototypeOf: du } = Object, { iterator: wl, toStringTag: n0 } = Symbol, xl = /* @__PURE__ */ ((i) => (e) => {
  const t = tw.call(e);
  return i[t] || (i[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Kt = (i) => (i = i.toLowerCase(), (e) => xl(e) === i), kl = (i) => (e) => typeof e === i, { isArray: ws } = Array, wn = kl("undefined");
function iw(i) {
  return i !== null && !wn(i) && i.constructor !== null && !wn(i.constructor) && wt(i.constructor.isBuffer) && i.constructor.isBuffer(i);
}
const o0 = Kt("ArrayBuffer");
function rw(i) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(i) : e = i && i.buffer && o0(i.buffer), e;
}
const sw = kl("string"), wt = kl("function"), a0 = kl("number"), Cl = (i) => i !== null && typeof i == "object", nw = (i) => i === !0 || i === !1, ra = (i) => {
  if (xl(i) !== "object")
    return !1;
  const e = du(i);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(n0 in i) && !(wl in i);
}, ow = Kt("Date"), aw = Kt("File"), lw = Kt("Blob"), cw = Kt("FileList"), hw = (i) => Cl(i) && wt(i.pipe), fw = (i) => {
  let e;
  return i && (typeof FormData == "function" && i instanceof FormData || wt(i.append) && ((e = xl(i)) === "formdata" || // detect form-data instance
  e === "object" && wt(i.toString) && i.toString() === "[object FormData]"));
}, uw = Kt("URLSearchParams"), [dw, Ow, pw, gw] = ["ReadableStream", "Request", "Response", "Headers"].map(Kt), mw = (i) => i.trim ? i.trim() : i.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ro(i, e, { allOwnKeys: t = !1 } = {}) {
  if (i === null || typeof i > "u")
    return;
  let r, s;
  if (typeof i != "object" && (i = [i]), ws(i))
    for (r = 0, s = i.length; r < s; r++)
      e.call(null, i[r], r, i);
  else {
    const n = t ? Object.getOwnPropertyNames(i) : Object.keys(i), o = n.length;
    let a;
    for (r = 0; r < o; r++)
      a = n[r], e.call(null, i[a], a, i);
  }
}
function l0(i, e) {
  e = e.toLowerCase();
  const t = Object.keys(i);
  let r = t.length, s;
  for (; r-- > 0; )
    if (s = t[r], e === s.toLowerCase())
      return s;
  return null;
}
const br = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, c0 = (i) => !wn(i) && i !== br;
function bh() {
  const { caseless: i } = c0(this) && this || {}, e = {}, t = (r, s) => {
    const n = i && l0(e, s) || s;
    ra(e[n]) && ra(r) ? e[n] = bh(e[n], r) : ra(r) ? e[n] = bh({}, r) : ws(r) ? e[n] = r.slice() : e[n] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && ro(arguments[r], t);
  return e;
}
const vw = (i, e, t, { allOwnKeys: r } = {}) => (ro(e, (s, n) => {
  t && wt(s) ? i[n] = s0(s, t) : i[n] = s;
}, { allOwnKeys: r }), i), Sw = (i) => (i.charCodeAt(0) === 65279 && (i = i.slice(1)), i), _w = (i, e, t, r) => {
  i.prototype = Object.create(e.prototype, r), i.prototype.constructor = i, Object.defineProperty(i, "super", {
    value: e.prototype
  }), t && Object.assign(i.prototype, t);
}, bw = (i, e, t, r) => {
  let s, n, o;
  const a = {};
  if (e = e || {}, i == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(i), n = s.length; n-- > 0; )
      o = s[n], (!r || r(o, i, e)) && !a[o] && (e[o] = i[o], a[o] = !0);
    i = t !== !1 && du(i);
  } while (i && (!t || t(i, e)) && i !== Object.prototype);
  return e;
}, yw = (i, e, t) => {
  i = String(i), (t === void 0 || t > i.length) && (t = i.length), t -= e.length;
  const r = i.indexOf(e, t);
  return r !== -1 && r === t;
}, ww = (i) => {
  if (!i) return null;
  if (ws(i)) return i;
  let e = i.length;
  if (!a0(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = i[e];
  return t;
}, xw = /* @__PURE__ */ ((i) => (e) => i && e instanceof i)(typeof Uint8Array < "u" && du(Uint8Array)), kw = (i, e) => {
  const r = (i && i[wl]).call(i);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const n = s.value;
    e.call(i, n[0], n[1]);
  }
}, Cw = (i, e) => {
  let t;
  const r = [];
  for (; (t = i.exec(e)) !== null; )
    r.push(t);
  return r;
}, Qw = Kt("HTMLFormElement"), Pw = (i) => i.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, r, s) {
    return r.toUpperCase() + s;
  }
), Xd = (({ hasOwnProperty: i }) => (e, t) => i.call(e, t))(Object.prototype), $w = Kt("RegExp"), h0 = (i, e) => {
  const t = Object.getOwnPropertyDescriptors(i), r = {};
  ro(t, (s, n) => {
    let o;
    (o = e(s, n, i)) !== !1 && (r[n] = o || s);
  }), Object.defineProperties(i, r);
}, Tw = (i) => {
  h0(i, (e, t) => {
    if (wt(i) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const r = i[t];
    if (wt(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, Rw = (i, e) => {
  const t = {}, r = (s) => {
    s.forEach((n) => {
      t[n] = !0;
    });
  };
  return ws(i) ? r(i) : r(String(i).split(e)), t;
}, Ew = () => {
}, Aw = (i, e) => i != null && Number.isFinite(i = +i) ? i : e;
function Lw(i) {
  return !!(i && wt(i.append) && i[n0] === "FormData" && i[wl]);
}
const Mw = (i) => {
  const e = new Array(10), t = (r, s) => {
    if (Cl(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const n = ws(r) ? [] : {};
        return ro(r, (o, a) => {
          const l = t(o, s + 1);
          !wn(l) && (n[a] = l);
        }), e[s] = void 0, n;
      }
    }
    return r;
  };
  return t(i, 0);
}, Dw = Kt("AsyncFunction"), qw = (i) => i && (Cl(i) || wt(i)) && wt(i.then) && wt(i.catch), f0 = ((i, e) => i ? setImmediate : e ? ((t, r) => (br.addEventListener("message", ({ source: s, data: n }) => {
  s === br && n === t && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), br.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(
  typeof setImmediate == "function",
  wt(br.postMessage)
), Bw = typeof queueMicrotask < "u" ? queueMicrotask.bind(br) : typeof process < "u" && process.nextTick || f0, Xw = (i) => i != null && wt(i[wl]), Z = {
  isArray: ws,
  isArrayBuffer: o0,
  isBuffer: iw,
  isFormData: fw,
  isArrayBufferView: rw,
  isString: sw,
  isNumber: a0,
  isBoolean: nw,
  isObject: Cl,
  isPlainObject: ra,
  isReadableStream: dw,
  isRequest: Ow,
  isResponse: pw,
  isHeaders: gw,
  isUndefined: wn,
  isDate: ow,
  isFile: aw,
  isBlob: lw,
  isRegExp: $w,
  isFunction: wt,
  isStream: hw,
  isURLSearchParams: uw,
  isTypedArray: xw,
  isFileList: cw,
  forEach: ro,
  merge: bh,
  extend: vw,
  trim: mw,
  stripBOM: Sw,
  inherits: _w,
  toFlatObject: bw,
  kindOf: xl,
  kindOfTest: Kt,
  endsWith: yw,
  toArray: ww,
  forEachEntry: kw,
  matchAll: Cw,
  isHTMLForm: Qw,
  hasOwnProperty: Xd,
  hasOwnProp: Xd,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: h0,
  freezeMethods: Tw,
  toObjectSet: Rw,
  toCamelCase: Pw,
  noop: Ew,
  toFiniteNumber: Aw,
  findKey: l0,
  global: br,
  isContextDefined: c0,
  isSpecCompliantForm: Lw,
  toJSONObject: Mw,
  isAsyncFn: Dw,
  isThenable: qw,
  setImmediate: f0,
  asap: Bw,
  isIterable: Xw
};
function fe(i, e, t, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = i, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null);
}
Z.inherits(fe, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Z.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const u0 = fe.prototype, d0 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((i) => {
  d0[i] = { value: i };
});
Object.defineProperties(fe, d0);
Object.defineProperty(u0, "isAxiosError", { value: !0 });
fe.from = (i, e, t, r, s, n) => {
  const o = Object.create(u0);
  return Z.toFlatObject(i, o, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), fe.call(o, i.message, e, t, r, s), o.cause = i, o.name = i.name, n && Object.assign(o, n), o;
};
const Iw = null;
function yh(i) {
  return Z.isPlainObject(i) || Z.isArray(i);
}
function O0(i) {
  return Z.endsWith(i, "[]") ? i.slice(0, -2) : i;
}
function Id(i, e, t) {
  return i ? i.concat(e).map(function(s, n) {
    return s = O0(s), !t && n ? "[" + s + "]" : s;
  }).join(t ? "." : "") : e;
}
function Zw(i) {
  return Z.isArray(i) && !i.some(yh);
}
const Ww = Z.toFlatObject(Z, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Ql(i, e, t) {
  if (!Z.isObject(i))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = Z.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, d) {
    return !Z.isUndefined(d[v]);
  });
  const r = t.metaTokens, s = t.visitor || h, n = t.dots, o = t.indexes, l = (t.Blob || typeof Blob < "u" && Blob) && Z.isSpecCompliantForm(e);
  if (!Z.isFunction(s))
    throw new TypeError("visitor must be a function");
  function c(S) {
    if (S === null) return "";
    if (Z.isDate(S))
      return S.toISOString();
    if (!l && Z.isBlob(S))
      throw new fe("Blob is not supported. Use a Buffer instead.");
    return Z.isArrayBuffer(S) || Z.isTypedArray(S) ? l && typeof Blob == "function" ? new Blob([S]) : Buffer.from(S) : S;
  }
  function h(S, v, d) {
    let O = S;
    if (S && !d && typeof S == "object") {
      if (Z.endsWith(v, "{}"))
        v = r ? v : v.slice(0, -2), S = JSON.stringify(S);
      else if (Z.isArray(S) && Zw(S) || (Z.isFileList(S) || Z.endsWith(v, "[]")) && (O = Z.toArray(S)))
        return v = O0(v), O.forEach(function(m, _) {
          !(Z.isUndefined(m) || m === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Id([v], _, n) : o === null ? v : v + "[]",
            c(m)
          );
        }), !1;
    }
    return yh(S) ? !0 : (e.append(Id(d, v, n), c(S)), !1);
  }
  const f = [], u = Object.assign(Ww, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: yh
  });
  function g(S, v) {
    if (!Z.isUndefined(S)) {
      if (f.indexOf(S) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      f.push(S), Z.forEach(S, function(O, p) {
        (!(Z.isUndefined(O) || O === null) && s.call(
          e,
          O,
          Z.isString(p) ? p.trim() : p,
          v,
          u
        )) === !0 && g(O, v ? v.concat(p) : [p]);
      }), f.pop();
    }
  }
  if (!Z.isObject(i))
    throw new TypeError("data must be an object");
  return g(i), e;
}
function Zd(i) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(i).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function Ou(i, e) {
  this._pairs = [], i && Ql(i, this, e);
}
const p0 = Ou.prototype;
p0.append = function(e, t) {
  this._pairs.push([e, t]);
};
p0.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, Zd);
  } : Zd;
  return this._pairs.map(function(s) {
    return t(s[0]) + "=" + t(s[1]);
  }, "").join("&");
};
function zw(i) {
  return encodeURIComponent(i).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function g0(i, e, t) {
  if (!e)
    return i;
  const r = t && t.encode || zw;
  Z.isFunction(t) && (t = {
    serialize: t
  });
  const s = t && t.serialize;
  let n;
  if (s ? n = s(e, t) : n = Z.isURLSearchParams(e) ? e.toString() : new Ou(e, t).toString(r), n) {
    const o = i.indexOf("#");
    o !== -1 && (i = i.slice(0, o)), i += (i.indexOf("?") === -1 ? "?" : "&") + n;
  }
  return i;
}
class Wd {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Z.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const m0 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Vw = typeof URLSearchParams < "u" ? URLSearchParams : Ou, Uw = typeof FormData < "u" ? FormData : null, jw = typeof Blob < "u" ? Blob : null, Nw = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Vw,
    FormData: Uw,
    Blob: jw
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, pu = typeof window < "u" && typeof document < "u", wh = typeof navigator == "object" && navigator || void 0, Yw = pu && (!wh || ["ReactNative", "NativeScript", "NS"].indexOf(wh.product) < 0), Fw = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Hw = pu && window.location.href || "http://localhost", Gw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: pu,
  hasStandardBrowserEnv: Yw,
  hasStandardBrowserWebWorkerEnv: Fw,
  navigator: wh,
  origin: Hw
}, Symbol.toStringTag, { value: "Module" })), ot = {
  ...Gw,
  ...Nw
};
function Kw(i, e) {
  return Ql(i, new ot.classes.URLSearchParams(), Object.assign({
    visitor: function(t, r, s, n) {
      return ot.isNode && Z.isBuffer(t) ? (this.append(r, t.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function Jw(i) {
  return Z.matchAll(/\w+|\[(\w*)]/g, i).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function ex(i) {
  const e = {}, t = Object.keys(i);
  let r;
  const s = t.length;
  let n;
  for (r = 0; r < s; r++)
    n = t[r], e[n] = i[n];
  return e;
}
function v0(i) {
  function e(t, r, s, n) {
    let o = t[n++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), l = n >= t.length;
    return o = !o && Z.isArray(s) ? s.length : o, l ? (Z.hasOwnProp(s, o) ? s[o] = [s[o], r] : s[o] = r, !a) : ((!s[o] || !Z.isObject(s[o])) && (s[o] = []), e(t, r, s[o], n) && Z.isArray(s[o]) && (s[o] = ex(s[o])), !a);
  }
  if (Z.isFormData(i) && Z.isFunction(i.entries)) {
    const t = {};
    return Z.forEachEntry(i, (r, s) => {
      e(Jw(r), s, t, 0);
    }), t;
  }
  return null;
}
function tx(i, e, t) {
  if (Z.isString(i))
    try {
      return (e || JSON.parse)(i), Z.trim(i);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (t || JSON.stringify)(i);
}
const so = {
  transitional: m0,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", s = r.indexOf("application/json") > -1, n = Z.isObject(e);
    if (n && Z.isHTMLForm(e) && (e = new FormData(e)), Z.isFormData(e))
      return s ? JSON.stringify(v0(e)) : e;
    if (Z.isArrayBuffer(e) || Z.isBuffer(e) || Z.isStream(e) || Z.isFile(e) || Z.isBlob(e) || Z.isReadableStream(e))
      return e;
    if (Z.isArrayBufferView(e))
      return e.buffer;
    if (Z.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (n) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Kw(e, this.formSerializer).toString();
      if ((a = Z.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Ql(
          a ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return n || s ? (t.setContentType("application/json", !1), tx(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || so.transitional, r = t && t.forcedJSONParsing, s = this.responseType === "json";
    if (Z.isResponse(e) || Z.isReadableStream(e))
      return e;
    if (e && Z.isString(e) && (r && !this.responseType || s)) {
      const o = !(t && t.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? fe.from(a, fe.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ot.classes.FormData,
    Blob: ot.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Z.forEach(["delete", "get", "head", "post", "put", "patch"], (i) => {
  so.headers[i] = {};
});
const ix = Z.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), rx = (i) => {
  const e = {};
  let t, r, s;
  return i && i.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), t = o.substring(0, s).trim().toLowerCase(), r = o.substring(s + 1).trim(), !(!t || e[t] && ix[t]) && (t === "set-cookie" ? e[t] ? e[t].push(r) : e[t] = [r] : e[t] = e[t] ? e[t] + ", " + r : r);
  }), e;
}, zd = Symbol("internals");
function Ls(i) {
  return i && String(i).trim().toLowerCase();
}
function sa(i) {
  return i === !1 || i == null ? i : Z.isArray(i) ? i.map(sa) : String(i);
}
function sx(i) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = t.exec(i); )
    e[r[1]] = r[2];
  return e;
}
const nx = (i) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(i.trim());
function rc(i, e, t, r, s) {
  if (Z.isFunction(r))
    return r.call(this, e, t);
  if (s && (e = t), !!Z.isString(e)) {
    if (Z.isString(r))
      return e.indexOf(r) !== -1;
    if (Z.isRegExp(r))
      return r.test(e);
  }
}
function ox(i) {
  return i.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r);
}
function ax(i, e) {
  const t = Z.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(i, r + t, {
      value: function(s, n, o) {
        return this[r].call(this, e, s, n, o);
      },
      configurable: !0
    });
  });
}
let xt = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, r) {
    const s = this;
    function n(a, l, c) {
      const h = Ls(l);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const f = Z.findKey(s, h);
      (!f || s[f] === void 0 || c === !0 || c === void 0 && s[f] !== !1) && (s[f || l] = sa(a));
    }
    const o = (a, l) => Z.forEach(a, (c, h) => n(c, h, l));
    if (Z.isPlainObject(e) || e instanceof this.constructor)
      o(e, t);
    else if (Z.isString(e) && (e = e.trim()) && !nx(e))
      o(rx(e), t);
    else if (Z.isObject(e) && Z.isIterable(e)) {
      let a = {}, l, c;
      for (const h of e) {
        if (!Z.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        a[c = h[0]] = (l = a[c]) ? Z.isArray(l) ? [...l, h[1]] : [l, h[1]] : h[1];
      }
      o(a, t);
    } else
      e != null && n(t, e, r);
    return this;
  }
  get(e, t) {
    if (e = Ls(e), e) {
      const r = Z.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!t)
          return s;
        if (t === !0)
          return sx(s);
        if (Z.isFunction(t))
          return t.call(this, s, r);
        if (Z.isRegExp(t))
          return t.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = Ls(e), e) {
      const r = Z.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!t || rc(this, this[r], r, t)));
    }
    return !1;
  }
  delete(e, t) {
    const r = this;
    let s = !1;
    function n(o) {
      if (o = Ls(o), o) {
        const a = Z.findKey(r, o);
        a && (!t || rc(r, r[a], a, t)) && (delete r[a], s = !0);
      }
    }
    return Z.isArray(e) ? e.forEach(n) : n(e), s;
  }
  clear(e) {
    const t = Object.keys(this);
    let r = t.length, s = !1;
    for (; r--; ) {
      const n = t[r];
      (!e || rc(this, this[n], n, e, !0)) && (delete this[n], s = !0);
    }
    return s;
  }
  normalize(e) {
    const t = this, r = {};
    return Z.forEach(this, (s, n) => {
      const o = Z.findKey(r, n);
      if (o) {
        t[o] = sa(s), delete t[n];
        return;
      }
      const a = e ? ox(n) : String(n).trim();
      a !== n && delete t[n], t[a] = sa(s), r[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return Z.forEach(this, (r, s) => {
      r != null && r !== !1 && (t[s] = e && Z.isArray(r) ? r.join(", ") : r);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const r = new this(e);
    return t.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[zd] = this[zd] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function n(o) {
      const a = Ls(o);
      r[a] || (ax(s, o), r[a] = !0);
    }
    return Z.isArray(e) ? e.forEach(n) : n(e), this;
  }
};
xt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Z.reduceDescriptors(xt.prototype, ({ value: i }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => i,
    set(r) {
      this[t] = r;
    }
  };
});
Z.freezeMethods(xt);
function sc(i, e) {
  const t = this || so, r = e || t, s = xt.from(r.headers);
  let n = r.data;
  return Z.forEach(i, function(a) {
    n = a.call(t, n, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), n;
}
function S0(i) {
  return !!(i && i.__CANCEL__);
}
function xs(i, e, t) {
  fe.call(this, i ?? "canceled", fe.ERR_CANCELED, e, t), this.name = "CanceledError";
}
Z.inherits(xs, fe, {
  __CANCEL__: !0
});
function _0(i, e, t) {
  const r = t.config.validateStatus;
  !t.status || !r || r(t.status) ? i(t) : e(new fe(
    "Request failed with status code " + t.status,
    [fe.ERR_BAD_REQUEST, fe.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
    t.config,
    t.request,
    t
  ));
}
function lx(i) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(i);
  return e && e[1] || "";
}
function cx(i, e) {
  i = i || 10;
  const t = new Array(i), r = new Array(i);
  let s = 0, n = 0, o;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const c = Date.now(), h = r[n];
    o || (o = c), t[s] = l, r[s] = c;
    let f = n, u = 0;
    for (; f !== s; )
      u += t[f++], f = f % i;
    if (s = (s + 1) % i, s === n && (n = (n + 1) % i), c - o < e)
      return;
    const g = h && c - h;
    return g ? Math.round(u * 1e3 / g) : void 0;
  };
}
function hx(i, e) {
  let t = 0, r = 1e3 / e, s, n;
  const o = (c, h = Date.now()) => {
    t = h, s = null, n && (clearTimeout(n), n = null), i.apply(null, c);
  };
  return [(...c) => {
    const h = Date.now(), f = h - t;
    f >= r ? o(c, h) : (s = c, n || (n = setTimeout(() => {
      n = null, o(s);
    }, r - f)));
  }, () => s && o(s)];
}
const Ma = (i, e, t = 3) => {
  let r = 0;
  const s = cx(50, 250);
  return hx((n) => {
    const o = n.loaded, a = n.lengthComputable ? n.total : void 0, l = o - r, c = s(l), h = o <= a;
    r = o;
    const f = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && a && h ? (a - o) / c : void 0,
      event: n,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    i(f);
  }, t);
}, Vd = (i, e) => {
  const t = i != null;
  return [(r) => e[0]({
    lengthComputable: t,
    total: i,
    loaded: r
  }), e[1]];
}, Ud = (i) => (...e) => Z.asap(() => i(...e)), fx = ot.hasStandardBrowserEnv ? /* @__PURE__ */ ((i, e) => (t) => (t = new URL(t, ot.origin), i.protocol === t.protocol && i.host === t.host && (e || i.port === t.port)))(
  new URL(ot.origin),
  ot.navigator && /(msie|trident)/i.test(ot.navigator.userAgent)
) : () => !0, ux = ot.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(i, e, t, r, s, n) {
      const o = [i + "=" + encodeURIComponent(e)];
      Z.isNumber(t) && o.push("expires=" + new Date(t).toGMTString()), Z.isString(r) && o.push("path=" + r), Z.isString(s) && o.push("domain=" + s), n === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(i) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + i + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(i) {
      this.write(i, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function dx(i) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(i);
}
function Ox(i, e) {
  return e ? i.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : i;
}
function b0(i, e, t) {
  let r = !dx(e);
  return i && (r || t == !1) ? Ox(i, e) : e;
}
const jd = (i) => i instanceof xt ? { ...i } : i;
function Ar(i, e) {
  e = e || {};
  const t = {};
  function r(c, h, f, u) {
    return Z.isPlainObject(c) && Z.isPlainObject(h) ? Z.merge.call({ caseless: u }, c, h) : Z.isPlainObject(h) ? Z.merge({}, h) : Z.isArray(h) ? h.slice() : h;
  }
  function s(c, h, f, u) {
    if (Z.isUndefined(h)) {
      if (!Z.isUndefined(c))
        return r(void 0, c, f, u);
    } else return r(c, h, f, u);
  }
  function n(c, h) {
    if (!Z.isUndefined(h))
      return r(void 0, h);
  }
  function o(c, h) {
    if (Z.isUndefined(h)) {
      if (!Z.isUndefined(c))
        return r(void 0, c);
    } else return r(void 0, h);
  }
  function a(c, h, f) {
    if (f in e)
      return r(c, h);
    if (f in i)
      return r(void 0, c);
  }
  const l = {
    url: n,
    method: n,
    data: n,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, h, f) => s(jd(c), jd(h), f, !0)
  };
  return Z.forEach(Object.keys(Object.assign({}, i, e)), function(h) {
    const f = l[h] || s, u = f(i[h], e[h], h);
    Z.isUndefined(u) && f !== a || (t[h] = u);
  }), t;
}
const y0 = (i) => {
  const e = Ar({}, i);
  let { data: t, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: n, headers: o, auth: a } = e;
  e.headers = o = xt.from(o), e.url = g0(b0(e.baseURL, e.url, e.allowAbsoluteUrls), i.params, i.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let l;
  if (Z.isFormData(t)) {
    if (ot.hasStandardBrowserEnv || ot.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((l = o.getContentType()) !== !1) {
      const [c, ...h] = l ? l.split(";").map((f) => f.trim()).filter(Boolean) : [];
      o.setContentType([c || "multipart/form-data", ...h].join("; "));
    }
  }
  if (ot.hasStandardBrowserEnv && (r && Z.isFunction(r) && (r = r(e)), r || r !== !1 && fx(e.url))) {
    const c = s && n && ux.read(n);
    c && o.set(s, c);
  }
  return e;
}, px = typeof XMLHttpRequest < "u", gx = px && function(i) {
  return new Promise(function(t, r) {
    const s = y0(i);
    let n = s.data;
    const o = xt.from(s.headers).normalize();
    let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = s, h, f, u, g, S;
    function v() {
      g && g(), S && S(), s.cancelToken && s.cancelToken.unsubscribe(h), s.signal && s.signal.removeEventListener("abort", h);
    }
    let d = new XMLHttpRequest();
    d.open(s.method.toUpperCase(), s.url, !0), d.timeout = s.timeout;
    function O() {
      if (!d)
        return;
      const m = xt.from(
        "getAllResponseHeaders" in d && d.getAllResponseHeaders()
      ), b = {
        data: !a || a === "text" || a === "json" ? d.responseText : d.response,
        status: d.status,
        statusText: d.statusText,
        headers: m,
        config: i,
        request: d
      };
      _0(function(x) {
        t(x), v();
      }, function(x) {
        r(x), v();
      }, b), d = null;
    }
    "onloadend" in d ? d.onloadend = O : d.onreadystatechange = function() {
      !d || d.readyState !== 4 || d.status === 0 && !(d.responseURL && d.responseURL.indexOf("file:") === 0) || setTimeout(O);
    }, d.onabort = function() {
      d && (r(new fe("Request aborted", fe.ECONNABORTED, i, d)), d = null);
    }, d.onerror = function() {
      r(new fe("Network Error", fe.ERR_NETWORK, i, d)), d = null;
    }, d.ontimeout = function() {
      let _ = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const b = s.transitional || m0;
      s.timeoutErrorMessage && (_ = s.timeoutErrorMessage), r(new fe(
        _,
        b.clarifyTimeoutError ? fe.ETIMEDOUT : fe.ECONNABORTED,
        i,
        d
      )), d = null;
    }, n === void 0 && o.setContentType(null), "setRequestHeader" in d && Z.forEach(o.toJSON(), function(_, b) {
      d.setRequestHeader(b, _);
    }), Z.isUndefined(s.withCredentials) || (d.withCredentials = !!s.withCredentials), a && a !== "json" && (d.responseType = s.responseType), c && ([u, S] = Ma(c, !0), d.addEventListener("progress", u)), l && d.upload && ([f, g] = Ma(l), d.upload.addEventListener("progress", f), d.upload.addEventListener("loadend", g)), (s.cancelToken || s.signal) && (h = (m) => {
      d && (r(!m || m.type ? new xs(null, i, d) : m), d.abort(), d = null);
    }, s.cancelToken && s.cancelToken.subscribe(h), s.signal && (s.signal.aborted ? h() : s.signal.addEventListener("abort", h)));
    const p = lx(s.url);
    if (p && ot.protocols.indexOf(p) === -1) {
      r(new fe("Unsupported protocol " + p + ":", fe.ERR_BAD_REQUEST, i));
      return;
    }
    d.send(n || null);
  });
}, mx = (i, e) => {
  const { length: t } = i = i ? i.filter(Boolean) : [];
  if (e || t) {
    let r = new AbortController(), s;
    const n = function(c) {
      if (!s) {
        s = !0, a();
        const h = c instanceof Error ? c : this.reason;
        r.abort(h instanceof fe ? h : new xs(h instanceof Error ? h.message : h));
      }
    };
    let o = e && setTimeout(() => {
      o = null, n(new fe(`timeout ${e} of ms exceeded`, fe.ETIMEDOUT));
    }, e);
    const a = () => {
      i && (o && clearTimeout(o), o = null, i.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(n) : c.removeEventListener("abort", n);
      }), i = null);
    };
    i.forEach((c) => c.addEventListener("abort", n));
    const { signal: l } = r;
    return l.unsubscribe = () => Z.asap(a), l;
  }
}, vx = function* (i, e) {
  let t = i.byteLength;
  if (t < e) {
    yield i;
    return;
  }
  let r = 0, s;
  for (; r < t; )
    s = r + e, yield i.slice(r, s), r = s;
}, Sx = async function* (i, e) {
  for await (const t of _x(i))
    yield* vx(t, e);
}, _x = async function* (i) {
  if (i[Symbol.asyncIterator]) {
    yield* i;
    return;
  }
  const e = i.getReader();
  try {
    for (; ; ) {
      const { done: t, value: r } = await e.read();
      if (t)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, Nd = (i, e, t, r) => {
  const s = Sx(i, e);
  let n = 0, o, a = (l) => {
    o || (o = !0, r && r(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: h } = await s.next();
        if (c) {
          a(), l.close();
          return;
        }
        let f = h.byteLength;
        if (t) {
          let u = n += f;
          t(u);
        }
        l.enqueue(new Uint8Array(h));
      } catch (c) {
        throw a(c), c;
      }
    },
    cancel(l) {
      return a(l), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, Pl = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", w0 = Pl && typeof ReadableStream == "function", bx = Pl && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((i) => (e) => i.encode(e))(new TextEncoder()) : async (i) => new Uint8Array(await new Response(i).arrayBuffer())), x0 = (i, ...e) => {
  try {
    return !!i(...e);
  } catch {
    return !1;
  }
}, yx = w0 && x0(() => {
  let i = !1;
  const e = new Request(ot.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return i = !0, "half";
    }
  }).headers.has("Content-Type");
  return i && !e;
}), Yd = 64 * 1024, xh = w0 && x0(() => Z.isReadableStream(new Response("").body)), Da = {
  stream: xh && ((i) => i.body)
};
Pl && ((i) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Da[e] && (Da[e] = Z.isFunction(i[e]) ? (t) => t[e]() : (t, r) => {
      throw new fe(`Response type '${e}' is not supported`, fe.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const wx = async (i) => {
  if (i == null)
    return 0;
  if (Z.isBlob(i))
    return i.size;
  if (Z.isSpecCompliantForm(i))
    return (await new Request(ot.origin, {
      method: "POST",
      body: i
    }).arrayBuffer()).byteLength;
  if (Z.isArrayBufferView(i) || Z.isArrayBuffer(i))
    return i.byteLength;
  if (Z.isURLSearchParams(i) && (i = i + ""), Z.isString(i))
    return (await bx(i)).byteLength;
}, xx = async (i, e) => {
  const t = Z.toFiniteNumber(i.getContentLength());
  return t ?? wx(e);
}, kx = Pl && (async (i) => {
  let {
    url: e,
    method: t,
    data: r,
    signal: s,
    cancelToken: n,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: l,
    responseType: c,
    headers: h,
    withCredentials: f = "same-origin",
    fetchOptions: u
  } = y0(i);
  c = c ? (c + "").toLowerCase() : "text";
  let g = mx([s, n && n.toAbortSignal()], o), S;
  const v = g && g.unsubscribe && (() => {
    g.unsubscribe();
  });
  let d;
  try {
    if (l && yx && t !== "get" && t !== "head" && (d = await xx(h, r)) !== 0) {
      let b = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), w;
      if (Z.isFormData(r) && (w = b.headers.get("content-type")) && h.setContentType(w), b.body) {
        const [x, y] = Vd(
          d,
          Ma(Ud(l))
        );
        r = Nd(b.body, Yd, x, y);
      }
    }
    Z.isString(f) || (f = f ? "include" : "omit");
    const O = "credentials" in Request.prototype;
    S = new Request(e, {
      ...u,
      signal: g,
      method: t.toUpperCase(),
      headers: h.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: O ? f : void 0
    });
    let p = await fetch(S);
    const m = xh && (c === "stream" || c === "response");
    if (xh && (a || m && v)) {
      const b = {};
      ["status", "statusText", "headers"].forEach((k) => {
        b[k] = p[k];
      });
      const w = Z.toFiniteNumber(p.headers.get("content-length")), [x, y] = a && Vd(
        w,
        Ma(Ud(a), !0)
      ) || [];
      p = new Response(
        Nd(p.body, Yd, x, () => {
          y && y(), v && v();
        }),
        b
      );
    }
    c = c || "text";
    let _ = await Da[Z.findKey(Da, c) || "text"](p, i);
    return !m && v && v(), await new Promise((b, w) => {
      _0(b, w, {
        data: _,
        headers: xt.from(p.headers),
        status: p.status,
        statusText: p.statusText,
        config: i,
        request: S
      });
    });
  } catch (O) {
    throw v && v(), O && O.name === "TypeError" && /Load failed|fetch/i.test(O.message) ? Object.assign(
      new fe("Network Error", fe.ERR_NETWORK, i, S),
      {
        cause: O.cause || O
      }
    ) : fe.from(O, O && O.code, i, S);
  }
}), kh = {
  http: Iw,
  xhr: gx,
  fetch: kx
};
Z.forEach(kh, (i, e) => {
  if (i) {
    try {
      Object.defineProperty(i, "name", { value: e });
    } catch {
    }
    Object.defineProperty(i, "adapterName", { value: e });
  }
});
const Fd = (i) => `- ${i}`, Cx = (i) => Z.isFunction(i) || i === null || i === !1, k0 = {
  getAdapter: (i) => {
    i = Z.isArray(i) ? i : [i];
    const { length: e } = i;
    let t, r;
    const s = {};
    for (let n = 0; n < e; n++) {
      t = i[n];
      let o;
      if (r = t, !Cx(t) && (r = kh[(o = String(t)).toLowerCase()], r === void 0))
        throw new fe(`Unknown adapter '${o}'`);
      if (r)
        break;
      s[o || "#" + n] = r;
    }
    if (!r) {
      const n = Object.entries(s).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? n.length > 1 ? `since :
` + n.map(Fd).join(`
`) : " " + Fd(n[0]) : "as no adapter specified";
      throw new fe(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: kh
};
function nc(i) {
  if (i.cancelToken && i.cancelToken.throwIfRequested(), i.signal && i.signal.aborted)
    throw new xs(null, i);
}
function Hd(i) {
  return nc(i), i.headers = xt.from(i.headers), i.data = sc.call(
    i,
    i.transformRequest
  ), ["post", "put", "patch"].indexOf(i.method) !== -1 && i.headers.setContentType("application/x-www-form-urlencoded", !1), k0.getAdapter(i.adapter || so.adapter)(i).then(function(r) {
    return nc(i), r.data = sc.call(
      i,
      i.transformResponse,
      r
    ), r.headers = xt.from(r.headers), r;
  }, function(r) {
    return S0(r) || (nc(i), r && r.response && (r.response.data = sc.call(
      i,
      i.transformResponse,
      r.response
    ), r.response.headers = xt.from(r.response.headers))), Promise.reject(r);
  });
}
const C0 = "1.9.0", $l = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((i, e) => {
  $l[i] = function(r) {
    return typeof r === i || "a" + (e < 1 ? "n " : " ") + i;
  };
});
const Gd = {};
$l.transitional = function(e, t, r) {
  function s(n, o) {
    return "[Axios v" + C0 + "] Transitional option '" + n + "'" + o + (r ? ". " + r : "");
  }
  return (n, o, a) => {
    if (e === !1)
      throw new fe(
        s(o, " has been removed" + (t ? " in " + t : "")),
        fe.ERR_DEPRECATED
      );
    return t && !Gd[o] && (Gd[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(n, o, a) : !0;
  };
};
$l.spelling = function(e) {
  return (t, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function Qx(i, e, t) {
  if (typeof i != "object")
    throw new fe("options must be an object", fe.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(i);
  let s = r.length;
  for (; s-- > 0; ) {
    const n = r[s], o = e[n];
    if (o) {
      const a = i[n], l = a === void 0 || o(a, n, i);
      if (l !== !0)
        throw new fe("option " + n + " must be " + l, fe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new fe("Unknown option " + n, fe.ERR_BAD_OPTION);
  }
}
const na = {
  assertOptions: Qx,
  validators: $l
}, ri = na.validators;
let Qr = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new Wd(),
      response: new Wd()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (r) {
      if (r instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const n = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? n && !String(r.stack).endsWith(n.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + n) : r.stack = n;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Ar(this.defaults, t);
    const { transitional: r, paramsSerializer: s, headers: n } = t;
    r !== void 0 && na.assertOptions(r, {
      silentJSONParsing: ri.transitional(ri.boolean),
      forcedJSONParsing: ri.transitional(ri.boolean),
      clarifyTimeoutError: ri.transitional(ri.boolean)
    }, !1), s != null && (Z.isFunction(s) ? t.paramsSerializer = {
      serialize: s
    } : na.assertOptions(s, {
      encode: ri.function,
      serialize: ri.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), na.assertOptions(t, {
      baseUrl: ri.spelling("baseURL"),
      withXsrfToken: ri.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let o = n && Z.merge(
      n.common,
      n[t.method]
    );
    n && Z.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (S) => {
        delete n[S];
      }
    ), t.headers = xt.concat(o, n);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(t) === !1 || (l = l && v.synchronous, a.unshift(v.fulfilled, v.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(v) {
      c.push(v.fulfilled, v.rejected);
    });
    let h, f = 0, u;
    if (!l) {
      const S = [Hd.bind(this), void 0];
      for (S.unshift.apply(S, a), S.push.apply(S, c), u = S.length, h = Promise.resolve(t); f < u; )
        h = h.then(S[f++], S[f++]);
      return h;
    }
    u = a.length;
    let g = t;
    for (f = 0; f < u; ) {
      const S = a[f++], v = a[f++];
      try {
        g = S(g);
      } catch (d) {
        v.call(this, d);
        break;
      }
    }
    try {
      h = Hd.call(this, g);
    } catch (S) {
      return Promise.reject(S);
    }
    for (f = 0, u = c.length; f < u; )
      h = h.then(c[f++], c[f++]);
    return h;
  }
  getUri(e) {
    e = Ar(this.defaults, e);
    const t = b0(e.baseURL, e.url, e.allowAbsoluteUrls);
    return g0(t, e.params, e.paramsSerializer);
  }
};
Z.forEach(["delete", "get", "head", "options"], function(e) {
  Qr.prototype[e] = function(t, r) {
    return this.request(Ar(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
Z.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(n, o, a) {
      return this.request(Ar(a || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: n,
        data: o
      }));
    };
  }
  Qr.prototype[e] = t(), Qr.prototype[e + "Form"] = t(!0);
});
let Px = class Q0 {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(n) {
      t = n;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners) return;
      let n = r._listeners.length;
      for (; n-- > 0; )
        r._listeners[n](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let n;
      const o = new Promise((a) => {
        r.subscribe(a), n = a;
      }).then(s);
      return o.cancel = function() {
        r.unsubscribe(n);
      }, o;
    }, e(function(n, o, a) {
      r.reason || (r.reason = new xs(n, o, a), t(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (r) => {
      e.abort(r);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new Q0(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function $x(i) {
  return function(t) {
    return i.apply(null, t);
  };
}
function Tx(i) {
  return Z.isObject(i) && i.isAxiosError === !0;
}
const Ch = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Ch).forEach(([i, e]) => {
  Ch[e] = i;
});
function P0(i) {
  const e = new Qr(i), t = s0(Qr.prototype.request, e);
  return Z.extend(t, Qr.prototype, e, { allOwnKeys: !0 }), Z.extend(t, e, null, { allOwnKeys: !0 }), t.create = function(s) {
    return P0(Ar(i, s));
  }, t;
}
const Ze = P0(so);
Ze.Axios = Qr;
Ze.CanceledError = xs;
Ze.CancelToken = Px;
Ze.isCancel = S0;
Ze.VERSION = C0;
Ze.toFormData = Ql;
Ze.AxiosError = fe;
Ze.Cancel = Ze.CanceledError;
Ze.all = function(e) {
  return Promise.all(e);
};
Ze.spread = $x;
Ze.isAxiosError = Tx;
Ze.mergeConfig = Ar;
Ze.AxiosHeaders = xt;
Ze.formToJSON = (i) => v0(Z.isHTMLForm(i) ? new FormData(i) : i);
Ze.getAdapter = k0.getAdapter;
Ze.HttpStatusCode = Ch;
Ze.default = Ze;
const {
  Axios: J3,
  AxiosError: eX,
  CanceledError: tX,
  isCancel: iX,
  CancelToken: rX,
  VERSION: sX,
  all: nX,
  Cancel: oX,
  isAxiosError: aX,
  spread: lX,
  toFormData: cX,
  AxiosHeaders: hX,
  HttpStatusCode: fX,
  formToJSON: uX,
  getAdapter: dX,
  mergeConfig: OX
} = Ze, Rx = "http://localhost:5000/api";
let $0 = () => localStorage.getItem("token");
function Ex(i) {
  $0 = i;
}
const Si = Ze.create({
  baseURL: Rx,
  headers: {
    "Content-Type": "application/json"
  }
});
Si.interceptors.request.use(
  (i) => {
    const e = $0();
    return e ? i.headers.Authorization = `Bearer ${e}` : delete i.headers.Authorization, i;
  },
  (i) => Promise.reject(i)
);
const T0 = to(), Ax = (i) => {
  const [e, t] = ie(!1), [r, s] = uu({});
  Ex(() => r.token || localStorage.getItem("token")), kt(() => {
    const a = localStorage.getItem("token"), l = localStorage.getItem("user");
    if (a && l)
      try {
        const c = JSON.parse(l);
        s({
          ...c,
          token: a
        }), t(!0);
      } catch {
        console.warn("Failed to parse saved user"), localStorage.removeItem("token"), localStorage.removeItem("user");
      }
  });
  const n = async (a) => {
    const l = await Si.post("/auth/login", a);
    if (!l.data) throw new Error("Login failed");
    const {
      accessToken: c,
      user: h
    } = await l.data;
    s({
      ...h,
      token: c
    }), t(!0), localStorage.setItem("token", c), localStorage.setItem("user", JSON.stringify(h));
  }, o = () => {
    s({}), t(!1), localStorage.removeItem("token"), localStorage.removeItem("user");
  };
  return B(T0.Provider, {
    value: {
      isAuthenticated: e,
      user: () => r,
      login: n,
      logout: o
    },
    get children() {
      return i.children;
    }
  });
}, wi = () => {
  const i = Ir(T0);
  if (!i) throw new Error("useAuth must be used within an AuthProvider");
  return i;
}, gu = [
  { slug: "tts", title: "TTS", subTitle: "TextToSpeech", show: !0 },
  { slug: "editor", title: "Editor", subTitle: "Editor", show: !0 },
  { slug: "file-gallery", title: "File Gallery", subTitle: "File Gallery", show: !0 },
  { slug: "downloader", title: "Downloader", subTitle: "Editor", show: !0 },
  { slug: "privacy", title: "Privacy Policy", subTitle: "Privacy  Policy.", show: !1 },
  { slug: "terms", title: "Terms & Conditions", subTitle: "Terms & Conditions", show: !1 }
];
var Lx = /* @__PURE__ */ Y("<button>");
function Di(i) {
  const [e, t] = lu(i, ["class", "disabled", "children", "variant"]), r = (s) => {
    switch (s) {
      case "primary":
        return "bg-sky-500 text-gray-950 outline-sky-300 outline outline-offset-1 hover:outline-2";
      case "secondary":
        return "bg-sky-100 text-slate-950 outline-slate-300 outline outline-offset-1 hover:outline-2";
      case "outline":
        return "bg-gray-950/10 border-gray-500/30 outline outline-gray-500/30 outline-offset-1 hover:outline-2";
      default:
        return "";
    }
  };
  return (() => {
    var s = Lx();
    return bl(s, mn({
      get class() {
        return `${r(e.variant)} cursor-pointer inline-flex items-center justify-center rounded-md px-4 shadow-sm border transition font-medium ${e.class || ""}`;
      },
      get disabled() {
        return e.disabled;
      }
    }, t), !1, !0), X(s, () => e.children), s;
  })();
}
He(["click"]);
let zt = [], Fi = 0;
const xo = 4;
let Mx = (i) => {
  let e = [], t = {
    get() {
      return t.lc || t.listen(() => {
      })(), t.value;
    },
    lc: 0,
    listen(r) {
      return t.lc = e.push(r), () => {
        for (let n = Fi + xo; n < zt.length; )
          zt[n] === r ? zt.splice(n, xo) : n += xo;
        let s = e.indexOf(r);
        ~s && (e.splice(s, 1), --t.lc || t.off());
      };
    },
    notify(r, s) {
      let n = !zt.length;
      for (let o of e)
        zt.push(o, t.value, r, s);
      if (n) {
        for (Fi = 0; Fi < zt.length; Fi += xo)
          zt[Fi](
            zt[Fi + 1],
            zt[Fi + 2],
            zt[Fi + 3]
          );
        zt.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(r) {
      let s = t.value;
      s !== r && (t.value = r, t.notify(s));
    },
    subscribe(r) {
      let s = t.listen(r);
      return r(t.value), s;
    },
    value: i
  };
  return t;
};
const Dx = 5, ko = 6, Co = 10;
let qx = (i, e, t, r) => (i.events = i.events || {}, i.events[t + Co] || (i.events[t + Co] = r((s) => {
  i.events[t].reduceRight((n, o) => (o(n), n), {
    shared: {},
    ...s
  });
})), i.events[t] = i.events[t] || [], i.events[t].push(e), () => {
  let s = i.events[t], n = s.indexOf(e);
  s.splice(n, 1), s.length || (delete i.events[t], i.events[t + Co](), delete i.events[t + Co]);
}), Bx = 1e3, Xx = (i, e) => qx(i, (r) => {
  let s = e(r);
  s && i.events[ko].push(s);
}, Dx, (r) => {
  let s = i.listen;
  i.listen = (...o) => (!i.lc && !i.active && (i.active = !0, r()), s(...o));
  let n = i.off;
  return i.events[ko] = [], i.off = () => {
    n(), setTimeout(() => {
      if (i.active && !i.lc) {
        i.active = !1;
        for (let o of i.events[ko]) o();
        i.events[ko] = [];
      }
    }, Bx);
  }, () => {
    i.listen = s, i.off = n;
  };
}), Kd = (i) => i, jr = {}, Qh = { addEventListener() {
}, removeEventListener() {
} };
function Ix() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
Ix() && (jr = localStorage);
let Zx = {
  addEventListener(i, e, t) {
    window.addEventListener("storage", e), window.addEventListener("pageshow", t);
  },
  removeEventListener(i, e, t) {
    window.removeEventListener("storage", e), window.removeEventListener("pageshow", t);
  }
};
typeof window < "u" && (Qh = Zx);
function Wx(i, e = void 0, t = {}) {
  let r = t.encode || Kd, s = t.decode || Kd, n = Mx(e), o = n.set;
  n.set = (c) => {
    typeof c > "u" ? delete jr[i] : jr[i] = r(c), o(c);
  };
  function a(c) {
    c.key === i ? c.newValue === null ? o(void 0) : o(s(c.newValue)) : jr[i] || o(void 0);
  }
  function l() {
    n.set(jr[i] ? s(jr[i]) : e);
  }
  return Xx(n, () => {
    if (l(), t.listen !== !1)
      return Qh.addEventListener(i, a, l), () => {
        Qh.removeEventListener(i, a, l);
      };
  }), n;
}
const zx = () => typeof window > "u" || !window.matchMedia ? "light" : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light", Vx = (() => {
  try {
    const i = localStorage.getItem("theme");
    if (i) return JSON.parse(i);
  } catch {
  }
  return zx();
})(), xn = Wx("theme", Vx, {
  encode: JSON.stringify,
  decode: JSON.parse
});
function Ux() {
  const i = xn.get();
  xn.set(i === "dark" ? "light" : "dark");
}
function R0(i) {
  let e = i.listen(() => {
  }), [t, r] = uu({ value: i.get() }), s = i.subscribe((n) => {
    r("value", J1(n));
  });
  return ft(() => s()), e(), () => t.value;
}
var jx = /* @__PURE__ */ Y('<svg class="h-5 w-5 text-sky-400 hover:text-sky-500"fill=currentColor viewBox="0 0 20 20"><path fill-rule=evenodd d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z"clip-rule=evenodd>'), Nx = /* @__PURE__ */ Y("<button type=button>"), Yx = /* @__PURE__ */ Y('<svg class="h-5 w-5 text-gray-500 hover:text-gray-600"fill=currentColor viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z">');
const Fx = (i) => {
  const e = R0(xn), t = () => e() === "dark";
  return (() => {
    var r = Nx();
    return cu(r, "click", Ux, !0), X(r, B(pe, {
      get when() {
        return t();
      },
      get fallback() {
        return Yx();
      },
      get children() {
        return jx();
      }
    })), ce((s) => {
      var n = `rounded-md p-2 focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 focus:outline-none dark:focus:ring-offset-gray-800 ${i.class || ""}`, o = t() ? "Switch to light mode" : "Switch to dark mode";
      return n !== s.e && Fe(r, s.e = n), o !== s.t && Ee(r, "aria-label", s.t = o), s;
    }, {
      e: void 0,
      t: void 0
    }), r;
  })();
};
He(["click"]);
var Hx = /* @__PURE__ */ Y('<nav class><div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8"><div class="flex h-16 items-center justify-between"><div class="flex lg:hidden"><button type=button class="inline-flex items-center justify-center rounded-md focus:outline-none focus:ring-2 focus:ring-white"><span class=sr-only>Open main menu</span><svg class="h-6 w-6"fill=none viewBox="0 0 24 24"stroke-width=1.5 stroke=currentColor aria-hidden=true><path stroke-linecap=round stroke-linejoin=round d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:items-center text-sm lg:gap-x-8 uppercase tracking-widest font-light text-shadow-2xs ">');
function Gx() {
  const {
    isAuthenticated: i,
    logout: e
  } = wi();
  hr();
  const t = Hm();
  t.pathname;
  const r = (s) => t.pathname === s;
  return (() => {
    var s = Hx(), n = s.firstChild, o = n.firstChild, a = o.firstChild, l = a.nextSibling;
    return X(l, B(pe, {
      get when() {
        return i();
      },
      get children() {
        return [B(bn, {
          href: "/dashboard",
          get class() {
            return `transition-colors ${r("/dashboard") ? "text-sky-500 font-medium" : ""}`;
          },
          children: "Dashboard"
        }), B(rt, {
          each: gu,
          children: (c) => c.show && B(bn, {
            get href() {
              return `/${c.slug}`;
            },
            get class() {
              return `transition-colors ${r(`/${c.slug}`) ? "text-sky-500 font-medium" : ""}`;
            },
            get title() {
              return c.title;
            },
            get children() {
              return c.title;
            }
          })
        })];
      }
    })), s;
  })();
}
const kn = {
  name: "Project Board",
  logo: "/logo.svg"
  // You can change this path to your actual logo
};
var Kx = /* @__PURE__ */ Y('<a href=/><div class="flex align-center justify-center gap-4"><span class=sr-only></span></div><div class="mt-1 uppercase tracking-widest font-light text-shadow-2xs "><b class="font-bold text-shadow-black">Project</b> Board'), Jx = /* @__PURE__ */ Y("<img>"), ek = /* @__PURE__ */ Y("<div>");
const E0 = (i) => (() => {
  var e = Kx(), t = e.firstChild, r = t.firstChild;
  return X(r, () => i.name || "Your Company Name"), X(t, (() => {
    var s = ct(() => !!i.logo);
    return () => s() ? (() => {
      var n = Jx();
      return ce((o) => {
        var a = `h-${i.height || 8} w-${i.width || "auto"}`, l = i.logo, c = i.name;
        return a !== o.e && Fe(n, o.e = a), l !== o.t && Ee(n, "src", o.t = l), c !== o.a && Ee(n, "alt", o.a = c), o;
      }, {
        e: void 0,
        t: void 0,
        a: void 0
      }), n;
    })() : (() => {
      var n = ek();
      return X(n, () => i.name.charAt(0).toUpperCase()), ce(() => Fe(n, `bg-sky-600 dark:bg-sky-400 text-gray-950 flex w-8 items-center justify-center font-semibold rounded-lg h-${i.height || 8} w-${i.width || 8}`)), n;
    })();
  })(), null), ce(() => Fe(e, `cursor-pointer flex items-center justify-center gap-2 ${i.className || ""}`)), e;
})();
var tk = /* @__PURE__ */ Y('<div class=py-6><a href=/login class="-mx-3 block rounded-lg px-3 py-2.5 text-base font-semibold leading-7 text-gray-900 hover:bg-gray-50">Log in'), ik = /* @__PURE__ */ Y('<div class=lg:hidden role=dialog aria-modal=true><div class="fixed inset-0 z-50"></div><div class="fixed inset-y-0 right-0 z-50 w-full overflow-y-auto bg-white px-6 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10"><div class="flex items-center justify-between"><button type=button class="-m-2.5 rounded-md p-2.5 text-gray-700"><span class=sr-only>Close menu</span><svg class=size-6 fill=none viewBox="0 0 24 24"stroke-width=1.5 stroke=currentColor aria-hidden=true><path stroke-linecap=round stroke-linejoin=round d="M6 18L18 6M6 6l12 12"></path></svg></button></div><div class="mt-6 flow-root"><div class="-my-6 divide-y divide-gray-500/10"><div class="space-y-2 py-6">'), rk = /* @__PURE__ */ Y('<a class="-mx-3 block rounded-lg px-3 py-2 text-base font-semibold leading-7 text-gray-900 hover:bg-gray-50">');
const sk = () => {
  const {
    isAuthenticated: i
  } = wi();
  return (() => {
    var e = ik(), t = e.firstChild, r = t.nextSibling, s = r.firstChild, n = s.firstChild, o = s.nextSibling, a = o.firstChild, l = a.firstChild;
    return X(s, B(E0, {
      get name() {
        return kn.name;
      },
      get logo() {
        return kn.logo;
      }
    }), n), X(l, B(rt, {
      each: gu,
      children: (c) => B(pe, {
        get when() {
          return c.show;
        },
        get children() {
          var h = rk();
          return X(h, () => c.title), ce((f) => {
            var u = c.slug === "home" ? "/" : `/${c.slug}`, g = c.title;
            return u !== f.e && Ee(h, "href", f.e = u), g !== f.t && Ee(h, "title", f.t = g), f;
          }, {
            e: void 0,
            t: void 0
          }), h;
        }
      })
    })), X(a, B(pe, {
      get when() {
        return !i();
      },
      get children() {
        return tk();
      }
    }), null), e;
  })();
};
var nk = /* @__PURE__ */ Y('<img alt=Profile class="h-full w-full object-cover">'), ok = /* @__PURE__ */ Y('<div class="absolute top-9 right-0 z-50 mt-2 w-60 origin-top-right rounded-md border bg-gray-800/20 border-gray-500/30 p-4 shadow-lg transition"><div class="flex h-full flex-col justify-between space-y-4"><div class="flex flex-col space-y-2">'), ak = /* @__PURE__ */ Y('<div class="relative flex items-center justify-center">'), lk = /* @__PURE__ */ Y("<span class=text-gray-950>");
function ck() {
  const {
    isAuthenticated: i,
    user: e,
    logout: t
  } = wi(), r = hr(), [s, n] = ie(!1);
  let o;
  const a = (h) => {
    o && !o.contains(h.target) && n(!1);
  };
  kt(() => document.addEventListener("mousedown", a)), ft(() => document.removeEventListener("mousedown", a));
  const l = async () => {
    await t(), n(!1), r("/login");
  }, c = () => (e()?.name || e()?.email || "U")[0].toUpperCase();
  return B(pe, {
    get when() {
      return i();
    },
    get fallback() {
      return B(bn, {
        href: "/login",
        class: "no-underline",
        get children() {
          return B(Di, {
            variant: "secondary",
            children: "Login"
          });
        }
      });
    },
    get children() {
      var h = ak();
      return X(h, B(Di, {
        onClick: () => n((f) => !f),
        variant: "primary",
        class: "rounded-full w-8 h-8 ",
        "aria-label": "Toggle menu",
        get children() {
          return B(pe, {
            get when() {
              return e()?.image;
            },
            get fallback() {
              return (() => {
                var f = lk();
                return X(f, c), f;
              })();
            },
            get children() {
              var f = nk();
              return ce(() => Ee(f, "src", e()?.image)), f;
            }
          });
        }
      }), null), X(h, B(pe, {
        get when() {
          return s();
        },
        get children() {
          var f = ok(), u = f.firstChild, g = u.firstChild, S = o;
          return typeof S == "function" ? mi(S, f) : o = f, X(g, B(bn, {
            href: "/profile",
            onClick: () => n(!1),
            class: "",
            children: "View Profile"
          })), X(u, B(Di, {
            onClick: l,
            class: "w-full",
            children: "Logout"
          }), null), f;
        }
      }), null), h;
    }
  });
}
var hk = /* @__PURE__ */ Y('<header class="sticky top-0 z-50 h-[3rem] flex items-center border-b bg-gray-800/10 border-gray-500/30 justify-between px-4"><div class="flex items-center justify-center "><div class="flex-1 align-center"></div><nav class="hidden md:flex"></nav></div><div class=md:hidden></div><div class="flex items-center justify-between gap-x-4">');
function fk() {
  return (() => {
    var i = hk(), e = i.firstChild, t = e.firstChild, r = t.nextSibling, s = e.nextSibling, n = s.nextSibling;
    return X(t, B(E0, {
      get name() {
        return kn.name;
      }
    })), X(r, B(Gx, {})), X(s, B(sk, {})), X(n, B(Fx, {}), null), X(n, B(ck, {}), null), i;
  })();
}
var uk = /* @__PURE__ */ Y('<footer class="sticky bottom-0 z-50 h-[2rem] flex items-center border-t bg-gray-500/10 border-gray-800/50 justify-between px-4"><div class="flex items-center justify-start"><p>© 2025 <!>. All rights reserved.</p><nav class="lg:flex lg:gap-x-6 ml-4">'), dk = /* @__PURE__ */ Y('<a class="hover:text-blue-600 dark:hover:text-blue-400">');
const Ok = (i) => (() => {
  var e = uk(), t = e.firstChild, r = t.firstChild, s = r.firstChild, n = s.nextSibling;
  n.nextSibling;
  var o = r.nextSibling;
  return X(r, () => kn.name, n), X(o, B(rt, {
    get each() {
      return i.links;
    },
    children: (a) => B(pe, {
      get when() {
        return a.show;
      },
      get children() {
        var l = dk();
        return X(l, () => a.title), ce(() => Ee(l, "href", a.slug === "home" ? "/" : `/${a.slug}`)), l;
      }
    })
  })), e;
})();
/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt
* files at https://github.com/iconify/iconify
*
* Licensed under MIT.
*
* @license MIT
* @version 3.0.0
*/
const A0 = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), qa = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), no = Object.freeze({
  ...A0,
  ...qa
}), Ph = Object.freeze({
  ...no,
  body: "",
  hidden: !1
}), pk = Object.freeze({
  width: null,
  height: null
}), L0 = Object.freeze({
  // Dimensions
  ...pk,
  // Transformations
  ...qa
});
function gk(i, e = 0) {
  const t = i.replace(/^-?[0-9.]*/, "");
  function r(s) {
    for (; s < 0; )
      s += 4;
    return s % 4;
  }
  if (t === "") {
    const s = parseInt(i);
    return isNaN(s) ? 0 : r(s);
  } else if (t !== i) {
    let s = 0;
    switch (t) {
      case "%":
        s = 25;
        break;
      case "deg":
        s = 90;
    }
    if (s) {
      let n = parseFloat(i.slice(0, i.length - t.length));
      return isNaN(n) ? 0 : (n = n / s, n % 1 === 0 ? r(n) : 0);
    }
  }
  return e;
}
const mk = /[\s,]+/;
function vk(i, e) {
  e.split(mk).forEach((t) => {
    switch (t.trim()) {
      case "horizontal":
        i.hFlip = !0;
        break;
      case "vertical":
        i.vFlip = !0;
        break;
    }
  });
}
const M0 = {
  ...L0,
  preserveAspectRatio: ""
};
function Jd(i) {
  const e = {
    ...M0
  }, t = (r, s) => i.getAttribute(r) || s;
  return e.width = t("width", null), e.height = t("height", null), e.rotate = gk(t("rotate", "")), vk(e, t("flip", "")), e.preserveAspectRatio = t("preserveAspectRatio", t("preserveaspectratio", "")), e;
}
function Sk(i, e) {
  for (const t in M0)
    if (i[t] !== e[t])
      return !0;
  return !1;
}
const D0 = /^[a-z0-9]+(-[a-z0-9]+)*$/, oo = (i, e, t, r = "") => {
  const s = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (s.length < 2 || s.length > 3)
      return null;
    r = s.shift().slice(1);
  }
  if (s.length > 3 || !s.length)
    return null;
  if (s.length > 1) {
    const a = s.pop(), l = s.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: s.length > 0 ? s[0] : r,
      prefix: l,
      name: a
    };
    return e && !oa(c) ? null : c;
  }
  const n = s[0], o = n.split("-");
  if (o.length > 1) {
    const a = {
      provider: r,
      prefix: o.shift(),
      name: o.join("-")
    };
    return e && !oa(a) ? null : a;
  }
  if (t && r === "") {
    const a = {
      provider: r,
      prefix: "",
      name: n
    };
    return e && !oa(a, t) ? null : a;
  }
  return null;
}, oa = (i, e) => i ? !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
// Check name: cannot be empty
((e && i.prefix === "" || i.prefix) && i.name) : !1;
function _k(i, e) {
  const t = {};
  !i.hFlip != !e.hFlip && (t.hFlip = !0), !i.vFlip != !e.vFlip && (t.vFlip = !0);
  const r = ((i.rotate || 0) + (e.rotate || 0)) % 4;
  return r && (t.rotate = r), t;
}
function eO(i, e) {
  const t = _k(i, e);
  for (const r in Ph)
    r in qa ? r in i && !(r in t) && (t[r] = qa[r]) : r in e ? t[r] = e[r] : r in i && (t[r] = i[r]);
  return t;
}
function bk(i, e) {
  const t = i.icons, r = i.aliases || /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null);
  function n(o) {
    if (t[o])
      return s[o] = [];
    if (!(o in s)) {
      s[o] = null;
      const a = r[o] && r[o].parent, l = a && n(a);
      l && (s[o] = [a].concat(l));
    }
    return s[o];
  }
  return Object.keys(t).concat(Object.keys(r)).forEach(n), s;
}
function yk(i, e, t) {
  const r = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null);
  let n = {};
  function o(a) {
    n = eO(
      r[a] || s[a],
      n
    );
  }
  return o(e), t.forEach(o), eO(i, n);
}
function q0(i, e) {
  const t = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return t;
  i.not_found instanceof Array && i.not_found.forEach((s) => {
    e(s, null), t.push(s);
  });
  const r = bk(i);
  for (const s in r) {
    const n = r[s];
    n && (e(s, yk(i, s, n)), t.push(s));
  }
  return t;
}
const wk = {
  provider: "",
  aliases: {},
  not_found: {},
  ...A0
};
function oc(i, e) {
  for (const t in e)
    if (t in i && typeof i[t] != typeof e[t])
      return !1;
  return !0;
}
function B0(i) {
  if (typeof i != "object" || i === null)
    return null;
  const e = i;
  if (typeof e.prefix != "string" || !i.icons || typeof i.icons != "object" || !oc(i, wk))
    return null;
  const t = e.icons;
  for (const s in t) {
    const n = t[s];
    if (
      // Name cannot be empty
      !s || // Must have body
      typeof n.body != "string" || // Check other props
      !oc(
        n,
        Ph
      )
    )
      return null;
  }
  const r = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const s in r) {
    const n = r[s], o = n.parent;
    if (
      // Name cannot be empty
      !s || // Parent must be set and point to existing icon
      typeof o != "string" || !t[o] && !r[o] || // Check other props
      !oc(
        n,
        Ph
      )
    )
      return null;
  }
  return e;
}
const Ba = /* @__PURE__ */ Object.create(null);
function xk(i, e) {
  return {
    provider: i,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Xi(i, e) {
  const t = Ba[i] || (Ba[i] = /* @__PURE__ */ Object.create(null));
  return t[e] || (t[e] = xk(i, e));
}
function X0(i, e) {
  return B0(e) ? q0(e, (t, r) => {
    r ? i.icons[t] = r : i.missing.add(t);
  }) : [];
}
function kk(i, e, t) {
  try {
    if (typeof t.body == "string")
      return i.icons[e] = { ...t }, !0;
  } catch {
  }
  return !1;
}
function Ck(i, e) {
  let t = [];
  return (typeof i == "string" ? [i] : Object.keys(Ba)).forEach((s) => {
    (typeof s == "string" && typeof e == "string" ? [e] : Object.keys(Ba[s] || {})).forEach((o) => {
      const a = Xi(s, o);
      t = t.concat(
        Object.keys(a.icons).map(
          (l) => (s !== "" ? "@" + s + ":" : "") + o + ":" + l
        )
      );
    });
  }), t;
}
let Cn = !1;
function I0(i) {
  return typeof i == "boolean" && (Cn = i), Cn;
}
function Qn(i) {
  const e = typeof i == "string" ? oo(i, !0, Cn) : i;
  if (e) {
    const t = Xi(e.provider, e.prefix), r = e.name;
    return t.icons[r] || (t.missing.has(r) ? null : void 0);
  }
}
function Z0(i, e) {
  const t = oo(i, !0, Cn);
  if (!t)
    return !1;
  const r = Xi(t.provider, t.prefix);
  return e ? kk(r, t.name, e) : (r.missing.add(t.name), !0);
}
function tO(i, e) {
  if (typeof i != "object")
    return !1;
  if (typeof e != "string" && (e = i.provider || ""), Cn && !e && !i.prefix) {
    let s = !1;
    return B0(i) && (i.prefix = "", q0(i, (n, o) => {
      Z0(n, o) && (s = !0);
    })), s;
  }
  const t = i.prefix;
  if (!oa({
    prefix: t,
    name: "a"
  }))
    return !1;
  const r = Xi(e, t);
  return !!X0(r, i);
}
function Qk(i) {
  return !!Qn(i);
}
function Pk(i) {
  const e = Qn(i);
  return e && {
    ...no,
    ...e
  };
}
function $k(i) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, t = /* @__PURE__ */ Object.create(null);
  i.sort((s, n) => s.provider !== n.provider ? s.provider.localeCompare(n.provider) : s.prefix !== n.prefix ? s.prefix.localeCompare(n.prefix) : s.name.localeCompare(n.name));
  let r = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((s) => {
    if (r.name === s.name && r.prefix === s.prefix && r.provider === s.provider)
      return;
    r = s;
    const n = s.provider, o = s.prefix, a = s.name, l = t[n] || (t[n] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = Xi(n, o));
    let h;
    a in c.icons ? h = e.loaded : o === "" || c.missing.has(a) ? h = e.missing : h = e.pending;
    const f = {
      provider: n,
      prefix: o,
      name: a
    };
    h.push(f);
  }), e;
}
function W0(i, e) {
  i.forEach((t) => {
    const r = t.loaderCallbacks;
    r && (t.loaderCallbacks = r.filter((s) => s.id !== e));
  });
}
function Tk(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = !0, setTimeout(() => {
    i.pendingCallbacksFlag = !1;
    const e = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let t = !1;
    const r = i.provider, s = i.prefix;
    e.forEach((n) => {
      const o = n.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== s)
          return !0;
        const c = l.name;
        if (i.icons[c])
          o.loaded.push({
            provider: r,
            prefix: s,
            name: c
          });
        else if (i.missing.has(c))
          o.missing.push({
            provider: r,
            prefix: s,
            name: c
          });
        else
          return t = !0, !0;
        return !1;
      }), o.pending.length !== a && (t || W0([i], n.id), n.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        n.abort
      ));
    });
  }));
}
let Rk = 0;
function Ek(i, e, t) {
  const r = Rk++, s = W0.bind(null, t, r);
  if (!e.pending.length)
    return s;
  const n = {
    id: r,
    icons: e,
    callback: i,
    abort: s
  };
  return t.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(n);
  }), s;
}
const $h = /* @__PURE__ */ Object.create(null);
function iO(i, e) {
  $h[i] = e;
}
function Th(i) {
  return $h[i] || $h[""];
}
function Ak(i, e = !0, t = !1) {
  const r = [];
  return i.forEach((s) => {
    const n = typeof s == "string" ? oo(s, e, t) : s;
    n && r.push(n);
  }), r;
}
var Lk = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function Mk(i, e, t, r) {
  const s = i.resources.length, n = i.random ? Math.floor(Math.random() * s) : i.index;
  let o;
  if (i.random) {
    let w = i.resources.slice(0);
    for (o = []; w.length > 1; ) {
      const x = Math.floor(Math.random() * w.length);
      o.push(w[x]), w = w.slice(0, x).concat(w.slice(x + 1));
    }
    o = o.concat(w);
  } else
    o = i.resources.slice(n).concat(i.resources.slice(0, n));
  const a = Date.now();
  let l = "pending", c = 0, h, f = null, u = [], g = [];
  typeof r == "function" && g.push(r);
  function S() {
    f && (clearTimeout(f), f = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), S(), u.forEach((w) => {
      w.status === "pending" && (w.status = "aborted");
    }), u = [];
  }
  function d(w, x) {
    x && (g = []), typeof w == "function" && g.push(w);
  }
  function O() {
    return {
      startTime: a,
      payload: e,
      status: l,
      queriesSent: c,
      queriesPending: u.length,
      subscribe: d,
      abort: v
    };
  }
  function p() {
    l = "failed", g.forEach((w) => {
      w(void 0, h);
    });
  }
  function m() {
    u.forEach((w) => {
      w.status === "pending" && (w.status = "aborted");
    }), u = [];
  }
  function _(w, x, y) {
    const k = x !== "success";
    switch (u = u.filter((T) => T !== w), l) {
      case "pending":
        break;
      case "failed":
        if (k || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (x === "abort") {
      h = y, p();
      return;
    }
    if (k) {
      h = y, u.length || (o.length ? b() : p());
      return;
    }
    if (S(), m(), !i.random) {
      const T = i.resources.indexOf(w.resource);
      T !== -1 && T !== i.index && (i.index = T);
    }
    l = "completed", g.forEach((T) => {
      T(y);
    });
  }
  function b() {
    if (l !== "pending")
      return;
    S();
    const w = o.shift();
    if (w === void 0) {
      if (u.length) {
        f = setTimeout(() => {
          S(), l === "pending" && (m(), p());
        }, i.timeout);
        return;
      }
      p();
      return;
    }
    const x = {
      status: "pending",
      resource: w,
      callback: (y, k) => {
        _(x, y, k);
      }
    };
    u.push(x), c++, f = setTimeout(b, i.rotate), t(w, e, x.callback);
  }
  return setTimeout(b), O;
}
function z0(i) {
  const e = {
    ...Lk,
    ...i
  };
  let t = [];
  function r() {
    t = t.filter((a) => a().status === "pending");
  }
  function s(a, l, c) {
    const h = Mk(
      e,
      a,
      l,
      (f, u) => {
        r(), c && c(f, u);
      }
    );
    return t.push(h), h;
  }
  function n(a) {
    return t.find((l) => a(l)) || null;
  }
  return {
    query: s,
    find: n,
    setIndex: (a) => {
      e.index = a;
    },
    getIndex: () => e.index,
    cleanup: r
  };
}
function mu(i) {
  let e;
  if (typeof i.resources == "string")
    e = [i.resources];
  else if (e = i.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === !0,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== !1
  };
}
const Tl = /* @__PURE__ */ Object.create(null), Ms = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], aa = [];
for (; Ms.length > 0; )
  Ms.length === 1 || Math.random() > 0.5 ? aa.push(Ms.shift()) : aa.push(Ms.pop());
Tl[""] = mu({
  resources: ["https://api.iconify.design"].concat(aa)
});
function rO(i, e) {
  const t = mu(e);
  return t === null ? !1 : (Tl[i] = t, !0);
}
function Rl(i) {
  return Tl[i];
}
function Dk() {
  return Object.keys(Tl);
}
function sO() {
}
const ac = /* @__PURE__ */ Object.create(null);
function qk(i) {
  if (!ac[i]) {
    const e = Rl(i);
    if (!e)
      return;
    const t = z0(e), r = {
      config: e,
      redundancy: t
    };
    ac[i] = r;
  }
  return ac[i];
}
function V0(i, e, t) {
  let r, s;
  if (typeof i == "string") {
    const n = Th(i);
    if (!n)
      return t(void 0, 424), sO;
    s = n.send;
    const o = qk(i);
    o && (r = o.redundancy);
  } else {
    const n = mu(i);
    if (n) {
      r = z0(n);
      const o = i.resources ? i.resources[0] : "", a = Th(o);
      a && (s = a.send);
    }
  }
  return !r || !s ? (t(void 0, 424), sO) : r.query(e, s, t)().abort;
}
function nO() {
}
function Bk(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = !0, setTimeout(() => {
    i.iconsLoaderFlag = !1, Tk(i);
  }));
}
function Xk(i) {
  const e = [], t = [];
  return i.forEach((r) => {
    (r.match(D0) ? e : t).push(r);
  }), {
    valid: e,
    invalid: t
  };
}
function Ds(i, e, t) {
  function r() {
    const s = i.pendingIcons;
    e.forEach((n) => {
      s && s.delete(n), i.icons[n] || i.missing.add(n);
    });
  }
  if (t && typeof t == "object")
    try {
      if (!X0(i, t).length) {
        r();
        return;
      }
    } catch (s) {
      console.error(s);
    }
  r(), Bk(i);
}
function oO(i, e) {
  i instanceof Promise ? i.then((t) => {
    e(t);
  }).catch(() => {
    e(null);
  }) : e(i);
}
function Ik(i, e) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(e).sort() : i.iconsToLoad = e, i.iconsQueueFlag || (i.iconsQueueFlag = !0, setTimeout(() => {
    i.iconsQueueFlag = !1;
    const { provider: t, prefix: r } = i, s = i.iconsToLoad;
    if (delete i.iconsToLoad, !s || !s.length)
      return;
    const n = i.loadIcon;
    if (i.loadIcons && (s.length > 1 || !n)) {
      oO(
        i.loadIcons(s, r, t),
        (h) => {
          Ds(i, s, h);
        }
      );
      return;
    }
    if (n) {
      s.forEach((h) => {
        const f = n(h, r, t);
        oO(f, (u) => {
          const g = u ? {
            prefix: r,
            icons: {
              [h]: u
            }
          } : null;
          Ds(i, [h], g);
        });
      });
      return;
    }
    const { valid: o, invalid: a } = Xk(s);
    if (a.length && Ds(i, a, null), !o.length)
      return;
    const l = r.match(D0) ? Th(t) : null;
    if (!l) {
      Ds(i, o, null);
      return;
    }
    l.prepare(t, r, o).forEach((h) => {
      V0(t, h, (f) => {
        Ds(i, h.icons, f);
      });
    });
  }));
}
const vu = (i, e) => {
  const t = Ak(i, !0, I0()), r = $k(t);
  if (!r.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        r.loaded,
        r.missing,
        r.pending,
        nO
      );
    }), () => {
      l = !1;
    };
  }
  const s = /* @__PURE__ */ Object.create(null), n = [];
  let o, a;
  return r.pending.forEach((l) => {
    const { provider: c, prefix: h } = l;
    if (h === a && c === o)
      return;
    o = c, a = h, n.push(Xi(c, h));
    const f = s[c] || (s[c] = /* @__PURE__ */ Object.create(null));
    f[h] || (f[h] = []);
  }), r.pending.forEach((l) => {
    const { provider: c, prefix: h, name: f } = l, u = Xi(c, h), g = u.pendingIcons || (u.pendingIcons = /* @__PURE__ */ new Set());
    g.has(f) || (g.add(f), s[c][h].push(f));
  }), n.forEach((l) => {
    const c = s[l.provider][l.prefix];
    c.length && Ik(l, c);
  }), e ? Ek(e, r, n) : nO;
}, Zk = (i) => new Promise((e, t) => {
  const r = typeof i == "string" ? oo(i, !0) : i;
  if (!r) {
    t(i);
    return;
  }
  vu([r || i], (s) => {
    if (s.length && r) {
      const n = Qn(r);
      if (n) {
        e({
          ...no,
          ...n
        });
        return;
      }
    }
    t(i);
  });
});
function aO(i) {
  try {
    const e = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof e.body == "string")
      return {
        ...e
      };
  } catch {
  }
}
function Wk(i, e) {
  if (typeof i == "object")
    return {
      data: aO(i),
      value: i
    };
  if (typeof i != "string")
    return {
      value: i
    };
  if (i.includes("{")) {
    const n = aO(i);
    if (n)
      return {
        data: n,
        value: i
      };
  }
  const t = oo(i, !0, !0);
  if (!t)
    return {
      value: i
    };
  const r = Qn(t);
  if (r !== void 0 || !t.prefix)
    return {
      value: i,
      name: t,
      data: r
      // could be 'null' -> icon is missing
    };
  const s = vu([t], () => e(i, t, Qn(t)));
  return {
    value: i,
    name: t,
    loading: s
  };
}
let U0 = !1;
try {
  U0 = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function zk(i, e) {
  switch (e) {
    // Force mode
    case "svg":
    case "bg":
    case "mask":
      return e;
  }
  return e !== "style" && (U0 || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
const Vk = /(-?[0-9.]*[0-9]+[0-9.]*)/g, Uk = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Rh(i, e, t) {
  if (e === 1)
    return i;
  if (t = t || 100, typeof i == "number")
    return Math.ceil(i * e * t) / t;
  if (typeof i != "string")
    return i;
  const r = i.split(Vk);
  if (r === null || !r.length)
    return i;
  const s = [];
  let n = r.shift(), o = Uk.test(n);
  for (; ; ) {
    if (o) {
      const a = parseFloat(n);
      isNaN(a) ? s.push(n) : s.push(Math.ceil(a * e * t) / t);
    } else
      s.push(n);
    if (n = r.shift(), n === void 0)
      return s.join("");
    o = !o;
  }
}
function jk(i, e = "defs") {
  let t = "";
  const r = i.indexOf("<" + e);
  for (; r >= 0; ) {
    const s = i.indexOf(">", r), n = i.indexOf("</" + e);
    if (s === -1 || n === -1)
      break;
    const o = i.indexOf(">", n);
    if (o === -1)
      break;
    t += i.slice(s + 1, n).trim(), i = i.slice(0, r).trim() + i.slice(o + 1);
  }
  return {
    defs: t,
    content: i
  };
}
function Nk(i, e) {
  return i ? "<defs>" + i + "</defs>" + e : e;
}
function Yk(i, e, t) {
  const r = jk(i);
  return Nk(r.defs, e + r.content + t);
}
const Fk = (i) => i === "unset" || i === "undefined" || i === "none";
function j0(i, e) {
  const t = {
    ...no,
    ...i
  }, r = {
    ...L0,
    ...e
  }, s = {
    left: t.left,
    top: t.top,
    width: t.width,
    height: t.height
  };
  let n = t.body;
  [t, r].forEach((v) => {
    const d = [], O = v.hFlip, p = v.vFlip;
    let m = v.rotate;
    O ? p ? m += 2 : (d.push(
      "translate(" + (s.width + s.left).toString() + " " + (0 - s.top).toString() + ")"
    ), d.push("scale(-1 1)"), s.top = s.left = 0) : p && (d.push(
      "translate(" + (0 - s.left).toString() + " " + (s.height + s.top).toString() + ")"
    ), d.push("scale(1 -1)"), s.top = s.left = 0);
    let _;
    switch (m < 0 && (m -= Math.floor(m / 4) * 4), m = m % 4, m) {
      case 1:
        _ = s.height / 2 + s.top, d.unshift(
          "rotate(90 " + _.toString() + " " + _.toString() + ")"
        );
        break;
      case 2:
        d.unshift(
          "rotate(180 " + (s.width / 2 + s.left).toString() + " " + (s.height / 2 + s.top).toString() + ")"
        );
        break;
      case 3:
        _ = s.width / 2 + s.left, d.unshift(
          "rotate(-90 " + _.toString() + " " + _.toString() + ")"
        );
        break;
    }
    m % 2 === 1 && (s.left !== s.top && (_ = s.left, s.left = s.top, s.top = _), s.width !== s.height && (_ = s.width, s.width = s.height, s.height = _)), d.length && (n = Yk(
      n,
      '<g transform="' + d.join(" ") + '">',
      "</g>"
    ));
  });
  const o = r.width, a = r.height, l = s.width, c = s.height;
  let h, f;
  o === null ? (f = a === null ? "1em" : a === "auto" ? c : a, h = Rh(f, l / c)) : (h = o === "auto" ? l : o, f = a === null ? Rh(h, c / l) : a === "auto" ? c : a);
  const u = {}, g = (v, d) => {
    Fk(d) || (u[v] = d.toString());
  };
  g("width", h), g("height", f);
  const S = [s.left, s.top, l, c];
  return u.viewBox = S.join(" "), {
    attributes: u,
    viewBox: S,
    body: n
  };
}
function Su(i, e) {
  let t = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const r in e)
    t += " " + r + '="' + e[r] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + t + ">" + i + "</svg>";
}
function Hk(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Gk(i) {
  return "data:image/svg+xml," + Hk(i);
}
function N0(i) {
  return 'url("' + Gk(i) + '")';
}
const Kk = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
let Xa = Kk();
function Jk(i) {
  Xa = i;
}
function eC() {
  return Xa;
}
function tC(i, e) {
  const t = Rl(i);
  if (!t)
    return 0;
  let r;
  if (!t.maxURL)
    r = 0;
  else {
    let s = 0;
    t.resources.forEach((o) => {
      s = Math.max(s, o.length);
    });
    const n = e + ".json?icons=";
    r = t.maxURL - s - t.path.length - n.length;
  }
  return r;
}
function iC(i) {
  return i === 404;
}
const rC = (i, e, t) => {
  const r = [], s = tC(i, e), n = "icons";
  let o = {
    type: n,
    provider: i,
    prefix: e,
    icons: []
  }, a = 0;
  return t.forEach((l, c) => {
    a += l.length + 1, a >= s && c > 0 && (r.push(o), o = {
      type: n,
      provider: i,
      prefix: e,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), r.push(o), r;
};
function sC(i) {
  if (typeof i == "string") {
    const e = Rl(i);
    if (e)
      return e.path;
  }
  return "/";
}
const nC = (i, e, t) => {
  if (!Xa) {
    t("abort", 424);
    return;
  }
  let r = sC(e.provider);
  switch (e.type) {
    case "icons": {
      const n = e.prefix, a = e.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      r += n + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const n = e.uri;
      r += n.slice(0, 1) === "/" ? n.slice(1) : n;
      break;
    }
    default:
      t("abort", 400);
      return;
  }
  let s = 503;
  Xa(i + r).then((n) => {
    const o = n.status;
    if (o !== 200) {
      setTimeout(() => {
        t(iC(o) ? "abort" : "next", o);
      });
      return;
    }
    return s = 501, n.json();
  }).then((n) => {
    if (typeof n != "object" || n === null) {
      setTimeout(() => {
        n === 404 ? t("abort", n) : t("next", s);
      });
      return;
    }
    setTimeout(() => {
      t("success", n);
    });
  }).catch(() => {
    t("next", s);
  });
}, oC = {
  prepare: rC,
  send: nC
};
function aC(i, e, t) {
  Xi(t || "", e).loadIcons = i;
}
function lC(i, e, t) {
  Xi(t || "", e).loadIcon = i;
}
const lc = "data-style";
let Y0 = "";
function cC(i) {
  Y0 = i;
}
function lO(i, e) {
  let t = Array.from(i.childNodes).find((r) => r.hasAttribute && r.hasAttribute(lc));
  t || (t = document.createElement("style"), t.setAttribute(lc, lc), i.appendChild(t)), t.textContent = ":host{display:inline-block;vertical-align:" + (e ? "-0.125em" : "0") + "}span,svg{display:block;margin:auto}" + Y0;
}
function F0() {
  iO("", oC), I0(!0);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (i.IconifyPreload !== void 0) {
      const t = i.IconifyPreload, r = "Invalid IconifyPreload syntax.";
      typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((s) => {
        try {
          // Check if item is an object and not null/array
          (typeof s != "object" || s === null || s instanceof Array || // Check for 'icons' and 'prefix'
          typeof s.icons != "object" || typeof s.prefix != "string" || // Add icon set
          !tO(s)) && console.error(r);
        } catch {
          console.error(r);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const t = i.IconifyProviders;
      if (typeof t == "object" && t !== null)
        for (const r in t) {
          const s = "IconifyProviders[" + r + "] is invalid.";
          try {
            const n = t[r];
            if (typeof n != "object" || !n || n.resources === void 0)
              continue;
            rO(r, n) || console.error(s);
          } catch {
            console.error(s);
          }
        }
    }
  }
  return {
    iconLoaded: Qk,
    getIcon: Pk,
    listIcons: Ck,
    addIcon: Z0,
    addCollection: tO,
    calculateSize: Rh,
    buildIcon: j0,
    iconToHTML: Su,
    svgToURL: N0,
    loadIcons: vu,
    loadIcon: Zk,
    addAPIProvider: rO,
    setCustomIconLoader: lC,
    setCustomIconsLoader: aC,
    appendCustomStyle: cC,
    _api: {
      getAPIConfig: Rl,
      setAPIModule: iO,
      sendAPIQuery: V0,
      setFetch: Jk,
      getFetch: eC,
      listAPIProviders: Dk
    }
  };
}
const Eh = {
  "background-color": "currentColor"
}, H0 = {
  "background-color": "transparent"
}, cO = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
}, hO = {
  "-webkit-mask": Eh,
  mask: Eh,
  background: H0
};
for (const i in hO) {
  const e = hO[i];
  for (const t in cO)
    e[i + "-" + t] = cO[t];
}
function fO(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function hC(i, e, t) {
  const r = document.createElement("span");
  let s = i.body;
  s.indexOf("<a") !== -1 && (s += "<!-- " + Date.now() + " -->");
  const n = i.attributes, o = Su(s, {
    ...n,
    width: e.width + "",
    height: e.height + ""
  }), a = N0(o), l = r.style, c = {
    "--svg": a,
    width: fO(n.width),
    height: fO(n.height),
    ...t ? Eh : H0
  };
  for (const h in c)
    l.setProperty(h, c[h]);
  return r;
}
let sn;
function fC() {
  try {
    sn = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    sn = null;
  }
}
function uC(i) {
  return sn === void 0 && fC(), sn ? sn.createHTML(i) : i;
}
function dC(i) {
  const e = document.createElement("span"), t = i.attributes;
  let r = "";
  t.width || (r = "width: inherit;"), t.height || (r += "height: inherit;"), r && (t.style = r);
  const s = Su(i.body, t);
  return e.innerHTML = uC(s), e.firstChild;
}
function Ah(i) {
  return Array.from(i.childNodes).find((e) => {
    const t = e.tagName && e.tagName.toUpperCase();
    return t === "SPAN" || t === "SVG";
  });
}
function uO(i, e) {
  const t = e.icon.data, r = e.customisations, s = j0(t, r);
  r.preserveAspectRatio && (s.attributes.preserveAspectRatio = r.preserveAspectRatio);
  const n = e.renderedMode;
  let o;
  switch (n) {
    case "svg":
      o = dC(s);
      break;
    default:
      o = hC(s, {
        ...no,
        ...t
      }, n === "mask");
  }
  const a = Ah(i);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : i.replaceChild(o, a) : i.appendChild(o);
}
function dO(i, e, t) {
  const r = t && (t.rendered ? t : t.lastRender);
  return {
    rendered: !1,
    inline: e,
    icon: i,
    lastRender: r
  };
}
function OC(i = "iconify-icon") {
  let e, t;
  try {
    e = window.customElements, t = window.HTMLElement;
  } catch {
    return;
  }
  if (!e || !t)
    return;
  const r = e.get(i);
  if (r)
    return r;
  const s = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "noobserver",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], n = class extends t {
    // Root
    _shadowRoot;
    // Initialised
    _initialised = !1;
    // Icon state
    _state;
    // Attributes check queued
    _checkQueued = !1;
    // Connected
    _connected = !1;
    // Observer
    _observer = null;
    _visible = !0;
    /**
     * Constructor
     */
    constructor() {
      super();
      const a = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), l = this.hasAttribute("inline");
      lO(a, l), this._state = dO({
        value: ""
      }, l), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = !0, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = !1, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return s.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(a) {
      switch (a) {
        case "inline": {
          const l = this.hasAttribute("inline"), c = this._state;
          l !== c.inline && (c.inline = l, lO(this._shadowRoot, l));
          break;
        }
        case "noobserver": {
          this.hasAttribute("noobserver") ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const a = this.getAttribute("icon");
      if (a && a.slice(0, 1) === "{")
        try {
          return JSON.parse(a);
        } catch {
        }
      return a;
    }
    set icon(a) {
      typeof a == "object" && (a = JSON.stringify(a)), this.setAttribute("icon", a);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return this.hasAttribute("inline");
    }
    set inline(a) {
      a ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(a) {
      a ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const a = this._state;
      if (a.rendered) {
        const l = this._shadowRoot;
        if (a.renderedMode === "svg")
          try {
            l.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        uO(l, a);
      }
    }
    /**
     * Get status
     */
    get status() {
      const a = this._state;
      return a.rendered ? "rendered" : a.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = !0, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = !1;
      const a = this._state, l = this.getAttribute("icon");
      if (l !== a.icon.value) {
        this._iconChanged(l);
        return;
      }
      if (!a.rendered || !this._visible)
        return;
      const c = this.getAttribute("mode"), h = Jd(this);
      (a.attrMode !== c || Sk(a.customisations, h) || !Ah(this._shadowRoot)) && this._renderIcon(a.icon, h, c);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(a) {
      const l = Wk(a, (c, h, f) => {
        const u = this._state;
        if (u.rendered || this.getAttribute("icon") !== c)
          return;
        const g = {
          value: c,
          name: h,
          data: f
        };
        g.data ? this._gotIconData(g) : u.icon = g;
      });
      l.data ? this._gotIconData(l) : this._state = dO(l, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const a = Ah(this._shadowRoot);
        a && this._shadowRoot.removeChild(a);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(a) {
      this._checkQueued = !1, this._renderIcon(a, Jd(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(a, l, c) {
      const h = zk(a.data.body, c), f = this._state.inline;
      uO(this._shadowRoot, this._state = {
        rendered: !0,
        icon: a,
        inline: f,
        customisations: l,
        attrMode: c,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer && !this.hasAttribute("noobserver"))
        try {
          this._observer = new IntersectionObserver((a) => {
            const l = a.some((c) => c.isIntersecting);
            l !== this._visible && (this._visible = l, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = !0, this._connected && this._forceRender());
    }
  };
  s.forEach((a) => {
    a in n.prototype || Object.defineProperty(n.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = F0();
  for (const a in o)
    n[a] = n.prototype[a] = o[a];
  return e.define(i, n), n;
}
const pC = OC() || F0(), { iconLoaded: pX, getIcon: gX, listIcons: mX, addIcon: vX, addCollection: SX, calculateSize: _X, buildIcon: bX, iconToHTML: yX, svgToURL: wX, loadIcons: xX, loadIcon: kX, setCustomIconLoader: CX, setCustomIconsLoader: QX, addAPIProvider: PX, _api: $X } = pC;
var gC = /* @__PURE__ */ Y("<iconify-icon>", !0, !1, !1);
function Ae(i) {
  let {
    icon: e,
    mode: t,
    inline: r,
    rotate: s,
    flip: n,
    width: o,
    height: a,
    preserveAspectRatio: l,
    noobserver: c
  } = i;
  return typeof e == "object" && (e = JSON.stringify(e)), // @ts-ignore
  (() => {
    var h = gC();
    return Ee(h, "icon", e), Ee(h, "mode", t), Ee(h, "inline", r), Ee(h, "rotate", s), Ee(h, "flip", n), Ee(h, "width", o), Ee(h, "height", a), Ee(h, "preserveaspectratio", l), Ee(h, "noobserver", c), bl(h, i, !1, !1), h._$owner = eo(), h;
  })();
}
var mC = /* @__PURE__ */ Y('<input class="border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-gray-900 text-black dark:text-white rounded px-1 text-sm flex-grow"autofocus>'), vC = /* @__PURE__ */ Y('<div class="pl-5 border-l border-gray-300 dark:border-gray-900 ml-1"> '), SC = /* @__PURE__ */ Y('<div class=relative><div class="cursor-pointer hover:bg-gray-900/50 px-1 rounded flex items-center gap-x-2">'), _C = /* @__PURE__ */ Y('<span class="truncate max-w-[220px]">');
const bC = (i, e, t) => {
  if (e)
    return t ? "vscode-icons:default-folder-opened" : "vscode-icons:default-folder";
  const r = i.split(".").pop()?.toLowerCase() || "";
  return {
    js: "vscode-icons:file-type-js",
    jsx: "tabler:file-type-jsx",
    ts: "vscode-icons:file-type-typescript",
    tsx: "tabler:file-type-tsx",
    json: "bi:filetype-json",
    html: "vscode-icons:file-type-html",
    css: "vscode-icons:file-type-css",
    md: "lineicons:markdown",
    py: "vscode-icons:file-type-python",
    java: "vscode-icons:file-type-java",
    cpp: "vscode-icons:file-type-cpp",
    cs: "vscode-icons:file-type-csharp",
    png: "bi:filetype-png",
    jpg: "bi:filetype-jpg",
    gif: "bi:filetype-gif",
    env: "vscode-icons:file-type-dotenv",
    sh: "bi:terminal",
    config: "vscode-icons:folder-type-config",
    // This is for folder type, might reconsider for specific files
    xml: "vscode-icons:file-type-xml",
    csv: "bi:filetype-csv",
    doc: "vscode-icons:file-type-doc",
    docx: "vscode-icons:file-type-docx",
    gitignore: "simple-icons:gitignoredotio"
    // Add more as needed
  }[r] || "vscode-icons:default-file";
}, G0 = (i) => {
  const [e, t] = ie(!1), [r, s] = ie(!1), [n, o] = ie(i.file.name), a = Qe(() => bC(i.file.name, i.file.isDirectory, e())), l = i.file.isDirectory, c = Qe(() => l && i.file.children && i.file.children.length > 0), h = () => {
    l && t(!e());
  }, f = () => {
    l ? h() : (console.log(i.file, "file handleClick"), i.onSelect(i.file.path));
  }, u = async () => {
    const S = n().trim();
    if (!S || S === i.file.name)
      return s(!1);
    try {
      await Si.post("/file/rename", {
        oldPath: i.file.path,
        // The new path will be the parent directory + newName
        newPath: `${i.file.path.substring(0, i.file.path.lastIndexOf("/") + 1)}${S}`
      }), i.onRefresh?.();
    } catch (v) {
      console.error("Rename failed:", v), o(i.file.name), alert(`Failed to rename: ${v.response?.data?.message || v.message}`);
    } finally {
      s(!1);
    }
  }, g = (S) => {
    S.key === "Enter" ? (S.preventDefault(), u()) : S.key === "Escape" && (o(i.file.name), s(!1));
  };
  return kt(() => {
    o(i.file.name);
  }), (() => {
    var S = SC(), v = S.firstChild;
    return v.$$dblclick = () => {
      !l && !r() && s(!0);
    }, v.$$contextmenu = (d) => i.onContextMenu(d, i.file), v.$$click = f, X(v, l && B(Ae, {
      get icon() {
        return e() ? "mdi:chevron-down" : "mdi:chevron-right";
      },
      class: "w-4 h-4 text-gray-500"
    }), null), X(v, B(Ae, {
      width: "20",
      height: "20",
      get icon() {
        return a();
      }
    }), null), X(v, B(pe, {
      get when() {
        return r();
      },
      get fallback() {
        return (() => {
          var d = _C();
          return X(d, () => i.file.name), d;
        })();
      },
      get children() {
        var d = mC();
        return d.$$click = (O) => O.stopPropagation(), d.$$keydown = g, d.addEventListener("blur", u), d.$$input = (O) => o(O.currentTarget.value), ce(() => d.value = n()), d;
      }
    }), null), X(S, B(pe, {
      get when() {
        return ct(() => !!e())() && c();
      },
      get children() {
        var d = vC();
        return d.firstChild, X(d, B(rt, {
          get each() {
            return i.file.children;
          },
          children: (O) => B(G0, {
            file: O,
            get onSelect() {
              return i.onSelect;
            },
            get onContextMenu() {
              return i.onContextMenu;
            },
            get onRefresh() {
              return i.onRefresh;
            }
          })
        }), null), d;
      }
    }), null), S;
  })();
};
He(["click", "contextmenu", "dblclick", "input", "keydown"]);
var yC = /* @__PURE__ */ Y('<svg xmlns=http://www.w3.org/2000/svg fill=none viewBox="0 0 24 24"><circle class=opacity-25 cx=12 cy=12 r=10 stroke=currentColor stroke-width=4></circle><path class=opacity-75 fill=currentColor d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">'), wC = /* @__PURE__ */ Y('<div class="flex space-x-2"><div></div><div></div><div>'), xC = /* @__PURE__ */ Y('<div class="w-48 h-2 bg-gray-200 rounded-full overflow-hidden"><div class="h-full bg-sky-500 animate-loading-bar">'), kC = /* @__PURE__ */ Y('<span class="text-sm text-gray-200 dark:text-gray-300">'), CC = /* @__PURE__ */ Y('<div><div class="flex flex-col items-center space-y-2 p-4 relative"><div class="top-0 bottom-o right-0 left-0 w-full h-full">');
const QC = {
  small: "h-4 w-4",
  medium: "h-8 w-8",
  large: "h-12 w-12"
}, PC = {
  top: "items-start justify-center",
  bottom: "items-end justify-center",
  left: "items-center justify-start",
  right: "items-center justify-end",
  center: "items-center justify-center"
};
function ao({
  position: i = "center",
  size: e = "large",
  type: t = "spinner",
  text: r,
  backdrop: s = !1
}) {
  const n = QC[e], o = PC[i];
  return (() => {
    var a = CC(), l = a.firstChild, c = l.firstChild;
    return Fe(a, `w-full h-full  flex ${o} ${s ? " inset-0 bg-black/50 z-50" : ""}`), X(c, B(pe, {
      when: t === "spinner",
      get children() {
        var h = yC();
        return Ee(h, "class", `animate-spin text-sky-500 ${n}`), h;
      }
    }), null), X(c, B(pe, {
      when: t === "dots",
      get children() {
        var h = wC(), f = h.firstChild, u = f.nextSibling, g = u.nextSibling;
        return Fe(f, `bg-sky-500 rounded-full ${n} animate-bounce`), Fe(u, `bg-sky-500 rounded-full ${n} animate-bounce delay-150`), Fe(g, `bg-sky-500 rounded-full ${n} animate-bounce delay-300`), h;
      }
    }), null), X(c, B(pe, {
      when: t === "bar",
      get children() {
        return xC();
      }
    }), null), X(c, B(pe, {
      when: r,
      get children() {
        var h = kC();
        return X(h, r), h;
      }
    }), null), a;
  })();
}
var cc, OO;
function $C() {
  if (OO) return cc;
  OO = 1;
  function i(s) {
    if (typeof s != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(s));
  }
  function e(s, n) {
    for (var o = "", a = 0, l = -1, c = 0, h, f = 0; f <= s.length; ++f) {
      if (f < s.length)
        h = s.charCodeAt(f);
      else {
        if (h === 47)
          break;
        h = 47;
      }
      if (h === 47) {
        if (!(l === f - 1 || c === 1)) if (l !== f - 1 && c === 2) {
          if (o.length < 2 || a !== 2 || o.charCodeAt(o.length - 1) !== 46 || o.charCodeAt(o.length - 2) !== 46) {
            if (o.length > 2) {
              var u = o.lastIndexOf("/");
              if (u !== o.length - 1) {
                u === -1 ? (o = "", a = 0) : (o = o.slice(0, u), a = o.length - 1 - o.lastIndexOf("/")), l = f, c = 0;
                continue;
              }
            } else if (o.length === 2 || o.length === 1) {
              o = "", a = 0, l = f, c = 0;
              continue;
            }
          }
          n && (o.length > 0 ? o += "/.." : o = "..", a = 2);
        } else
          o.length > 0 ? o += "/" + s.slice(l + 1, f) : o = s.slice(l + 1, f), a = f - l - 1;
        l = f, c = 0;
      } else h === 46 && c !== -1 ? ++c : c = -1;
    }
    return o;
  }
  function t(s, n) {
    var o = n.dir || n.root, a = n.base || (n.name || "") + (n.ext || "");
    return o ? o === n.root ? o + a : o + s + a : a;
  }
  var r = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var n = "", o = !1, a, l = arguments.length - 1; l >= -1 && !o; l--) {
        var c;
        l >= 0 ? c = arguments[l] : (a === void 0 && (a = process.cwd()), c = a), i(c), c.length !== 0 && (n = c + "/" + n, o = c.charCodeAt(0) === 47);
      }
      return n = e(n, !o), o ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
    },
    normalize: function(n) {
      if (i(n), n.length === 0) return ".";
      var o = n.charCodeAt(0) === 47, a = n.charCodeAt(n.length - 1) === 47;
      return n = e(n, !o), n.length === 0 && !o && (n = "."), n.length > 0 && a && (n += "/"), o ? "/" + n : n;
    },
    isAbsolute: function(n) {
      return i(n), n.length > 0 && n.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var n, o = 0; o < arguments.length; ++o) {
        var a = arguments[o];
        i(a), a.length > 0 && (n === void 0 ? n = a : n += "/" + a);
      }
      return n === void 0 ? "." : r.normalize(n);
    },
    relative: function(n, o) {
      if (i(n), i(o), n === o || (n = r.resolve(n), o = r.resolve(o), n === o)) return "";
      for (var a = 1; a < n.length && n.charCodeAt(a) === 47; ++a)
        ;
      for (var l = n.length, c = l - a, h = 1; h < o.length && o.charCodeAt(h) === 47; ++h)
        ;
      for (var f = o.length, u = f - h, g = c < u ? c : u, S = -1, v = 0; v <= g; ++v) {
        if (v === g) {
          if (u > g) {
            if (o.charCodeAt(h + v) === 47)
              return o.slice(h + v + 1);
            if (v === 0)
              return o.slice(h + v);
          } else c > g && (n.charCodeAt(a + v) === 47 ? S = v : v === 0 && (S = 0));
          break;
        }
        var d = n.charCodeAt(a + v), O = o.charCodeAt(h + v);
        if (d !== O)
          break;
        d === 47 && (S = v);
      }
      var p = "";
      for (v = a + S + 1; v <= l; ++v)
        (v === l || n.charCodeAt(v) === 47) && (p.length === 0 ? p += ".." : p += "/..");
      return p.length > 0 ? p + o.slice(h + S) : (h += S, o.charCodeAt(h) === 47 && ++h, o.slice(h));
    },
    _makeLong: function(n) {
      return n;
    },
    dirname: function(n) {
      if (i(n), n.length === 0) return ".";
      for (var o = n.charCodeAt(0), a = o === 47, l = -1, c = !0, h = n.length - 1; h >= 1; --h)
        if (o = n.charCodeAt(h), o === 47) {
          if (!c) {
            l = h;
            break;
          }
        } else
          c = !1;
      return l === -1 ? a ? "/" : "." : a && l === 1 ? "//" : n.slice(0, l);
    },
    basename: function(n, o) {
      if (o !== void 0 && typeof o != "string") throw new TypeError('"ext" argument must be a string');
      i(n);
      var a = 0, l = -1, c = !0, h;
      if (o !== void 0 && o.length > 0 && o.length <= n.length) {
        if (o.length === n.length && o === n) return "";
        var f = o.length - 1, u = -1;
        for (h = n.length - 1; h >= 0; --h) {
          var g = n.charCodeAt(h);
          if (g === 47) {
            if (!c) {
              a = h + 1;
              break;
            }
          } else
            u === -1 && (c = !1, u = h + 1), f >= 0 && (g === o.charCodeAt(f) ? --f === -1 && (l = h) : (f = -1, l = u));
        }
        return a === l ? l = u : l === -1 && (l = n.length), n.slice(a, l);
      } else {
        for (h = n.length - 1; h >= 0; --h)
          if (n.charCodeAt(h) === 47) {
            if (!c) {
              a = h + 1;
              break;
            }
          } else l === -1 && (c = !1, l = h + 1);
        return l === -1 ? "" : n.slice(a, l);
      }
    },
    extname: function(n) {
      i(n);
      for (var o = -1, a = 0, l = -1, c = !0, h = 0, f = n.length - 1; f >= 0; --f) {
        var u = n.charCodeAt(f);
        if (u === 47) {
          if (!c) {
            a = f + 1;
            break;
          }
          continue;
        }
        l === -1 && (c = !1, l = f + 1), u === 46 ? o === -1 ? o = f : h !== 1 && (h = 1) : o !== -1 && (h = -1);
      }
      return o === -1 || l === -1 || // We saw a non-dot character immediately before the dot
      h === 0 || // The (right-most) trimmed path component is exactly '..'
      h === 1 && o === l - 1 && o === a + 1 ? "" : n.slice(o, l);
    },
    format: function(n) {
      if (n === null || typeof n != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof n);
      return t("/", n);
    },
    parse: function(n) {
      i(n);
      var o = { root: "", dir: "", base: "", ext: "", name: "" };
      if (n.length === 0) return o;
      var a = n.charCodeAt(0), l = a === 47, c;
      l ? (o.root = "/", c = 1) : c = 0;
      for (var h = -1, f = 0, u = -1, g = !0, S = n.length - 1, v = 0; S >= c; --S) {
        if (a = n.charCodeAt(S), a === 47) {
          if (!g) {
            f = S + 1;
            break;
          }
          continue;
        }
        u === -1 && (g = !1, u = S + 1), a === 46 ? h === -1 ? h = S : v !== 1 && (v = 1) : h !== -1 && (v = -1);
      }
      return h === -1 || u === -1 || // We saw a non-dot character immediately before the dot
      v === 0 || // The (right-most) trimmed path component is exactly '..'
      v === 1 && h === u - 1 && h === f + 1 ? u !== -1 && (f === 0 && l ? o.base = o.name = n.slice(1, u) : o.base = o.name = n.slice(f, u)) : (f === 0 && l ? (o.name = n.slice(1, h), o.base = n.slice(1, u)) : (o.name = n.slice(f, h), o.base = n.slice(f, u)), o.ext = n.slice(h, u)), f > 0 ? o.dir = n.slice(0, f - 1) : l && (o.dir = "/"), o;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return r.posix = r, cc = r, cc;
}
var pO = $C(), TC = /* @__PURE__ */ Y('<li class="text-sm text-green-600 hover:underline cursor-pointer p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700">➕ New File'), RC = /* @__PURE__ */ Y('<li class="text-sm text-green-600 hover:underline cursor-pointer p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700">📁 New Folder'), EC = /* @__PURE__ */ Y('<div id=context-menu class="fixed min-w-[160px] border shadow-md rounded p-2 z-50 bg-white dark:bg-gray-800"><div class="text-sm font-semibold truncate"></div><div class="text-xs mb-2 text-gray-500"></div><ul class=space-y-1><li class="text-sm text-yellow-500 hover:underline cursor-pointer p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700">Open</li><li class="text-sm text-red-500 hover:underline cursor-pointer p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700">❌ Delete'), AC = /* @__PURE__ */ Y('<div class="relative w-full h-full flex flex-col"><div class="flex items-center p-2 border-b bg-gray-100 dark:bg-gray-700"><button title="Go Up"></button><span class="mx-2 text-sm font-medium">Path: </span><button class="p-2 rounded hover:bg-gray-200 dark:hover:bg-gray-600 ml-auto"title=Refresh></button><button class="p-2 rounded hover:bg-gray-200 dark:hover:bg-gray-600 ml-2"title="New File"></button><button class="p-2 rounded hover:bg-gray-200 dark:hover:bg-gray-600 ml-2"title="New Folder"></button></div><div class="flex-grow overflow-auto p-4">'), LC = /* @__PURE__ */ Y('<div class="h-full flex items-center justify-center">'), MC = /* @__PURE__ */ Y('<p class="text-center text-gray-500">No files or folders in this directory.');
function DC(i) {
  const [e, t] = ie([]), [r, s] = ie("/"), [n, o] = ie(!0), [a, l] = ie({
    x: 0,
    y: 0,
    file: null,
    visible: !1
  }), c = Qe(() => e()), h = async (O) => {
    o(!0);
    try {
      const p = O !== void 0 ? O : "/", m = p && p !== "/" ? `?directory=${encodeURIComponent(p)}&` : "?";
      console.log(m, "query fetchFiles");
      const _ = await Si.get(`/file/list${m}recursive=true`);
      if (console.log(_, "response fetchFiles"), !_.data || !Array.isArray(_.data))
        throw new Error("Invalid data format received from API. Expected an array of FileItem.");
      t(_.data), s(p);
    } catch (p) {
      console.error("Failed to fetch files:", p), alert(`Failed to fetch files: ${p.response?.data?.message || p.message}`);
    } finally {
      o(!1);
    }
  };
  i.refreshList?.((O) => h(O || r()));
  const f = (O, p) => {
    p ? h(O) : i.onFileSelect?.(O);
  }, u = (O, p) => {
    O.preventDefault(), l({
      x: O.clientX,
      y: O.clientY,
      file: p,
      visible: !0
    });
  }, g = () => l((O) => ({
    ...O,
    visible: !1
  })), S = (O) => {
    const p = document.getElementById("context-menu");
    p && !p.contains(O.target) && g();
  }, v = async (O, p) => {
    const m = a().file;
    if (!m) return;
    if (g(), O === "open") {
      m.isDirectory ? h(m.path) : i.onFileSelect?.(m.path);
      return;
    }
    let _ = "", b = {};
    if (O === "create") {
      const w = prompt(`Enter name for new ${p === "folder" ? "folder" : "file"}:`)?.trim();
      if (!w) {
        alert("Name cannot be empty.");
        return;
      }
      const x = pO.join(m.path, w);
      _ = "/file/create", b = {
        filePath: x,
        isDirectory: p === "folder",
        content: p === "file" ? "" : void 0
      };
    } else if (O === "delete") {
      if (!confirm(`Are you sure you want to delete "${m.name}"? This action cannot be undone.`))
        return;
      _ = "/file/delete", b = {
        filePath: m.path
      };
    }
    if (_)
      try {
        await Si.post(_, b), h(r());
      } catch (w) {
        console.error(`Error performing ${O} action:`, w), alert(`Error: ${w.response?.data?.message || w.message}`);
      }
  };
  kt(() => {
    h(r()), document.addEventListener("click", S);
  }), ft(() => {
    document.removeEventListener("click", S);
  });
  const d = () => {
    const O = pO.dirname(r());
    O !== r() && h(O);
  };
  return (() => {
    var O = AC(), p = O.firstChild, m = p.firstChild, _ = m.nextSibling;
    _.firstChild;
    var b = _.nextSibling, w = b.nextSibling, x = w.nextSibling, y = p.nextSibling;
    return cu(m, "click", r() !== "/" ? d : void 0, !0), X(m, B(Ae, {
      icon: "mdi:arrow-up-bold",
      class: "w-5 h-5"
    })), X(_, (() => {
      var k = ct(() => r() === "/");
      return () => k() ? "/" : `${r()}`;
    })(), null), b.$$click = () => h(r()), X(b, B(Ae, {
      icon: "mdi:refresh",
      class: "w-5 h-5"
    })), w.$$click = () => v("create", "file"), X(w, B(Ae, {
      icon: "mdi:file-plus",
      class: "w-5 h-5"
    })), x.$$click = () => v("create", "folder"), X(x, B(Ae, {
      icon: "mdi:folder-plus",
      class: "w-5 h-5"
    })), X(y, B(pe, {
      get when() {
        return !n();
      },
      get fallback() {
        return (() => {
          var k = LC();
          return X(k, B(ao, {})), k;
        })();
      },
      get children() {
        return B(rt, {
          get each() {
            return c();
          },
          get fallback() {
            return MC();
          },
          children: (k) => (
            // This is the single child function for <For>
            B(G0, {
              file: k,
              onSelect: (T) => f(T, k.isDirectory),
              onContextMenu: u,
              onRefresh: (T) => h(T || r())
            })
          )
        });
      }
    })), X(O, B(pe, {
      get when() {
        return ct(() => !!a().visible)() && a().file;
      },
      get children() {
        var k = EC(), T = k.firstChild, R = T.nextSibling, $ = R.nextSibling, E = $.firstChild, D = E.nextSibling;
        return X(T, () => a().file.name), X(R, () => a().file.type === "folder" ? "📁 Folder" : "📄 File"), E.$$click = () => v("open"), X($, B(pe, {
          get when() {
            return a().file.type === "folder";
          },
          get children() {
            return [(() => {
              var q = TC();
              return q.$$click = () => v("create", "file"), q;
            })(), (() => {
              var q = RC();
              return q.$$click = () => v("create", "folder"), q;
            })()];
          }
        }), D), D.$$click = () => v("delete"), ce((q) => {
          var W = `${a().y}px`, z = `${a().x}px`;
          return W !== q.e && ((q.e = W) != null ? k.style.setProperty("top", W) : k.style.removeProperty("top")), z !== q.t && ((q.t = z) != null ? k.style.setProperty("left", z) : k.style.removeProperty("left")), q;
        }, {
          e: void 0,
          t: void 0
        }), k;
      }
    }), null), ce((k) => {
      var T = r() === "/", R = `p-2 rounded ${r() === "/" ? "text-gray-400 cursor-not-allowed" : "hover:bg-gray-200 dark:hover:bg-gray-600"}`;
      return T !== k.e && (m.disabled = k.e = T), R !== k.t && Fe(m, k.t = R), k;
    }, {
      e: void 0,
      t: void 0
    }), O;
  })();
}
He(["click"]);
var qC = /* @__PURE__ */ Y("<aside>");
const BC = () => {
  const [i, e] = ie(!0);
  return (() => {
    var t = qC();
    return ce(() => Fe(t, `transition-all duration-300 ${i() ? "w-80" : "w-0"} flex flex-shrink-0 py-4 flex flex-col justify-between items-center border-r dark:border-gray-800/50`)), t;
  })();
};
var XC = /* @__PURE__ */ Y('<aside><button class="text-lg font-medium mx-4 hover:text-gray-400">');
const IC = () => {
  const [i, e] = ie(!1);
  return (() => {
    var t = XC(), r = t.firstChild;
    return r.$$click = () => e(!i()), ce(() => Fe(t, `transition-all duration-300 ${i() ? "w-52" : "w-0"} flex-shrink-0 bg-gray-100 dark:bg-gray-900 text-white dark:text-gray-100 py-4 flex flex-col justify-between items-center`)), t;
  })();
};
He(["click"]);
var ZC = /* @__PURE__ */ Y("<div>");
function WC({
  content: i,
  classNames: e = ""
}) {
  return (() => {
    var t = ZC();
    return Fe(t, `flex-grow overflow-auto ${e}`), X(t, i), t;
  })();
}
var zC = /* @__PURE__ */ Y('<header class="mb-4 pb-2"><h1 class="text-2xl font-semibold">'), VC = /* @__PURE__ */ Y('<p class="text-sm text-gray-600">');
const UC = ({
  title: i,
  subTitle: e
}) => (() => {
  var t = zC(), r = t.firstChild;
  return X(r, i), X(t, e && (() => {
    var s = VC();
    return X(s, e), s;
  })(), null), t;
})();
var jC = /* @__PURE__ */ Y("<div>");
function NC({
  content: i,
  header: e,
  classNames: t = ""
}) {
  return (() => {
    var r = jC();
    return Fe(r, `flex flex-1 ${t}`), X(r, () => e && (typeof e == "object" && "title" in e ? B(UC, {
      get title() {
        return e.title;
      },
      get subTitle() {
        return e.subTitle;
      }
    }) : e), null), X(r, B(WC, {
      content: i
    }), null), r;
  })();
}
var YC = /* @__PURE__ */ Y('<div class="flex flex-col h-[calc(100vh)] overflow-hidden"><div class="flex flex-1 overflow-auto">');
function FC({
  title: i,
  menus: e,
  content: t,
  leftSidebar: r = !1,
  rightSidebar: s = !1,
  footer: n = !0
}) {
  return (() => {
    var o = YC(), a = o.firstChild;
    return X(o, B(fk, {}), a), X(a, B(pe, {
      when: r,
      get children() {
        return B(BC, {});
      }
    }), null), X(a, B(NC, {
      content: t
    }), null), X(a, B(pe, {
      when: s,
      get children() {
        return B(IC, {});
      }
    }), null), X(o, B(pe, {
      when: n,
      get children() {
        return B(Ok, {
          links: e
        });
      }
    }), null), o;
  })();
}
function HC(i) {
  const e = xn.subscribe((t) => {
    const r = document.documentElement, s = document.body;
    r.style.transition = "background-color 0.3s ease, color 0.3s ease", s.style.transition = "background-color 0.3s ease, color 0.3s ease", r.classList.remove("light", "dark"), s.classList.remove("light", "dark"), r.classList.add(t), s.classList.add(t);
  });
  return ft(() => {
    e(), document.documentElement.style.transition = "", document.body.style.transition = "";
  }), i.children;
}
function qs(i) {
  const {
    isAuthenticated: e
  } = wi(), t = hr();
  return Tr(() => {
    e() || t("/login", {
      replace: !0
    });
  }), B(pe, {
    get when() {
      return e();
    },
    get children() {
      return i.children;
    }
  });
}
const [GC, gO] = ie([]);
let KC = 0;
function hc(i, e = "info", t = 3e3) {
  const r = ++KC;
  gO((s) => [...s, { id: r, message: i, type: e }]), setTimeout(() => {
    gO((s) => s.filter((n) => n.id !== r));
  }, t);
}
var JC = /* @__PURE__ */ Y('<div class="fixed top-10 right-10 space-y-2 z-50">'), eQ = /* @__PURE__ */ Y("<div>");
function tQ() {
  return (() => {
    var i = JC();
    return X(i, B(rt, {
      get each() {
        return GC();
      },
      children: (e) => (() => {
        var t = eQ();
        return X(t, () => e.message), ce(() => Fe(t, `px-4 py-3 rounded shadow text-white animate-fade-in-out
              ${e.type === "success" && "bg-green-600"}
              ${e.type === "error" && "bg-red-600"}
              ${e.type === "info" && "bg-blue-600"}`)), t;
      })()
    })), i;
  })();
}
var iQ = /* @__PURE__ */ Y("<div class=space-y-3>"), rQ = /* @__PURE__ */ Y('<div class="flex flex-col"><label class=font-medium></label><input class="border px-3 py-2 rounded-md">'), sQ = /* @__PURE__ */ Y('<div class="pl-2 border-l">'), nQ = /* @__PURE__ */ Y('<div class="pl-4 mt-2 border-l border-gray-300">'), oQ = /* @__PURE__ */ Y('<div class=mt-2><button type=button class="text-sm font-semibold text-blue-700 hover:underline"> '), aQ = /* @__PURE__ */ Y('<div class="p-6 max-w-3xl mx-auto"><h1 class="text-2xl font-bold mb-4">Edit package.json'), lQ = /* @__PURE__ */ Y("<p>Loading..."), cQ = /* @__PURE__ */ Y('<form class=space-y-4><button type=submit class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Save');
function K0(i) {
  return console.log(Object.entries(i), i), (() => {
    var e = iQ();
    return X(e, B(rt, {
      get each() {
        return Object.entries(i.data);
      },
      children: ([t, r]) => {
        const s = [...i.path, t], [n, o] = ie(!0), a = typeof r == "string" || typeof r == "number" || typeof r == "boolean";
        return console.log(s, r), (() => {
          var l = sQ();
          return X(l, B(pe, {
            when: a,
            get fallback() {
              return (() => {
                var c = oQ(), h = c.firstChild, f = h.firstChild;
                return h.$$click = () => o(!n()), X(h, () => n() ? "▶" : "▼", f), X(h, t, null), X(c, B(pe, {
                  get when() {
                    return !n();
                  },
                  get children() {
                    var u = nQ();
                    return X(u, B(K0, {
                      data: r,
                      path: s,
                      get onChange() {
                        return i.onChange;
                      }
                    })), u;
                  }
                }), null), c;
              })();
            },
            get children() {
              var c = rQ(), h = c.firstChild, f = h.nextSibling;
              return X(h, t), f.$$input = (u) => i.onChange(s, u.currentTarget.value), ce(() => f.value = String(r)), c;
            }
          })), l;
        })();
      }
    })), e;
  })();
}
async function hQ() {
  const i = await fetch("/package.json");
  if (!i.ok) throw new Error("Failed to load package.json");
  return i.json();
}
function fQ() {
  const [i] = qm(hQ), [e, t] = uu({}), r = (n, o) => {
    t(ew((a) => {
      let l = a;
      for (let f = 0; f < n.length - 1; f++) {
        const u = n[f];
        u in l || (l[u] = {}), l = l[u];
      }
      const c = n[n.length - 1], h = l[c];
      if (typeof h == "number") {
        const f = Number(o);
        isNaN(f) || (l[c] = f);
      } else typeof h == "boolean" ? l[c] = o === "true" : l[c] = o;
    }));
  }, s = (n) => {
    n.preventDefault(), console.log("Updated package.json:", e);
  };
  return (() => {
    var n = aQ();
    return n.firstChild, X(n, B(pe, {
      get when() {
        return i();
      },
      get fallback() {
        return lQ();
      },
      children: (o) => (Object.keys(e).length === 0 && t({
        ...o
      }), (() => {
        var a = cQ(), l = a.firstChild;
        return a.addEventListener("submit", s), X(a, B(K0, {
          data: e,
          path: [],
          onChange: r
        }), l), a;
      })())
    }), null), n;
  })();
}
He(["input", "click"]);
function uQ() {
  return B(fQ, {});
}
var dQ = /* @__PURE__ */ Y('<button class="w-full flex items-center gap-2 justify-center p-3 text-white bg-neutral-900 rounded-md hover:bg-neutral-800 mt-4"> Sign in with Google');
const OQ = "http://localhost:5000/api/auth/google/callback";
function pQ() {
  const [i, e] = ie("");
  return kt(() => {
    e(`${OQ}`);
  }), (() => {
    var t = dQ(), r = t.firstChild;
    return t.$$click = () => i() && (window.location.href = i()), X(t, B(Ae, {
      icon: "flat-color-icons:google",
      width: "20",
      height: "20"
    }), r), t;
  })();
}
He(["click"]);
var gQ = /* @__PURE__ */ Y('<button class="w-full flex gap-2 items-center justify-center p-3 text-white bg-gray-700 rounded-md hover:bg-gray-600 mt-4"> Sign in with Github');
const mQ = "https://board-api.duckdns.org/api/auth/github/callback";
function vQ() {
  const [i, e] = ie("");
  return kt(() => {
    e(`${mQ}`);
  }), (() => {
    var t = gQ(), r = t.firstChild;
    return t.$$click = () => i() && (window.location.href = i()), X(t, B(Ae, {
      icon: "mdi:github",
      width: "24",
      class: "text-gray-900",
      height: "24"
    }), r), t;
  })();
}
He(["click"]);
var SQ = /* @__PURE__ */ Y('<div class=py-16><div class="flex items-center justify-center"><div class="w-full max-w-md rounded-lg p-8 border shadow-lg"><h2 class="text-center text-2xl font-bold">Welcome Back 👋</h2><form class="space-y-4 mt-4"><div><label class=block>Email</label><input type=email placeholder="Enter email"class="mt-1 w-full rounded-md border p-3 focus:ring-2 focus:ring-blue-500"required></div><div><label class=block>Password</label><input type=password placeholder=•••••••• class="mt-1 w-full rounded-md border p-3 focus:ring-2 focus:ring-blue-500"required></div><button type=submit class="w-full rounded-md bg-sky-500 p-3 hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400">Sign In'), _Q = /* @__PURE__ */ Y('<p class="text-center text-sm text-red-400">');
const bQ = () => {
  const {
    login: i
  } = wi(), e = hr(), [t, r] = ie(""), [s, n] = ie(""), [o, a] = ie(null), [l, c] = ie(!1), h = async (f) => {
    f.preventDefault(), a(null), c(!0);
    try {
      await i({
        email: t(),
        password: s()
      }), e("/dashboard");
    } catch (u) {
      a(u.message || "Login failed");
    } finally {
      c(!1);
    }
  };
  return B(pe, {
    get when() {
      return !l();
    },
    get fallback() {
      return B(ao, {});
    },
    get children() {
      var f = SQ(), u = f.firstChild, g = u.firstChild, S = g.firstChild, v = S.nextSibling, d = v.firstChild, O = d.firstChild, p = O.nextSibling, m = d.nextSibling, _ = m.firstChild, b = _.nextSibling;
      return X(g, (() => {
        var w = ct(() => !!o());
        return () => w() && (() => {
          var x = _Q();
          return X(x, o), x;
        })();
      })(), v), v.addEventListener("submit", h), p.$$input = (w) => r(w.currentTarget.value), b.$$input = (w) => n(w.currentTarget.value), X(g, B(pQ, {}), null), X(g, B(vQ, {}), null), ce(() => p.value = t()), ce(() => b.value = s()), f;
    }
  });
};
He(["input"]);
function yQ() {
  const {
    isAuthenticated: i
  } = wi(), e = hr();
  return kt(() => {
    i() && e("/dashboard", {
      replace: !0
    });
  }), B(pe, {
    get when() {
      return !i();
    },
    get fallback() {
      return B(ao, {});
    },
    get children() {
      return B(bQ, {});
    }
  });
}
let Lh = [], J0 = [];
(() => {
  let i = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < i.length; e++)
    (e % 2 ? J0 : Lh).push(t = t + i[e]);
})();
function wQ(i) {
  if (i < 768) return !1;
  for (let e = 0, t = Lh.length; ; ) {
    let r = e + t >> 1;
    if (i < Lh[r]) t = r;
    else if (i >= J0[r]) e = r + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function mO(i) {
  return i >= 127462 && i <= 127487;
}
const vO = 8205;
function xQ(i, e, t = !0, r = !0) {
  return (t ? ev : kQ)(i, e, r);
}
function ev(i, e, t) {
  if (e == i.length) return e;
  e && tv(i.charCodeAt(e)) && iv(i.charCodeAt(e - 1)) && e--;
  let r = fc(i, e);
  for (e += SO(r); e < i.length; ) {
    let s = fc(i, e);
    if (r == vO || s == vO || t && wQ(s))
      e += SO(s), r = s;
    else if (mO(s)) {
      let n = 0, o = e - 2;
      for (; o >= 0 && mO(fc(i, o)); )
        n++, o -= 2;
      if (n % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function kQ(i, e, t) {
  for (; e > 0; ) {
    let r = ev(i, e - 2, t);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function fc(i, e) {
  let t = i.charCodeAt(e);
  if (!iv(t) || e + 1 == i.length) return t;
  let r = i.charCodeAt(e + 1);
  return tv(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function tv(i) {
  return i >= 56320 && i < 57344;
}
function iv(i) {
  return i >= 55296 && i < 56320;
}
function SO(i) {
  return i < 65536 ? 1 : 2;
}
class be {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = fs(this, e, t);
    let s = [];
    return this.decompose(
      0,
      e,
      s,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      s,
      1
      /* Open.From */
    ), ci.from(s, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = fs(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), ci.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), s = new nn(this), n = new nn(e);
    for (let o = t, a = t; ; ) {
      if (s.next(o), n.next(o), o = 0, s.lineBreak != n.lineBreak || s.done != n.done || s.value != n.value)
        return !1;
      if (a += s.value.length, s.done || a >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new nn(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new rv(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let s = this.line(e).from;
      r = this.iterRange(s, Math.max(s, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new sv(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? be.empty : e.length <= 32 ? new Ie(e) : ci.from(Ie.split(e, []));
  }
}
class Ie extends be {
  constructor(e, t = CQ(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, s) {
    for (let n = 0; ; n++) {
      let o = this.text[n], a = s + o.length;
      if ((t ? r : a) >= e)
        return new QQ(s, a, r, o);
      s = a + 1, r++;
    }
  }
  decompose(e, t, r, s) {
    let n = e <= 0 && t >= this.length ? this : new Ie(_O(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (s & 1) {
      let o = r.pop(), a = la(n.text, o.text.slice(), 0, n.length);
      if (a.length <= 32)
        r.push(new Ie(a, o.length + n.length));
      else {
        let l = a.length >> 1;
        r.push(new Ie(a.slice(0, l)), new Ie(a.slice(l)));
      }
    } else
      r.push(n);
  }
  replace(e, t, r) {
    if (!(r instanceof Ie))
      return super.replace(e, t, r);
    [e, t] = fs(this, e, t);
    let s = la(this.text, la(r.text, _O(this.text, 0, e)), t), n = this.length + r.length - (t - e);
    return s.length <= 32 ? new Ie(s, n) : ci.from(Ie.split(s, []), n);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = fs(this, e, t);
    let s = "";
    for (let n = 0, o = 0; n <= t && o < this.text.length; o++) {
      let a = this.text[o], l = n + a.length;
      n > e && o && (s += r), e < l && t > n && (s += a.slice(Math.max(0, e - n), t - n)), n = l + 1;
    }
    return s;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], s = -1;
    for (let n of e)
      r.push(n), s += n.length + 1, r.length == 32 && (t.push(new Ie(r, s)), r = [], s = -1);
    return s > -1 && t.push(new Ie(r, s)), t;
  }
}
class ci extends be {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, s) {
    for (let n = 0; ; n++) {
      let o = this.children[n], a = s + o.length, l = r + o.lines - 1;
      if ((t ? l : a) >= e)
        return o.lineInner(e, t, r, s);
      s = a + 1, r = l + 1;
    }
  }
  decompose(e, t, r, s) {
    for (let n = 0, o = 0; o <= t && n < this.children.length; n++) {
      let a = this.children[n], l = o + a.length;
      if (e <= l && t >= o) {
        let c = s & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0));
        o >= e && l <= t && !c ? r.push(a) : a.decompose(e - o, t - o, r, c);
      }
      o = l + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = fs(this, e, t), r.lines < this.lines)
      for (let s = 0, n = 0; s < this.children.length; s++) {
        let o = this.children[s], a = n + o.length;
        if (e >= n && t <= a) {
          let l = o.replace(e - n, t - n, r), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let h = this.children.slice();
            return h[s] = l, new ci(h, this.length - (t - e) + r.length);
          }
          return super.replace(n, a, l);
        }
        n = a + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = fs(this, e, t);
    let s = "";
    for (let n = 0, o = 0; n < this.children.length && o <= t; n++) {
      let a = this.children[n], l = o + a.length;
      o > e && n && (s += r), e < l && t > o && (s += a.sliceString(e - o, t - o, r)), o = l + 1;
    }
    return s;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof ci))
      return 0;
    let r = 0, [s, n, o, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; s += t, n += t) {
      if (s == o || n == a)
        return r;
      let l = this.children[s], c = e.children[n];
      if (l != c)
        return r + l.scanIdentical(c, t);
      r += l.length + 1;
    }
  }
  static from(e, t = e.reduce((r, s) => r + s.length + 1, -1)) {
    let r = 0;
    for (let g of e)
      r += g.lines;
    if (r < 32) {
      let g = [];
      for (let S of e)
        S.flatten(g);
      return new Ie(g, t);
    }
    let s = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), n = s << 1, o = s >> 1, a = [], l = 0, c = -1, h = [];
    function f(g) {
      let S;
      if (g.lines > n && g instanceof ci)
        for (let v of g.children)
          f(v);
      else g.lines > o && (l > o || !l) ? (u(), a.push(g)) : g instanceof Ie && l && (S = h[h.length - 1]) instanceof Ie && g.lines + S.lines <= 32 ? (l += g.lines, c += g.length + 1, h[h.length - 1] = new Ie(S.text.concat(g.text), S.length + 1 + g.length)) : (l + g.lines > s && u(), l += g.lines, c += g.length + 1, h.push(g));
    }
    function u() {
      l != 0 && (a.push(h.length == 1 ? h[0] : ci.from(h, c)), c = -1, l = h.length = 0);
    }
    for (let g of e)
      f(g);
    return u(), a.length == 1 ? a[0] : new ci(a, t);
  }
}
be.empty = /* @__PURE__ */ new Ie([""], 0);
function CQ(i) {
  let e = -1;
  for (let t of i)
    e += t.length + 1;
  return e;
}
function la(i, e, t = 0, r = 1e9) {
  for (let s = 0, n = 0, o = !0; n < i.length && s <= r; n++) {
    let a = i[n], l = s + a.length;
    l >= t && (l > r && (a = a.slice(0, r - s)), s < t && (a = a.slice(t - s)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), s = l + 1;
  }
  return e;
}
function _O(i, e, t) {
  return la(i, [""], e, t);
}
class nn {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof Ie ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, s = this.nodes[r], n = this.offsets[r], o = n >> 1, a = s instanceof Ie ? s.text.length : s.children.length;
      if (o == (t > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((n & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (s instanceof Ie) {
        let l = s.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = s.children[o + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof Ie ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class rv {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new nn(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: s } = this.cursor.next(e);
    return this.pos += (s.length + e) * t, this.value = s.length <= r ? s : t < 0 ? s.slice(s.length - r) : s.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class sv {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: s } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (be.prototype[Symbol.iterator] = function() {
  return this.iter();
}, nn.prototype[Symbol.iterator] = rv.prototype[Symbol.iterator] = sv.prototype[Symbol.iterator] = function() {
  return this;
});
let QQ = class {
  /**
  @internal
  */
  constructor(e, t, r, s) {
    this.from = e, this.to = t, this.number = r, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function fs(i, e, t) {
  return e = Math.max(0, Math.min(i.length, e)), [e, Math.max(e, Math.min(i.length, t))];
}
function it(i, e, t = !0, r = !0) {
  return xQ(i, e, t, r);
}
function PQ(i) {
  return i >= 56320 && i < 57344;
}
function $Q(i) {
  return i >= 55296 && i < 56320;
}
function vt(i, e) {
  let t = i.charCodeAt(e);
  if (!$Q(t) || e + 1 == i.length)
    return t;
  let r = i.charCodeAt(e + 1);
  return PQ(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function _u(i) {
  return i <= 65535 ? String.fromCharCode(i) : (i -= 65536, String.fromCharCode((i >> 10) + 55296, (i & 1023) + 56320));
}
function hi(i) {
  return i < 65536 ? 1 : 2;
}
const Mh = /\r\n?|\n/;
var tt = /* @__PURE__ */ function(i) {
  return i[i.Simple = 0] = "Simple", i[i.TrackDel = 1] = "TrackDel", i[i.TrackBefore = 2] = "TrackBefore", i[i.TrackAfter = 3] = "TrackAfter", i;
}(tt || (tt = {}));
class pi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, s = 0; t < this.sections.length; ) {
      let n = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(r, s, n), s += n) : s += o, r += n;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    Dh(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], s = this.sections[t++];
      s < 0 ? e.push(r, s) : e.push(s, r);
    }
    return new pi(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : nv(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : qh(this, e, t);
  }
  mapPos(e, t = -1, r = tt.Simple) {
    let s = 0, n = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = s + a;
      if (l < 0) {
        if (c > e)
          return n + (e - s);
        n += a;
      } else {
        if (r != tt.Simple && c >= e && (r == tt.TrackDel && s < e && c > e || r == tt.TrackBefore && s < e || r == tt.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !a)
          return e == s || t < 0 ? n : n + l;
        n += l;
      }
      s = c;
    }
    if (e > s)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${s}`);
    return n;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, s = 0; r < this.sections.length && s <= t; ) {
      let n = this.sections[r++], o = this.sections[r++], a = s + n;
      if (o >= 0 && s <= t && a >= e)
        return s < e && a > t ? "cover" : !0;
      s = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], s = this.sections[t++];
      e += (e ? " " : "") + r + (s >= 0 ? ":" + s : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new pi(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new pi(e);
  }
}
class je extends pi {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Dh(this, (t, r, s, n, o) => e = e.replace(s, s + (r - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return qh(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let s = 0, n = 0; s < t.length; s += 2) {
      let o = t[s], a = t[s + 1];
      if (a >= 0) {
        t[s] = a, t[s + 1] = o;
        let l = s >> 1;
        for (; r.length < l; )
          r.push(be.empty);
        r.push(o ? e.slice(n, n + o) : be.empty);
      }
      n += o;
    }
    return new je(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : nv(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : qh(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    Dh(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return pi.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], s = [], n = new Pn(this);
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++];
      for (; a < l || a == l && n.len == 0; ) {
        if (n.done)
          break e;
        let h = Math.min(n.len, l - a);
        nt(s, h, -1);
        let f = n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0;
        nt(t, h, f), f > 0 && Ji(r, t, n.text), n.forward(h), a += h;
      }
      let c = e[o++];
      for (; a < c; ) {
        if (n.done)
          break e;
        let h = Math.min(n.len, c - a);
        nt(t, h, -1), nt(s, h, n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0), n.forward(h), a += h;
      }
    }
    return {
      changes: new je(t, r),
      filtered: pi.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], s = this.sections[t + 1];
      s < 0 ? e.push(r) : s == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let s = [], n = [], o = 0, a = null;
    function l(h = !1) {
      if (!h && !s.length)
        return;
      o < t && nt(s, t - o, -1);
      let f = new je(s, n);
      a = a ? a.compose(f.map(a)) : f, s = [], n = [], o = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let f of h)
          c(f);
      else if (h instanceof je) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        l(), a = a ? a.compose(h.map(a)) : h;
      } else {
        let { from: f, to: u = f, insert: g } = h;
        if (f > u || f < 0 || u > t)
          throw new RangeError(`Invalid change range ${f} to ${u} (in doc of length ${t})`);
        let S = g ? typeof g == "string" ? be.of(g.split(r || Mh)) : g : be.empty, v = S.length;
        if (f == u && v == 0)
          return;
        f < o && l(), f > o && nt(s, f - o, -1), nt(s, u - f, v), Ji(n, s, S), o = u;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new je(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let s = 0; s < e.length; s++) {
      let n = e[s];
      if (typeof n == "number")
        t.push(n, -1);
      else {
        if (!Array.isArray(n) || typeof n[0] != "number" || n.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (n.length == 1)
          t.push(n[0], 0);
        else {
          for (; r.length < s; )
            r.push(be.empty);
          r[s] = be.of(n.slice(1)), t.push(n[0], r[s].length);
        }
      }
    }
    return new je(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new je(e, t);
  }
}
function nt(i, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let s = i.length - 2;
  s >= 0 && t <= 0 && t == i[s + 1] ? i[s] += e : s >= 0 && e == 0 && i[s] == 0 ? i[s + 1] += t : r ? (i[s] += e, i[s + 1] += t) : i.push(e, t);
}
function Ji(i, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < i.length)
    i[i.length - 1] = i[i.length - 1].append(t);
  else {
    for (; i.length < r; )
      i.push(be.empty);
    i.push(t);
  }
}
function Dh(i, e, t) {
  let r = i.inserted;
  for (let s = 0, n = 0, o = 0; o < i.sections.length; ) {
    let a = i.sections[o++], l = i.sections[o++];
    if (l < 0)
      s += a, n += a;
    else {
      let c = s, h = n, f = be.empty;
      for (; c += a, h += l, l && r && (f = f.append(r[o - 2 >> 1])), !(t || o == i.sections.length || i.sections[o + 1] < 0); )
        a = i.sections[o++], l = i.sections[o++];
      e(s, c, n, h, f), s = c, n = h;
    }
  }
}
function qh(i, e, t, r = !1) {
  let s = [], n = r ? [] : null, o = new Pn(i), a = new Pn(e);
  for (let l = -1; ; ) {
    if (o.done && a.len || a.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      nt(s, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !t))) {
      let c = a.len;
      for (nt(s, a.ins, -1); c; ) {
        let h = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= h && (nt(s, 0, o.ins), n && Ji(n, s, o.text), l = o.i), o.forward(h), c -= h;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, h = o.len;
      for (; h; )
        if (a.ins == -1) {
          let f = Math.min(h, a.len);
          c += f, h -= f, a.forward(f);
        } else if (a.ins == 0 && a.len < h)
          h -= a.len, a.next();
        else
          break;
      nt(s, c, l < o.i ? o.ins : 0), n && l < o.i && Ji(n, s, o.text), l = o.i, o.forward(o.len - h);
    } else {
      if (o.done && a.done)
        return n ? je.createSet(s, n) : pi.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function nv(i, e, t = !1) {
  let r = [], s = t ? [] : null, n = new Pn(i), o = new Pn(e);
  for (let a = !1; ; ) {
    if (n.done && o.done)
      return s ? je.createSet(r, s) : pi.create(r);
    if (n.ins == 0)
      nt(r, n.len, 0, a), n.next();
    else if (o.len == 0 && !o.done)
      nt(r, 0, o.ins, a), s && Ji(s, r, o.text), o.next();
    else {
      if (n.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(n.len2, o.len), c = r.length;
        if (n.ins == -1) {
          let h = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          nt(r, l, h, a), s && h && Ji(s, r, o.text);
        } else o.ins == -1 ? (nt(r, n.off ? 0 : n.len, l, a), s && Ji(s, r, n.textBit(l))) : (nt(r, n.off ? 0 : n.len, o.off ? 0 : o.ins, a), s && !o.off && Ji(s, r, o.text));
        a = (n.ins > l || o.ins >= 0 && o.len > l) && (a || r.length > c), n.forward2(l), o.forward(l);
      }
    }
  }
}
class Pn {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? be.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? be.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class yr {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, s;
    return this.empty ? r = s = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), s = e.mapPos(this.to, -1)), r == this.from && s == this.to ? this : new yr(r, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return V.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return V.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return V.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new yr(e, t, r);
  }
}
class V {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : V.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new V([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return V.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, V.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new V(e.ranges.map((t) => yr.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new V([V.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, s = 0; s < e.length; s++) {
      let n = e[s];
      if (n.empty ? n.from <= r : n.from < r)
        return V.normalized(e.slice(), t);
      r = n.to;
    }
    return new V(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, s) {
    return yr.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, s) {
    let n = (r ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return t < e ? yr.create(t, e, 48 | n) : yr.create(e, t, (t > e ? 8 : 0) | n);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((s, n) => s.from - n.from), t = e.indexOf(r);
    for (let s = 1; s < e.length; s++) {
      let n = e[s], o = e[s - 1];
      if (n.empty ? n.from <= o.to : n.from < o.to) {
        let a = o.from, l = Math.max(n.to, o.to);
        s <= t && t--, e.splice(--s, 2, n.anchor > n.head ? V.range(l, a) : V.range(a, l));
      }
    }
    return new V(e, t);
  }
}
function ov(i, e) {
  for (let t of i.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let bu = 0;
class ee {
  constructor(e, t, r, s, n) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = s, this.id = bu++, this.default = e([]), this.extensions = typeof n == "function" ? n(this) : n;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ee(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : yu), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new ca([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new ca(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new ca(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function yu(i, e) {
  return i == e || i.length == e.length && i.every((t, r) => t === e[r]);
}
class ca {
  constructor(e, t, r, s) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = s, this.id = bu++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, s = this.facet.compareInput, n = this.id, o = e[n] >> 1, a = this.type == 2, l = !1, c = !1, h = [];
    for (let f of this.dependencies)
      f == "doc" ? l = !0 : f == "selection" ? c = !0 : (((t = e[f.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && h.push(e[f.id]);
    return {
      create(f) {
        return f.values[o] = r(f), 1;
      },
      update(f, u) {
        if (l && u.docChanged || c && (u.docChanged || u.selection) || Bh(f, h)) {
          let g = r(f);
          if (a ? !bO(g, f.values[o], s) : !s(g, f.values[o]))
            return f.values[o] = g, 1;
        }
        return 0;
      },
      reconfigure: (f, u) => {
        let g, S = u.config.address[n];
        if (S != null) {
          let v = Za(u, S);
          if (this.dependencies.every((d) => d instanceof ee ? u.facet(d) === f.facet(d) : d instanceof Ge ? u.field(d, !1) == f.field(d, !1) : !0) || (a ? bO(g = r(f), v, s) : s(g = r(f), v)))
            return f.values[o] = v, 0;
        } else
          g = r(f);
        return f.values[o] = g, 1;
      }
    };
  }
}
function bO(i, e, t) {
  if (i.length != e.length)
    return !1;
  for (let r = 0; r < i.length; r++)
    if (!t(i[r], e[r]))
      return !1;
  return !0;
}
function Bh(i, e) {
  let t = !1;
  for (let r of e)
    on(i, r) & 1 && (t = !0);
  return t;
}
function TQ(i, e, t) {
  let r = t.map((l) => i[l.id]), s = t.map((l) => l.type), n = r.filter((l) => !(l & 1)), o = i[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let h = 0; h < r.length; h++) {
      let f = Za(l, r[h]);
      if (s[h] == 2)
        for (let u of f)
          c.push(u);
      else
        c.push(f);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of r)
        on(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!Bh(l, n))
        return 0;
      let h = a(l);
      return e.compare(h, l.values[o]) ? 0 : (l.values[o] = h, 1);
    },
    reconfigure(l, c) {
      let h = Bh(l, r), f = c.config.facets[e.id], u = c.facet(e);
      if (f && !h && yu(t, f))
        return l.values[o] = u, 0;
      let g = a(l);
      return e.compare(g, u) ? (l.values[o] = u, 0) : (l.values[o] = g, 1);
    }
  };
}
const Qo = /* @__PURE__ */ ee.define({ static: !0 });
class Ge {
  constructor(e, t, r, s, n) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = s, this.spec = n, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new Ge(bu++, e.create, e.update, e.compare || ((r, s) => r === s), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Qo).find((r) => r.field == this);
    return (t?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, s) => {
        let n = r.values[t], o = this.updateF(n, s);
        return this.compareF(n, o) ? 0 : (r.values[t] = o, 1);
      },
      reconfigure: (r, s) => {
        let n = r.facet(Qo), o = s.facet(Qo), a;
        return (a = n.find((l) => l.field == this)) && a != o.find((l) => l.field == this) ? (r.values[t] = a.create(r), 1) : s.config.address[this.id] != null ? (r.values[t] = s.field(this), 0) : (r.values[t] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Qo.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const vr = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Bs(i) {
  return (e) => new av(e, i);
}
const Vi = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Bs(vr.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Bs(vr.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Bs(vr.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Bs(vr.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Bs(vr.lowest)
};
class av {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class lo {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Xh(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return lo.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Xh {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Ia {
  constructor(e, t, r, s, n, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = s, this.staticValues = n, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let s = [], n = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let u of RQ(e, t, o))
      u instanceof Ge ? s.push(u) : (n[u.facet.id] || (n[u.facet.id] = [])).push(u);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let u of s)
      a[u.id] = c.length << 1, c.push((g) => u.slot(g));
    let h = r?.config.facets;
    for (let u in n) {
      let g = n[u], S = g[0].facet, v = h && h[u] || [];
      if (g.every(
        (d) => d.type == 0
        /* Provider.Static */
      ))
        if (a[S.id] = l.length << 1 | 1, yu(v, g))
          l.push(r.facet(S));
        else {
          let d = S.combine(g.map((O) => O.value));
          l.push(r && S.compare(d, r.facet(S)) ? r.facet(S) : d);
        }
      else {
        for (let d of g)
          d.type == 0 ? (a[d.id] = l.length << 1 | 1, l.push(d.value)) : (a[d.id] = c.length << 1, c.push((O) => d.dynamicSlot(O)));
        a[S.id] = c.length << 1, c.push((d) => TQ(d, S, g));
      }
    }
    let f = c.map((u) => u(a));
    return new Ia(e, o, f, a, l, n);
  }
}
function RQ(i, e, t) {
  let r = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function n(o, a) {
    let l = s.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = r[l].indexOf(o);
      c > -1 && r[l].splice(c, 1), o instanceof Xh && t.delete(o.compartment);
    }
    if (s.set(o, a), Array.isArray(o))
      for (let c of o)
        n(c, a);
    else if (o instanceof Xh) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), n(c, a);
    } else if (o instanceof av)
      n(o.inner, o.prec);
    else if (o instanceof Ge)
      r[a].push(o), o.provides && n(o.provides, a);
    else if (o instanceof ca)
      r[a].push(o), o.facet.extensions && n(o.facet.extensions, vr.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      n(c, a);
    }
  }
  return n(i, vr.default), r.reduce((o, a) => o.concat(a));
}
function on(i, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = i.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  i.status[t] = 4;
  let s = i.computeSlot(i, i.config.dynamicSlots[t]);
  return i.status[t] = 2 | s;
}
function Za(i, e) {
  return e & 1 ? i.config.staticValues[e >> 1] : i.values[e >> 1];
}
const lv = /* @__PURE__ */ ee.define(), Ih = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e),
  static: !0
}), cv = /* @__PURE__ */ ee.define({
  combine: (i) => i.length ? i[0] : void 0,
  static: !0
}), hv = /* @__PURE__ */ ee.define(), fv = /* @__PURE__ */ ee.define(), uv = /* @__PURE__ */ ee.define(), dv = /* @__PURE__ */ ee.define({
  combine: (i) => i.length ? i[0] : !1
});
class Ui {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new EQ();
  }
}
class EQ {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Ui(this, e);
  }
}
class AQ {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new he(this, e);
  }
}
class he {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new he(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new AQ(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let s of e) {
      let n = s.map(t);
      n && r.push(n);
    }
    return r;
  }
}
he.reconfigure = /* @__PURE__ */ he.define();
he.appendConfig = /* @__PURE__ */ he.define();
class ze {
  constructor(e, t, r, s, n, o) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = s, this.annotations = n, this.scrollIntoView = o, this._doc = null, this._state = null, r && ov(r, t.newLength), n.some((a) => a.type == ze.time) || (this.annotations = n.concat(ze.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, s, n, o) {
    return new ze(e, t, r, s, n, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(ze.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
ze.time = /* @__PURE__ */ Ui.define();
ze.userEvent = /* @__PURE__ */ Ui.define();
ze.addToHistory = /* @__PURE__ */ Ui.define();
ze.remote = /* @__PURE__ */ Ui.define();
function LQ(i, e) {
  let t = [];
  for (let r = 0, s = 0; ; ) {
    let n, o;
    if (r < i.length && (s == e.length || e[s] >= i[r]))
      n = i[r++], o = i[r++];
    else if (s < e.length)
      n = e[s++], o = e[s++];
    else
      return t;
    !t.length || t[t.length - 1] < n ? t.push(n, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function Ov(i, e, t) {
  var r;
  let s, n, o;
  return t ? (s = e.changes, n = je.empty(e.changes.length), o = i.changes.compose(e.changes)) : (s = e.changes.map(i.changes), n = i.changes.mapDesc(e.changes, !0), o = i.changes.compose(s)), {
    changes: o,
    selection: e.selection ? e.selection.map(n) : (r = i.selection) === null || r === void 0 ? void 0 : r.map(s),
    effects: he.mapEffects(i.effects, s).concat(he.mapEffects(e.effects, n)),
    annotations: i.annotations.length ? i.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: i.scrollIntoView || e.scrollIntoView
  };
}
function Zh(i, e, t) {
  let r = e.selection, s = is(e.annotations);
  return e.userEvent && (s = s.concat(ze.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof je ? e.changes : je.of(e.changes || [], t, i.facet(cv)),
    selection: r && (r instanceof V ? r : V.single(r.anchor, r.head)),
    effects: is(e.effects),
    annotations: s,
    scrollIntoView: !!e.scrollIntoView
  };
}
function pv(i, e, t) {
  let r = Zh(i, e.length ? e[0] : {}, i.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let n = 1; n < e.length; n++) {
    e[n].filter === !1 && (t = !1);
    let o = !!e[n].sequential;
    r = Ov(r, Zh(i, e[n], o ? r.changes.newLength : i.doc.length), o);
  }
  let s = ze.create(i, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return DQ(t ? MQ(s) : s);
}
function MQ(i) {
  let e = i.startState, t = !0;
  for (let s of e.facet(hv)) {
    let n = s(i);
    if (n === !1) {
      t = !1;
      break;
    }
    Array.isArray(n) && (t = t === !0 ? n : LQ(t, n));
  }
  if (t !== !0) {
    let s, n;
    if (t === !1)
      n = i.changes.invertedDesc, s = je.empty(e.doc.length);
    else {
      let o = i.changes.filter(t);
      s = o.changes, n = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    i = ze.create(e, s, i.selection && i.selection.map(n), he.mapEffects(i.effects, n), i.annotations, i.scrollIntoView);
  }
  let r = e.facet(fv);
  for (let s = r.length - 1; s >= 0; s--) {
    let n = r[s](i);
    n instanceof ze ? i = n : Array.isArray(n) && n.length == 1 && n[0] instanceof ze ? i = n[0] : i = pv(e, is(n), !1);
  }
  return i;
}
function DQ(i) {
  let e = i.startState, t = e.facet(uv), r = i;
  for (let s = t.length - 1; s >= 0; s--) {
    let n = t[s](i);
    n && Object.keys(n).length && (r = Ov(r, Zh(e, n, i.changes.newLength), !0));
  }
  return r == i ? i : ze.create(e, i.changes, i.selection, r.effects, r.annotations, r.scrollIntoView);
}
const qQ = [];
function is(i) {
  return i == null ? qQ : Array.isArray(i) ? i : [i];
}
var De = /* @__PURE__ */ function(i) {
  return i[i.Word = 0] = "Word", i[i.Space = 1] = "Space", i[i.Other = 2] = "Other", i;
}(De || (De = {}));
const BQ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Wh;
try {
  Wh = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function XQ(i) {
  if (Wh)
    return Wh.test(i);
  for (let e = 0; e < i.length; e++) {
    let t = i[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || BQ.test(t)))
      return !0;
  }
  return !1;
}
function IQ(i) {
  return (e) => {
    if (!/\S/.test(e))
      return De.Space;
    if (XQ(e))
      return De.Word;
    for (let t = 0; t < i.length; t++)
      if (e.indexOf(i[t]) > -1)
        return De.Word;
    return De.Other;
  };
}
class _e {
  constructor(e, t, r, s, n, o) {
    this.config = e, this.doc = t, this.selection = r, this.values = s, this.status = e.statusTemplate.slice(), this.computeSlot = n, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      on(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return on(this, r), Za(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return pv(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: s } = t;
    for (let a of e.effects)
      a.is(lo.reconfigure) ? (t && (s = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => s.set(c, l)), t = null), s.set(a.value.compartment, a.value.extension)) : a.is(he.reconfigure) ? (t = null, r = a.value) : a.is(he.appendConfig) && (t = null, r = is(r).concat(a.value));
    let n;
    t ? n = e.startState.values.slice() : (t = Ia.resolve(r, s, this), n = new _e(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(Ih) ? e.newSelection : e.newSelection.asSingle();
    new _e(t, e.newDoc, o, n, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: V.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), s = this.changes(r.changes), n = [r.range], o = is(r.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), c = this.changes(l.changes), h = c.map(s);
      for (let u = 0; u < a; u++)
        n[u] = n[u].map(h);
      let f = s.mapDesc(c, !0);
      n.push(l.range.map(f)), s = s.compose(h), o = he.mapEffects(o, h).concat(he.mapEffects(is(l.effects), f));
    }
    return {
      changes: s,
      selection: V.create(n, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof je ? e : je.of(e, this.doc.length, this.facet(_e.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return be.of(e.split(this.facet(_e.lineSeparator) || Mh));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (on(this, t), Za(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let s = e[r];
        s instanceof Ge && this.config.address[s.id] != null && (t[r] = s.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (r) {
      for (let n in r)
        if (Object.prototype.hasOwnProperty.call(e, n)) {
          let o = r[n], a = e[n];
          s.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return _e.create({
      doc: e.doc,
      selection: V.fromJSON(e.selection),
      extensions: t.extensions ? s.concat([t.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Ia.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof be ? e.doc : be.of((e.doc || "").split(t.staticFacet(_e.lineSeparator) || Mh)), s = e.selection ? e.selection instanceof V ? e.selection : V.single(e.selection.anchor, e.selection.head) : V.single(0);
    return ov(s, r.length), t.staticFacet(Ih) || (s = s.asSingle()), new _e(t, r, s, t.dynamicSlots.map(() => null), (n, o) => o.create(n), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_e.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_e.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(dv);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(_e.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, s) => {
      if (s == "$")
        return "$";
      let n = +(s || 1);
      return !n || n > t.length ? r : t[n - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let s = [];
    for (let n of this.facet(lv))
      for (let o of n(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && s.push(o[e]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return IQ(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: s } = this.doc.lineAt(e), n = this.charCategorizer(e), o = e - r, a = e - r;
    for (; o > 0; ) {
      let l = it(t, o, !1);
      if (n(t.slice(l, o)) != De.Word)
        break;
      o = l;
    }
    for (; a < s; ) {
      let l = it(t, a);
      if (n(t.slice(a, l)) != De.Word)
        break;
      a = l;
    }
    return o == a ? null : V.range(o + r, a + r);
  }
}
_e.allowMultipleSelections = Ih;
_e.tabSize = /* @__PURE__ */ ee.define({
  combine: (i) => i.length ? i[0] : 4
});
_e.lineSeparator = cv;
_e.readOnly = dv;
_e.phrases = /* @__PURE__ */ ee.define({
  compare(i, e) {
    let t = Object.keys(i), r = Object.keys(e);
    return t.length == r.length && t.every((s) => i[s] == e[s]);
  }
});
_e.languageData = lv;
_e.changeFilter = hv;
_e.transactionFilter = fv;
_e.transactionExtender = uv;
lo.reconfigure = /* @__PURE__ */ he.define();
function xi(i, e, t = {}) {
  let r = {};
  for (let s of i)
    for (let n of Object.keys(s)) {
      let o = s[n], a = r[n];
      if (a === void 0)
        r[n] = o;
      else if (!(a === o || o === void 0)) if (Object.hasOwnProperty.call(t, n))
        r[n] = t[n](a, o);
      else
        throw new Error("Config merge conflict for field " + n);
    }
  for (let s in e)
    r[s] === void 0 && (r[s] = e[s]);
  return r;
}
class Lr {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return zh.create(e, t, this);
  }
}
Lr.prototype.startSide = Lr.prototype.endSide = 0;
Lr.prototype.point = !1;
Lr.prototype.mapMode = tt.TrackDel;
let zh = class gv {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new gv(e, t, r);
  }
};
function Vh(i, e) {
  return i.from - e.from || i.value.startSide - e.value.startSide;
}
class wu {
  constructor(e, t, r, s) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, s = 0) {
    let n = r ? this.to : this.from;
    for (let o = s, a = n.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = n[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, t, r, s) {
    for (let n = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, n); n < o; n++)
      if (s(this.from[n] + e, this.to[n] + e, this.value[n]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], s = [], n = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], h = this.from[l] + e, f = this.to[l] + e, u, g;
      if (h == f) {
        let S = t.mapPos(h, c.startSide, c.mapMode);
        if (S == null || (u = g = S, c.startSide != c.endSide && (g = t.mapPos(h, c.endSide), g < u)))
          continue;
      } else if (u = t.mapPos(h, c.startSide), g = t.mapPos(f, c.endSide), u > g || u == g && c.startSide > 0 && c.endSide <= 0)
        continue;
      (g - u || c.endSide - c.startSide) < 0 || (o < 0 && (o = u), c.point && (a = Math.max(a, g - u)), r.push(c), s.push(u - o), n.push(g - o));
    }
    return { mapped: r.length ? new wu(s, n, r, a) : null, pos: o };
  }
}
class ye {
  constructor(e, t, r, s) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(e, t, r, s) {
    return new ye(e, t, r, s);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: s = 0, filterTo: n = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (r && (t = t.slice().sort(Vh)), this.isEmpty)
      return t.length ? ye.of(t) : this;
    let a = new mv(this, null, -1).goto(0), l = 0, c = [], h = new Ii();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let f = t[l++];
        h.addInner(f.from, f.to, f.value) || c.push(f);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!o || s > this.chunkEnd(a.chunkIndex) || n < this.chunkPos[a.chunkIndex]) && h.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || s > a.to || n < a.from || o(a.from, a.to, a.value)) && (h.addInner(a.from, a.to, a.value) || c.push(zh.create(a.from, a.to, a.value))), a.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? ye.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: s, filterTo: n }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], s = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        s = Math.max(s, l.maxPoint), t.push(l), r.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: h, pos: f } = l.map(a, e);
        h && (s = Math.max(s, h.maxPoint), t.push(h), r.push(f));
      }
    }
    let n = this.nextLayer.map(e);
    return t.length == 0 ? n : new ye(r, t, n || ye.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let n = this.chunkPos[s], o = this.chunk[s];
        if (t >= n && e <= n + o.length && o.between(n, e - n, t - n, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return $n.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return $n.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, s, n = -1) {
    let o = e.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= n), a = t.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= n), l = yO(o, a, r), c = new Xs(o, l, n), h = new Xs(a, l, n);
    r.iterGaps((f, u, g) => wO(c, f, h, u, g, s)), r.empty && r.length == 0 && wO(c, 0, h, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, s) {
    s == null && (s = 999999999);
    let n = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), o = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (n.length != o.length)
      return !1;
    if (!n.length)
      return !0;
    let a = yO(n, o), l = new Xs(n, a, 0).goto(r), c = new Xs(o, a, 0).goto(r);
    for (; ; ) {
      if (l.to != c.to || !Uh(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > s)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, s, n = -1) {
    let o = new Xs(e, null, n).goto(t), a = t, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let h = o.activeForPoint(o.to), f = o.pointFrom < t ? h.length + 1 : o.point.startSide < 0 ? h.length : Math.min(h.length, l);
        s.point(a, c, o.point, h, f, o.pointRank), l = Math.min(o.openEnd(c), h.length);
      } else c > a && (s.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > r)
        return l + (o.point && o.to > r ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new Ii();
    for (let s of e instanceof zh ? [e] : t ? ZQ(e) : e)
      r.add(s.from, s.to, s.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return ye.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let s = e[r]; s != ye.empty; s = s.nextLayer)
        t = new ye(s.chunkPos, s.chunk, t, Math.max(s.maxPoint, t.maxPoint));
    return t;
  }
}
ye.empty = /* @__PURE__ */ new ye([], [], null, -1);
function ZQ(i) {
  if (i.length > 1)
    for (let e = i[0], t = 1; t < i.length; t++) {
      let r = i[t];
      if (Vh(e, r) > 0)
        return i.slice().sort(Vh);
      e = r;
    }
  return i;
}
ye.empty.nextLayer = ye.empty;
class Ii {
  finishChunk(e) {
    this.chunks.push(new wu(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new Ii())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let s = e - this.lastTo || r.startSide - this.last.endSide;
    if (s <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ye.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = ye.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function yO(i, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let n of i)
    for (let o = 0; o < n.chunk.length; o++)
      n.chunk[o].maxPoint <= 0 && r.set(n.chunk[o], n.chunkPos[o]);
  let s = /* @__PURE__ */ new Set();
  for (let n of e)
    for (let o = 0; o < n.chunk.length; o++) {
      let a = r.get(n.chunk[o]);
      a != null && (t ? t.mapPos(a) : a) == n.chunkPos[o] && !t?.touchesRange(a, a + n.chunk[o].length) && s.add(n.chunk[o]);
    }
  return s;
}
class mv {
  constructor(e, t, r, s = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < e || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class $n {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let s = [];
    for (let n = 0; n < e.length; n++)
      for (let o = e[n]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && s.push(new mv(o, t, r, n));
    return s.length == 1 ? s[0] : new $n(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      uc(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      uc(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), uc(this.heap, 0);
    }
  }
}
function uc(i, e) {
  for (let t = i[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= i.length)
      break;
    let s = i[r];
    if (r + 1 < i.length && s.compare(i[r + 1]) >= 0 && (s = i[r + 1], r++), t.compare(s) < 0)
      break;
    i[r] = t, i[e] = s, e = r;
  }
}
class Xs {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = $n.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Po(this.active, e), Po(this.activeTo, e), Po(this.activeRank, e), this.minActive = xO(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: s, rank: n } = this.cursor;
    for (; t < this.activeRank.length && (n - this.activeRank[t] || s - this.activeTo[t]) > 0; )
      t++;
    $o(this.active, t, r), $o(this.activeTo, t, s), $o(this.activeRank, t, n), e && $o(e, t, this.cursor.from), this.minActive = xO(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > e) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), r && Po(r, s);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let n = this.cursor.value;
          if (!n.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = n, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = n.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let s = r.length - 1; s >= 0 && r[s] < e; s--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function wO(i, e, t, r, s, n) {
  i.goto(e), t.goto(r);
  let o = r + s, a = r, l = r - e;
  for (; ; ) {
    let c = i.to + l - t.to, h = c || i.endSide - t.endSide, f = h < 0 ? i.to + l : t.to, u = Math.min(f, o);
    if (i.point || t.point ? i.point && t.point && (i.point == t.point || i.point.eq(t.point)) && Uh(i.activeForPoint(i.to), t.activeForPoint(t.to)) || n.comparePoint(a, u, i.point, t.point) : u > a && !Uh(i.active, t.active) && n.compareRange(a, u, i.active, t.active), f > o)
      break;
    (c || i.openEnd != t.openEnd) && n.boundChange && n.boundChange(f), a = f, h <= 0 && i.next(), h >= 0 && t.next();
  }
}
function Uh(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (i[t] != e[t] && !i[t].eq(e[t]))
      return !1;
  return !0;
}
function Po(i, e) {
  for (let t = e, r = i.length - 1; t < r; t++)
    i[t] = i[t + 1];
  i.pop();
}
function $o(i, e, t) {
  for (let r = i.length - 1; r >= e; r--)
    i[r + 1] = i[r];
  i[e] = t;
}
function xO(i, e) {
  let t = -1, r = 1e9;
  for (let s = 0; s < e.length; s++)
    (e[s] - r || i[s].endSide - i[t].endSide) < 0 && (t = s, r = e[s]);
  return t;
}
function Nt(i, e, t = i.length) {
  let r = 0;
  for (let s = 0; s < t && s < i.length; )
    i.charCodeAt(s) == 9 ? (r += e - r % e, s++) : (r++, s = it(i, s));
  return r;
}
function jh(i, e, t, r) {
  for (let s = 0, n = 0; ; ) {
    if (n >= e)
      return s;
    if (s == i.length)
      break;
    n += i.charCodeAt(s) == 9 ? t - n % t : 1, s = it(i, s);
  }
  return r === !0 ? -1 : i.length;
}
const Nh = "ͼ", kO = typeof Symbol > "u" ? "__" + Nh : Symbol.for(Nh), Yh = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), CO = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class nr {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function s(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function n(o, a, l, c) {
      let h = [], f = /^@(\w+)\b/.exec(o[0]), u = f && f[1] == "keyframes";
      if (f && a == null) return l.push(o[0] + ";");
      for (let g in a) {
        let S = a[g];
        if (/&/.test(g))
          n(
            g.split(/,\s*/).map((v) => o.map((d) => v.replace(/&/, d))).reduce((v, d) => v.concat(d)),
            S,
            l
          );
        else if (S && typeof S == "object") {
          if (!f) throw new RangeError("The value of a property (" + g + ") should be a primitive value.");
          n(s(g), S, h, u);
        } else S != null && h.push(g.replace(/_.*/, "").replace(/[A-Z]/g, (v) => "-" + v.toLowerCase()) + ": " + S + ";");
      }
      (h.length || u) && l.push((r && !f && !c ? o.map(r) : o).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let o in e) n(s(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = CO[kO] || 1;
    return CO[kO] = e + 1, Nh + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let s = e[Yh], n = r && r.nonce;
    s ? n && s.setNonce(n) : s = new WQ(e, n), s.mount(Array.isArray(t) ? t : [t], e);
  }
}
let QO = /* @__PURE__ */ new Map();
class WQ {
  constructor(e, t) {
    let r = e.ownerDocument || e, s = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && s.CSSStyleSheet) {
      let n = QO.get(r);
      if (n) return e[Yh] = n;
      this.sheet = new s.CSSStyleSheet(), QO.set(r, this);
    } else
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[Yh] = this;
  }
  mount(e, t) {
    let r = this.sheet, s = 0, n = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = this.modules.indexOf(a);
      if (l < n && l > -1 && (this.modules.splice(l, 1), n--, l = -1), l == -1) {
        if (this.modules.splice(n++, 0, a), r) for (let c = 0; c < a.rules.length; c++)
          r.insertRule(a.rules[c], s++);
      } else {
        for (; n < l; ) s += this.modules[n++].rules.length;
        s += a.rules.length, n++;
      }
    }
    if (r)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let l = 0; l < this.modules.length; l++)
        o += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = o;
      let a = t.head || t;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var or = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Tn = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, zQ = typeof navigator < "u" && /Mac/.test(navigator.platform), VQ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var et = 0; et < 10; et++) or[48 + et] = or[96 + et] = String(et);
for (var et = 1; et <= 24; et++) or[et + 111] = "F" + et;
for (var et = 65; et <= 90; et++)
  or[et] = String.fromCharCode(et + 32), Tn[et] = String.fromCharCode(et);
for (var dc in or) Tn.hasOwnProperty(dc) || (Tn[dc] = or[dc]);
function UQ(i) {
  var e = zQ && i.metaKey && i.shiftKey && !i.ctrlKey && !i.altKey || VQ && i.shiftKey && i.key && i.key.length == 1 || i.key == "Unidentified", t = !e && i.key || (i.shiftKey ? Tn : or)[i.keyCode] || i.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Pe() {
  var i = arguments[0];
  typeof i == "string" && (i = document.createElement(i));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {
      var s = t[r];
      typeof s == "string" ? i.setAttribute(r, s) : s != null && (i[r] = s);
    }
    e++;
  }
  for (; e < arguments.length; e++) vv(i, arguments[e]);
  return i;
}
function vv(i, e) {
  if (typeof e == "string")
    i.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    i.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) vv(i, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function Rn(i) {
  let e;
  return i.nodeType == 11 ? e = i.getSelection ? i : i.ownerDocument : e = i, e.getSelection();
}
function Fh(i, e) {
  return e ? i == e || i.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function ha(i, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Fh(i, e.anchorNode);
  } catch {
    return !1;
  }
}
function En(i) {
  return i.nodeType == 3 ? Dr(i, 0, i.nodeValue.length).getClientRects() : i.nodeType == 1 ? i.getClientRects() : [];
}
function an(i, e, t, r) {
  return t ? PO(i, e, t, r, -1) || PO(i, e, t, r, 1) : !1;
}
function Mr(i) {
  for (var e = 0; ; e++)
    if (i = i.previousSibling, !i)
      return e;
}
function Wa(i) {
  return i.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(i.nodeName);
}
function PO(i, e, t, r, s) {
  for (; ; ) {
    if (i == t && e == r)
      return !0;
    if (e == (s < 0 ? 0 : _i(i))) {
      if (i.nodeName == "DIV")
        return !1;
      let n = i.parentNode;
      if (!n || n.nodeType != 1)
        return !1;
      e = Mr(i) + (s < 0 ? 0 : 1), i = n;
    } else if (i.nodeType == 1) {
      if (i = i.childNodes[e + (s < 0 ? -1 : 0)], i.nodeType == 1 && i.contentEditable == "false")
        return !1;
      e = s < 0 ? _i(i) : 0;
    } else
      return !1;
  }
}
function _i(i) {
  return i.nodeType == 3 ? i.nodeValue.length : i.childNodes.length;
}
function El(i, e) {
  let t = e ? i.left : i.right;
  return { left: t, right: t, top: i.top, bottom: i.bottom };
}
function jQ(i) {
  let e = i.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: i.innerWidth,
    top: 0,
    bottom: i.innerHeight
  };
}
function Sv(i, e) {
  let t = e.width / i.offsetWidth, r = e.height / i.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - i.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - i.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function NQ(i, e, t, r, s, n, o, a) {
  let l = i.ownerDocument, c = l.defaultView || window;
  for (let h = i, f = !1; h && !f; )
    if (h.nodeType == 1) {
      let u, g = h == l.body, S = 1, v = 1;
      if (g)
        u = jQ(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (f = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let p = h.getBoundingClientRect();
        ({ scaleX: S, scaleY: v } = Sv(h, p)), u = {
          left: p.left,
          right: p.left + h.clientWidth * S,
          top: p.top,
          bottom: p.top + h.clientHeight * v
        };
      }
      let d = 0, O = 0;
      if (s == "nearest")
        e.top < u.top ? (O = e.top - (u.top + o), t > 0 && e.bottom > u.bottom + O && (O = e.bottom - u.bottom + o)) : e.bottom > u.bottom && (O = e.bottom - u.bottom + o, t < 0 && e.top - O < u.top && (O = e.top - (u.top + o)));
      else {
        let p = e.bottom - e.top, m = u.bottom - u.top;
        O = (s == "center" && p <= m ? e.top + p / 2 - m / 2 : s == "start" || s == "center" && t < 0 ? e.top - o : e.bottom - m + o) - u.top;
      }
      if (r == "nearest" ? e.left < u.left ? (d = e.left - (u.left + n), t > 0 && e.right > u.right + d && (d = e.right - u.right + n)) : e.right > u.right && (d = e.right - u.right + n, t < 0 && e.left < u.left + d && (d = e.left - (u.left + n))) : d = (r == "center" ? e.left + (e.right - e.left) / 2 - (u.right - u.left) / 2 : r == "start" == a ? e.left - n : e.right - (u.right - u.left) + n) - u.left, d || O)
        if (g)
          c.scrollBy(d, O);
        else {
          let p = 0, m = 0;
          if (O) {
            let _ = h.scrollTop;
            h.scrollTop += O / v, m = (h.scrollTop - _) * v;
          }
          if (d) {
            let _ = h.scrollLeft;
            h.scrollLeft += d / S, p = (h.scrollLeft - _) * S;
          }
          e = {
            left: e.left - p,
            top: e.top - m,
            right: e.right - p,
            bottom: e.bottom - m
          }, p && Math.abs(p - d) < 1 && (r = "nearest"), m && Math.abs(m - O) < 1 && (s = "nearest");
        }
      if (g)
        break;
      (e.top < u.top || e.bottom > u.bottom || e.left < u.left || e.right > u.right) && (e = {
        left: Math.max(e.left, u.left),
        right: Math.min(e.right, u.right),
        top: Math.max(e.top, u.top),
        bottom: Math.min(e.bottom, u.bottom)
      }), h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function YQ(i) {
  let e = i.ownerDocument, t, r;
  for (let s = i.parentNode; s && !(s == e.body || t && r); )
    if (s.nodeType == 1)
      !r && s.scrollHeight > s.clientHeight && (r = s), !t && s.scrollWidth > s.clientWidth && (t = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: t, y: r };
}
class FQ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? _i(t) : 0), r, Math.min(e.focusOffset, r ? _i(r) : 0));
  }
  set(e, t, r, s) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = s;
  }
}
let zr = null;
function _v(i) {
  if (i.setActive)
    return i.setActive();
  if (zr)
    return i.focus(zr);
  let e = [];
  for (let t = i; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (i.focus(zr == null ? {
    get preventScroll() {
      return zr = { preventScroll: !0 }, !0;
    }
  } : void 0), !zr) {
    zr = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], s = e[t++], n = e[t++];
      r.scrollTop != s && (r.scrollTop = s), r.scrollLeft != n && (r.scrollLeft = n);
    }
  }
}
let $O;
function Dr(i, e, t = e) {
  let r = $O || ($O = document.createRange());
  return r.setEnd(i, t), r.setStart(i, e), r;
}
function rs(i, e, t, r) {
  let s = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  r && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = r);
  let n = new KeyboardEvent("keydown", s);
  n.synthetic = !0, i.dispatchEvent(n);
  let o = new KeyboardEvent("keyup", s);
  return o.synthetic = !0, i.dispatchEvent(o), n.defaultPrevented || o.defaultPrevented;
}
function HQ(i) {
  for (; i; ) {
    if (i && (i.nodeType == 9 || i.nodeType == 11 && i.host))
      return i;
    i = i.assignedSlot || i.parentNode;
  }
  return null;
}
function bv(i) {
  for (; i.attributes.length; )
    i.removeAttributeNode(i.attributes[0]);
}
function GQ(i, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, _i(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let s = t.childNodes[r - 1];
      s.contentEditable == "false" ? r-- : (t = s, r = _i(t));
    } else {
      if (t == i)
        return !0;
      r = Mr(t), t = t.parentNode;
    }
}
function yv(i) {
  return i.scrollTop > Math.max(1, i.scrollHeight - i.clientHeight - 4);
}
function wv(i, e) {
  for (let t = i, r = e; ; ) {
    if (t.nodeType == 3 && r > 0)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r - 1], r = _i(t);
    } else if (t.parentNode && !Wa(t))
      r = Mr(t), t = t.parentNode;
    else
      return null;
  }
}
function xv(i, e) {
  for (let t = i, r = e; ; ) {
    if (t.nodeType == 3 && r < t.nodeValue.length)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r], r = 0;
    } else if (t.parentNode && !Wa(t))
      r = Mr(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class at {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new at(e.parentNode, Mr(e), t);
  }
  static after(e, t) {
    return new at(e.parentNode, Mr(e) + 1, t);
  }
}
const xu = [];
class Re {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, s = null, n;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (n = s ? s.nextSibling : r.firstChild)) {
            let a = Re.get(n);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(n);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (n = s ? s.nextSibling : r.firstChild, t && !t.written && t.node == r && n != o.dom && (t.written = !0), o.dom.parentNode == r)
          for (; n && n != o.dom; )
            n = TO(n);
        else
          r.insertBefore(o.dom, n);
        s = o.dom;
      }
      for (n = s ? s.nextSibling : r.firstChild, n && t && t.node == r && (t.written = !0); n; )
        n = TO(n);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let s = _i(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let n = e.parentNode;
        if (n == this.dom)
          break;
        s == 0 && n.firstChild != n.lastChild && (e == n.firstChild ? s = -1 : s = 1), e = n;
      }
      s < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Re.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let s = 0, n = 0; ; s++) {
      let o = this.children[s];
      if (o.dom == r)
        return n;
      n += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let s = -1, n = -1, o = -1, a = -1;
    for (let l = 0, c = r, h = r; l < this.children.length; l++) {
      let f = this.children[l], u = c + f.length;
      if (c < e && u > t)
        return f.domBoundsAround(e, t, c);
      if (u >= e && s == -1 && (s = l, n = c), c > t && f.dom.parentNode == this.dom) {
        o = l, a = h;
        break;
      }
      h = u, c = u + f.breakAfter;
    }
    return {
      from: n,
      to: a < 0 ? r + this.length : a,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = xu) {
    this.markDirty();
    for (let s = e; s < t; s++) {
      let n = this.children[s];
      n.parent == this && r.indexOf(n) < 0 && n.destroy();
    }
    r.length < 250 ? this.children.splice(e, t - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(t));
    for (let s = 0; s < r.length; s++)
      r[s].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new kv(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, s, n, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Re.prototype.breakAfter = 0;
function TO(i) {
  let e = i.nextSibling;
  return i.parentNode.removeChild(i), e;
}
class kv {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function Cv(i, e, t, r, s, n, o, a, l) {
  let { children: c } = i, h = c.length ? c[e] : null, f = n.length ? n[n.length - 1] : null, u = f ? f.breakAfter : o;
  if (!(e == r && h && !o && !u && n.length < 2 && h.merge(t, s, n.length ? f : null, t == 0, a, l))) {
    if (r < c.length) {
      let g = c[r];
      g && (s < g.length || g.breakAfter && f?.breakAfter) ? (e == r && (g = g.split(s), s = 0), !u && f && g.merge(0, s, f, !0, 0, l) ? n[n.length - 1] = g : ((s || g.children.length && !g.children[0].length) && g.merge(0, s, null, !1, 0, l), n.push(g))) : g?.breakAfter && (f ? f.breakAfter = 1 : o = 1), r++;
    }
    for (h && (h.breakAfter = o, t > 0 && (!o && n.length && h.merge(t, h.length, n[0], !1, a, 0) ? h.breakAfter = n.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, a, 0), e++)); e < r && n.length; )
      if (c[r - 1].become(n[n.length - 1]))
        r--, n.pop(), l = n.length ? 0 : a;
      else if (c[e].become(n[0]))
        e++, n.shift(), a = n.length ? 0 : l;
      else
        break;
    !n.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < r || n.length) && i.replaceChildren(e, r, n);
  }
}
function Qv(i, e, t, r, s, n) {
  let o = i.childCursor(), { i: a, off: l } = o.findPos(t, 1), { i: c, off: h } = o.findPos(e, -1), f = e - t;
  for (let u of r)
    f += u.length;
  i.length += f, Cv(i, c, h, a, l, r, 0, s, n);
}
let St = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Hh = typeof document < "u" ? document : { documentElement: { style: {} } };
const Gh = /* @__PURE__ */ /Edge\/(\d+)/.exec(St.userAgent), Pv = /* @__PURE__ */ /MSIE \d/.test(St.userAgent), Kh = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(St.userAgent), Al = !!(Pv || Kh || Gh), RO = !Al && /* @__PURE__ */ /gecko\/(\d+)/i.test(St.userAgent), Oc = !Al && /* @__PURE__ */ /Chrome\/(\d+)/.exec(St.userAgent), KQ = "webkitFontSmoothing" in Hh.documentElement.style, $v = !Al && /* @__PURE__ */ /Apple Computer/.test(St.vendor), EO = $v && (/* @__PURE__ */ /Mobile\/\w+/.test(St.userAgent) || St.maxTouchPoints > 2);
var re = {
  mac: EO || /* @__PURE__ */ /Mac/.test(St.platform),
  windows: /* @__PURE__ */ /Win/.test(St.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(St.platform),
  ie: Al,
  ie_version: Pv ? Hh.documentMode || 6 : Kh ? +Kh[1] : Gh ? +Gh[1] : 0,
  gecko: RO,
  gecko_version: RO ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(St.userAgent) || [0, 0])[1] : 0,
  chrome: !!Oc,
  chrome_version: Oc ? +Oc[1] : 0,
  ios: EO,
  android: /* @__PURE__ */ /Android\b/.test(St.userAgent),
  safari: $v,
  webkit_version: KQ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(St.userAgent) || [0, 0])[1] : 0,
  tabSize: Hh.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const JQ = 256;
class Yt extends Re {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof Yt) || this.length - (t - e) + r.length > JQ || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Yt(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new at(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return eP(this.dom, e, t);
  }
}
class Zi extends Re {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let s of t)
      s.setParent(this);
  }
  setAttrs(e) {
    if (bv(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, s, n, o) {
    return r && (!(r instanceof Zi && r.mark.eq(this.mark)) || e && n <= 0 || t < this.length && o <= 0) ? !1 : (Qv(this, e, t, r ? r.children.slice() : [], n - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, s = -1, n = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > e && t.push(r < e ? a.split(e - r) : a), s < 0 && r >= e && (s = n), r = l, n++;
    }
    let o = this.length - e;
    return this.length = e, s > -1 && (this.children.length = s, this.markDirty()), new Zi(this.mark, t, o);
  }
  domAtPos(e) {
    return Tv(this, e);
  }
  coordsAt(e, t) {
    return Ev(this, e, t);
  }
}
function eP(i, e, t) {
  let r = i.nodeValue.length;
  e > r && (e = r);
  let s = e, n = e, o = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? re.chrome || re.gecko || (e ? (s--, o = 1) : n < r && (n++, o = -1)) : t < 0 ? s-- : n < r && n++;
  let a = Dr(i, s, n).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : t >= 0) ? 0 : a.length - 1];
  return re.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? El(l, o < 0) : l || null;
}
class er extends Re {
  static create(e, t, r) {
    return new er(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = er.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, s, n, o) {
    return r && (!(r instanceof er) || !this.widget.compare(r.widget) || e > 0 && n <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof er && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return be.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, s = this.posAtStart;
    return r ? r.slice(s, s + this.length) : be.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? at.before(this.dom) : at.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let s = this.dom.getClientRects(), n = null;
    if (!s.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? s.length - 1 : 0; n = s[a], !(e > 0 ? a == 0 : a == s.length - 1 || n.top < n.bottom); a += o ? -1 : 1)
      ;
    return El(n, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class us extends Re {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof us && e.side == this.side;
  }
  split() {
    return new us(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? at.before(this.dom) : at.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return be.empty;
  }
  get isHidden() {
    return !0;
  }
}
Yt.prototype.children = er.prototype.children = us.prototype.children = xu;
function Tv(i, e) {
  let t = i.dom, { children: r } = i, s = 0;
  for (let n = 0; s < r.length; s++) {
    let o = r[s], a = n + o.length;
    if (!(a == n && o.getSide() <= 0)) {
      if (e > n && e < a && o.dom.parentNode == t)
        return o.domAtPos(e - n);
      if (e <= n)
        break;
      n = a;
    }
  }
  for (let n = s; n > 0; n--) {
    let o = r[n - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let n = s; n < r.length; n++) {
    let o = r[n];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new at(t, 0);
}
function Rv(i, e, t) {
  let r, { children: s } = i;
  t > 0 && e instanceof Zi && s.length && (r = s[s.length - 1]) instanceof Zi && r.mark.eq(e.mark) ? Rv(r, e.children[0], t - 1) : (s.push(e), e.setParent(i)), i.length += e.length;
}
function Ev(i, e, t) {
  let r = null, s = -1, n = null, o = -1;
  function a(c, h) {
    for (let f = 0, u = 0; f < c.children.length && u <= h; f++) {
      let g = c.children[f], S = u + g.length;
      S >= h && (g.children.length ? a(g, h - u) : (!n || n.isHidden && (t > 0 || iP(n, g))) && (S > h || u == S && g.getSide() > 0) ? (n = g, o = h - u) : (u < h || u == S && g.getSide() < 0 && !g.isHidden) && (r = g, s = h - u)), u = S;
    }
  }
  a(i, e);
  let l = (t < 0 ? r : n) || r || n;
  return l ? l.coordsAt(Math.max(0, l == r ? s : o), t) : tP(i);
}
function tP(i) {
  let e = i.dom.lastChild;
  if (!e)
    return i.dom.getBoundingClientRect();
  let t = En(e);
  return t[t.length - 1] || null;
}
function iP(i, e) {
  let t = i.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return t && r && r.top < t.bottom;
}
function Jh(i, e) {
  for (let t in i)
    t == "class" && e.class ? e.class += " " + i.class : t == "style" && e.style ? e.style += ";" + i.style : e[t] = i[t];
  return e;
}
const AO = /* @__PURE__ */ Object.create(null);
function za(i, e, t) {
  if (i == e)
    return !0;
  i || (i = AO), e || (e = AO);
  let r = Object.keys(i), s = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != s.length - (t && s.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let n of r)
    if (n != t && (s.indexOf(n) == -1 || i[n] !== e[n]))
      return !1;
  return !0;
}
function ef(i, e, t) {
  let r = !1;
  if (e)
    for (let s in e)
      t && s in t || (r = !0, s == "style" ? i.style.cssText = "" : i.removeAttribute(s));
  if (t)
    for (let s in t)
      e && e[s] == t[s] || (r = !0, s == "style" ? i.style.cssText = t[s] : i.setAttribute(s, t[s]));
  return r;
}
function rP(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < i.attributes.length; t++) {
    let r = i.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
class ji {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var dt = /* @__PURE__ */ function(i) {
  return i[i.Text = 0] = "Text", i[i.WidgetBefore = 1] = "WidgetBefore", i[i.WidgetAfter = 2] = "WidgetAfter", i[i.WidgetRange = 3] = "WidgetRange", i;
}(dt || (dt = {}));
class ae extends Lr {
  constructor(e, t, r, s) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new co(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new ar(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, s;
    if (e.isBlockGap)
      r = -5e8, s = 4e8;
    else {
      let { start: n, end: o } = Av(e, t);
      r = (n ? t ? -3e8 : -1 : 5e8) - 1, s = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new ar(e, r, s, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new ho(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return ye.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ae.none = ye.empty;
class co extends ae {
  constructor(e) {
    let { start: t, end: r } = Av(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof co && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && za(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
co.prototype.point = !1;
class ho extends ae {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof ho && this.spec.class == e.spec.class && za(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
ho.prototype.mapMode = tt.TrackBefore;
ho.prototype.point = !0;
class ar extends ae {
  constructor(e, t, r, s, n, o) {
    super(t, r, n, e), this.block = s, this.isReplace = o, this.mapMode = s ? t <= 0 ? tt.TrackBefore : tt.TrackAfter : tt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? dt.WidgetRange : this.startSide <= 0 ? dt.WidgetBefore : dt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof ar && sP(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
ar.prototype.point = !0;
function Av(i, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = i;
  return t == null && (t = i.inclusive), r == null && (r = i.inclusive), { start: t ?? e, end: r ?? e };
}
function sP(i, e) {
  return i == e || !!(i && e && i.compare(e));
}
function fa(i, e, t, r = 0) {
  let s = t.length - 1;
  s >= 0 && t[s] + r >= i ? t[s] = Math.max(t[s], e) : t.push(i, e);
}
class We extends Re {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, s, n, o) {
    if (r) {
      if (!(r instanceof We))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return s && this.setDeco(r ? r.attrs : null), Qv(this, e, t, r ? r.children.slice() : [], n, o), !0;
  }
  split(e) {
    let t = new We();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: s } = this.childPos(e);
    s && (t.append(this.children[r].split(s), 0), this.children[r].merge(s, this.children[r].length, null, !1, 0, 0), r++);
    for (let n = r; n < this.children.length; n++)
      t.append(this.children[n], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    za(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    Rv(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = Jh(t, this.attrs || {})), r && (this.attrs = Jh({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return Tv(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (bv(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (ef(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let s = this.dom.lastChild;
    for (; s && Re.get(s) instanceof Zi; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((r = Re.get(s)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!re.ios || !this.children.some((n) => n instanceof Yt))) {
      let n = document.createElement("BR");
      n.cmIgnore = !0, this.dom.appendChild(n);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof Yt) || /[^ -~]/.test(r.text))
        return null;
      let s = En(r.dom);
      if (s.length != 1)
        return null;
      e += s[0].width, t = s[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = Ev(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, n = r.bottom - r.top;
      if (Math.abs(n - s.lineHeight) < 2 && s.textHeight < n) {
        let o = (n - s.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof We && this.children.length == 0 && e.children.length == 0 && za(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, s = 0; r < e.children.length; r++) {
      let n = e.children[r], o = s + n.length;
      if (o >= t) {
        if (n instanceof We)
          return n;
        if (o > t)
          break;
      }
      s = o + n.breakAfter;
    }
    return null;
  }
}
class qi extends Re {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, s, n, o) {
    return r && (!(r instanceof qi) || !this.widget.compare(r.widget) || e > 0 && n <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? at.before(this.dom) : at.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new qi(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return xu;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : be.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof qi && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    return r || (this.widget instanceof tf ? null : El(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class tf extends ji {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class ln {
  constructor(e, t, r, s) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof qi && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new We()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(To(new us(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof qi) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: n, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = n, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(To(new Yt(this.text.slice(this.textOff, this.textOff + s)), t), r), this.atCursorPos = !0, this.textOff += s, e -= s, r = 0;
    }
  }
  span(e, t, r, s) {
    this.buildText(t - e, r, s), this.pos = t, this.openStart < 0 && (this.openStart = s);
  }
  point(e, t, r, s, n, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof ar) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (r instanceof ar)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new qi(r.widget || ds.block, a, r));
      else {
        let l = er.create(r.widget || ds.inline, a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && n <= s.length && (e < t || r.startSide > 0), h = !l.isEditable && (e < t || n > s.length || r.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), c && (f.append(To(new us(1), s), n), n = s.length + Math.max(0, n - s.length)), f.append(To(l, s), n), this.atCursorPos = h, this.pendingBuffer = h ? e < t || n > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = n);
  }
  static build(e, t, r, s, n) {
    let o = new ln(e, t, r, n);
    return o.openEnd = ye.spans(s, t, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function To(i, e) {
  for (let t of e)
    i = new Zi(t, [i], i.length);
  return i;
}
class ds extends ji {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
ds.inline = /* @__PURE__ */ new ds("span");
ds.block = /* @__PURE__ */ new ds("div");
var Me = /* @__PURE__ */ function(i) {
  return i[i.LTR = 0] = "LTR", i[i.RTL = 1] = "RTL", i;
}(Me || (Me = {}));
const qr = Me.LTR, ku = Me.RTL;
function Lv(i) {
  let e = [];
  for (let t = 0; t < i.length; t++)
    e.push(1 << +i[t]);
  return e;
}
const nP = /* @__PURE__ */ Lv("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), oP = /* @__PURE__ */ Lv("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), rf = /* @__PURE__ */ Object.create(null), si = [];
for (let i of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ i.charCodeAt(0), t = /* @__PURE__ */ i.charCodeAt(1);
  rf[e] = t, rf[t] = -e;
}
function Mv(i) {
  return i <= 247 ? nP[i] : 1424 <= i && i <= 1524 ? 2 : 1536 <= i && i <= 1785 ? oP[i - 1536] : 1774 <= i && i <= 2220 ? 4 : 8192 <= i && i <= 8204 ? 256 : 64336 <= i && i <= 65023 ? 4 : 1;
}
const aP = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class tr {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? ku : qr;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, s) {
    let n = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= t && a.to >= t) {
        if (a.level == r)
          return o;
        (n < 0 || (s != 0 ? s < 0 ? a.from < t : a.to > t : e[n].level > a.level)) && (n = o);
      }
    }
    if (n < 0)
      throw new RangeError("Index out of range");
    return n;
  }
}
function Dv(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++) {
    let r = i[t], s = e[t];
    if (r.from != s.from || r.to != s.to || r.direction != s.direction || !Dv(r.inner, s.inner))
      return !1;
  }
  return !0;
}
const $e = [];
function lP(i, e, t, r, s) {
  for (let n = 0; n <= r.length; n++) {
    let o = n ? r[n - 1].to : e, a = n < r.length ? r[n].from : t, l = n ? 256 : s;
    for (let c = o, h = l, f = l; c < a; c++) {
      let u = Mv(i.charCodeAt(c));
      u == 512 ? u = h : u == 8 && f == 4 && (u = 16), $e[c] = u == 4 ? 2 : u, u & 7 && (f = u), h = u;
    }
    for (let c = o, h = l, f = l; c < a; c++) {
      let u = $e[c];
      if (u == 128)
        c < a - 1 && h == $e[c + 1] && h & 24 ? u = $e[c] = h : $e[c] = 256;
      else if (u == 64) {
        let g = c + 1;
        for (; g < a && $e[g] == 64; )
          g++;
        let S = c && h == 8 || g < t && $e[g] == 8 ? f == 1 ? 1 : 8 : 256;
        for (let v = c; v < g; v++)
          $e[v] = S;
        c = g - 1;
      } else u == 8 && f == 1 && ($e[c] = 1);
      h = u, u & 7 && (f = u);
    }
  }
}
function cP(i, e, t, r, s) {
  let n = s == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, h = o < r.length ? r[o].from : t;
    for (let f = c, u, g, S; f < h; f++)
      if (g = rf[u = i.charCodeAt(f)])
        if (g < 0) {
          for (let v = a - 3; v >= 0; v -= 3)
            if (si[v + 1] == -g) {
              let d = si[v + 2], O = d & 2 ? s : d & 4 ? d & 1 ? n : s : 0;
              O && ($e[f] = $e[si[v]] = O), a = v;
              break;
            }
        } else {
          if (si.length == 189)
            break;
          si[a++] = f, si[a++] = u, si[a++] = l;
        }
      else if ((S = $e[f]) == 2 || S == 1) {
        let v = S == s;
        l = v ? 0 : 1;
        for (let d = a - 3; d >= 0; d -= 3) {
          let O = si[d + 2];
          if (O & 2)
            break;
          if (v)
            si[d + 2] |= 2;
          else {
            if (O & 4)
              break;
            si[d + 2] |= 4;
          }
        }
      }
  }
}
function hP(i, e, t, r) {
  for (let s = 0, n = r; s <= t.length; s++) {
    let o = s ? t[s - 1].to : i, a = s < t.length ? t[s].from : e;
    for (let l = o; l < a; ) {
      let c = $e[l];
      if (c == 256) {
        let h = l + 1;
        for (; ; )
          if (h == a) {
            if (s == t.length)
              break;
            h = t[s++].to, a = s < t.length ? t[s].from : e;
          } else if ($e[h] == 256)
            h++;
          else
            break;
        let f = n == 1, u = (h < e ? $e[h] : r) == 1, g = f == u ? f ? 1 : 2 : r;
        for (let S = h, v = s, d = v ? t[v - 1].to : i; S > l; )
          S == d && (S = t[--v].from, d = v ? t[v - 1].to : i), $e[--S] = g;
        l = h;
      } else
        n = c, l++;
    }
  }
}
function sf(i, e, t, r, s, n, o) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == s % 2)
    for (let l = e, c = 0; l < t; ) {
      let h = !0, f = !1;
      if (c == n.length || l < n[c].from) {
        let v = $e[l];
        v != a && (h = !1, f = v == 16);
      }
      let u = !h && a == 1 ? [] : null, g = h ? r : r + 1, S = l;
      e: for (; ; )
        if (c < n.length && S == n[c].from) {
          if (f)
            break e;
          let v = n[c];
          if (!h)
            for (let d = v.to, O = c + 1; ; ) {
              if (d == t)
                break e;
              if (O < n.length && n[O].from == d)
                d = n[O++].to;
              else {
                if ($e[d] == a)
                  break e;
                break;
              }
            }
          if (c++, u)
            u.push(v);
          else {
            v.from > l && o.push(new tr(l, v.from, g));
            let d = v.direction == qr != !(g % 2);
            nf(i, d ? r + 1 : r, s, v.inner, v.from, v.to, o), l = v.to;
          }
          S = v.to;
        } else {
          if (S == t || (h ? $e[S] != a : $e[S] == a))
            break;
          S++;
        }
      u ? sf(i, l, S, r + 1, s, u, o) : l < S && o.push(new tr(l, S, g)), l = S;
    }
  else
    for (let l = t, c = n.length; l > e; ) {
      let h = !0, f = !1;
      if (!c || l > n[c - 1].to) {
        let v = $e[l - 1];
        v != a && (h = !1, f = v == 16);
      }
      let u = !h && a == 1 ? [] : null, g = h ? r : r + 1, S = l;
      e: for (; ; )
        if (c && S == n[c - 1].to) {
          if (f)
            break e;
          let v = n[--c];
          if (!h)
            for (let d = v.from, O = c; ; ) {
              if (d == e)
                break e;
              if (O && n[O - 1].to == d)
                d = n[--O].from;
              else {
                if ($e[d - 1] == a)
                  break e;
                break;
              }
            }
          if (u)
            u.push(v);
          else {
            v.to < l && o.push(new tr(v.to, l, g));
            let d = v.direction == qr != !(g % 2);
            nf(i, d ? r + 1 : r, s, v.inner, v.from, v.to, o), l = v.from;
          }
          S = v.from;
        } else {
          if (S == e || (h ? $e[S - 1] != a : $e[S - 1] == a))
            break;
          S--;
        }
      u ? sf(i, S, l, r + 1, s, u, o) : S < l && o.push(new tr(S, l, g)), l = S;
    }
}
function nf(i, e, t, r, s, n, o) {
  let a = e % 2 ? 2 : 1;
  lP(i, s, n, r, a), cP(i, s, n, r, a), hP(s, n, r, a), sf(i, s, n, e, t, r, o);
}
function fP(i, e, t) {
  if (!i)
    return [new tr(0, 0, e == ku ? 1 : 0)];
  if (e == qr && !t.length && !aP.test(i))
    return qv(i.length);
  if (t.length)
    for (; i.length > $e.length; )
      $e[$e.length] = 256;
  let r = [], s = e == qr ? 0 : 1;
  return nf(i, s, s, t, 0, i.length, r), r;
}
function qv(i) {
  return [new tr(0, i, 0)];
}
let Bv = "";
function uP(i, e, t, r, s) {
  var n;
  let o = r.head - i.from, a = tr.find(e, o, (n = r.bidiLevel) !== null && n !== void 0 ? n : -1, r.assoc), l = e[a], c = l.side(s, t);
  if (o == c) {
    let u = a += s ? 1 : -1;
    if (u < 0 || u >= e.length)
      return null;
    l = e[a = u], o = l.side(!s, t), c = l.side(s, t);
  }
  let h = it(i.text, o, l.forward(s, t));
  (h < l.from || h > l.to) && (h = c), Bv = i.text.slice(Math.min(o, h), Math.max(o, h));
  let f = a == (s ? e.length - 1 : 0) ? null : e[a + (s ? 1 : -1)];
  return f && h == c && f.level + (s ? 0 : 1) < l.level ? V.cursor(f.side(!s, t) + i.from, f.forward(s, t) ? 1 : -1, f.level) : V.cursor(h + i.from, l.forward(s, t) ? -1 : 1, l.level);
}
function dP(i, e, t) {
  for (let r = e; r < t; r++) {
    let s = Mv(i.charCodeAt(r));
    if (s == 1)
      return qr;
    if (s == 2 || s == 4)
      return ku;
  }
  return qr;
}
const Xv = /* @__PURE__ */ ee.define(), Iv = /* @__PURE__ */ ee.define(), Zv = /* @__PURE__ */ ee.define(), Wv = /* @__PURE__ */ ee.define(), of = /* @__PURE__ */ ee.define(), zv = /* @__PURE__ */ ee.define(), Vv = /* @__PURE__ */ ee.define(), Cu = /* @__PURE__ */ ee.define(), Qu = /* @__PURE__ */ ee.define(), Uv = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e)
}), jv = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e)
}), Nv = /* @__PURE__ */ ee.define();
class ss {
  constructor(e, t = "nearest", r = "nearest", s = 5, n = 5, o = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = s, this.xMargin = n, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new ss(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new ss(V.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Ro = /* @__PURE__ */ he.define({ map: (i, e) => i.map(e) }), Yv = /* @__PURE__ */ he.define();
function bt(i, e, t) {
  let r = i.facet(Wv);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const Mi = /* @__PURE__ */ ee.define({ combine: (i) => i.length ? i[0] : !0 });
let OP = 0;
const Gr = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.filter((e, t) => {
      for (let r = 0; r < t; r++)
        if (i[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class Ue {
  constructor(e, t, r, s, n) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = s, this.baseExtensions = n(this), this.extension = this.baseExtensions.concat(Gr.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(Gr.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: s, provide: n, decorations: o } = t || {};
    return new Ue(OP++, e, r, s, (a) => {
      let l = [];
      return o && l.push(An.of((c) => {
        let h = c.plugin(a);
        return h ? o(h) : ae.none;
      })), n && l.push(n(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Ue.define((r, s) => new e(r, s), t);
  }
}
class pc {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (bt(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        bt(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        bt(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Fv = /* @__PURE__ */ ee.define(), Pu = /* @__PURE__ */ ee.define(), An = /* @__PURE__ */ ee.define(), Hv = /* @__PURE__ */ ee.define(), $u = /* @__PURE__ */ ee.define(), Gv = /* @__PURE__ */ ee.define();
function LO(i, e) {
  let t = i.state.facet(Gv);
  if (!t.length)
    return t;
  let r = t.map((n) => n instanceof Function ? n(i) : n), s = [];
  return ye.spans(r, e.from, e.to, {
    point() {
    },
    span(n, o, a, l) {
      let c = n - e.from, h = o - e.from, f = s;
      for (let u = a.length - 1; u >= 0; u--, l--) {
        let g = a[u].spec.bidiIsolate, S;
        if (g == null && (g = dP(e.text, c, h)), l > 0 && f.length && (S = f[f.length - 1]).to == c && S.direction == g)
          S.to = h, f = S.inner;
        else {
          let v = { from: c, to: h, direction: g, inner: [] };
          f.push(v), f = v.inner;
        }
      }
    }
  }), s;
}
const Kv = /* @__PURE__ */ ee.define();
function Tu(i) {
  let e = 0, t = 0, r = 0, s = 0;
  for (let n of i.state.facet(Kv)) {
    let o = n(i);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (s = Math.max(s, o.bottom)));
  }
  return { left: e, right: t, top: r, bottom: s };
}
const Gs = /* @__PURE__ */ ee.define();
class Xt {
  constructor(e, t, r, s) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = s;
  }
  join(e) {
    return new Xt(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let s = e[t - 1];
      if (!(s.fromA > r.toA)) {
        if (s.toA < r.fromA)
          break;
        r = r.join(s), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let s = 0, n = 0, o = 0, a = 0; ; s++) {
      let l = s == e.length ? null : e[s], c = o - a, h = l ? l.fromB : 1e9;
      for (; n < t.length && t[n] < h; ) {
        let f = t[n], u = t[n + 1], g = Math.max(a, f), S = Math.min(h, u);
        if (g <= S && new Xt(g + c, S + c, g, S).addToSet(r), u > h)
          break;
        n += 2;
      }
      if (!l)
        return r;
      new Xt(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), o = l.toA, a = l.toB;
    }
  }
}
class Va {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = je.empty(this.startState.doc.length);
    for (let n of r)
      this.changes = this.changes.compose(n.changes);
    let s = [];
    this.changes.iterChangedRanges((n, o, a, l) => s.push(new Xt(n, o, a, l))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Va(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class MO extends Re {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = ae.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new We()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Xt(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? s = this.domChanged.newSel.head : !bP(e.changes, this.hasComposition) && !e.selectionSet && (s = e.state.selection.main.head));
    let n = s > -1 ? gP(this.view, e.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      r = new Xt(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(r.slice());
    }
    this.hasComposition = n ? { from: n.range.fromB, to: n.range.toB } : null, (re.ie || re.chrome) && !n && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = SP(o, a, e.changes);
    return r = Xt.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, n), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = re.chrome || re.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || s.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let n = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof qi && o.widget instanceof tf && n.push(o.dom);
    s.updateGaps(n);
  }
  updateChildren(e, t, r) {
    let s = r ? r.range.addToSet(e.slice()) : e, n = this.childCursor(t);
    for (let o = s.length - 1; ; o--) {
      let a = o >= 0 ? s[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: h, toB: f } = a, u, g, S, v;
      if (r && r.range.fromB < f && r.range.toB > h) {
        let _ = ln.build(this.view.state.doc, h, r.range.fromB, this.decorations, this.dynamicDecorationMap), b = ln.build(this.view.state.doc, r.range.toB, f, this.decorations, this.dynamicDecorationMap);
        g = _.breakAtStart, S = _.openStart, v = b.openEnd;
        let w = this.compositionView(r);
        b.breakAtStart ? w.breakAfter = 1 : b.content.length && w.merge(w.length, w.length, b.content[0], !1, b.openStart, 0) && (w.breakAfter = b.content[0].breakAfter, b.content.shift()), _.content.length && w.merge(0, 0, _.content[_.content.length - 1], !0, 0, _.openEnd) && _.content.pop(), u = _.content.concat(w).concat(b.content);
      } else
        ({ content: u, breakAtStart: g, openStart: S, openEnd: v } = ln.build(this.view.state.doc, h, f, this.decorations, this.dynamicDecorationMap));
      let { i: d, off: O } = n.findPos(c, 1), { i: p, off: m } = n.findPos(l, -1);
      Cv(this, p, m, d, O, u, g, S, v);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Yv) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let t = new Yt(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: s } of e.marks)
      t = new Zi(s, [t], t.length);
    let r = new We();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (n, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = Re.get(n);
      a && a != o && (a.dom = null), o.setDOM(n);
    }, r = this.childPos(e.range.fromB, 1), s = this.children[r.i];
    t(e.line, s);
    for (let n = e.marks.length - 1; n >= -1; n--)
      r = s.childPos(r.off, 1), s = s.children[r.i], t(n >= 0 ? e.marks[n].node : e.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, s = r == this.dom, n = !s && !(this.view.state.facet(Mi) || this.dom.tabIndex > -1) && ha(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(s || t || n))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (re.gecko && a.empty && !this.hasComposition && pP(l)) {
      let f = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(f, l.node.childNodes[l.offset] || null)), l = c = new at(f, 0), o = !0;
    }
    let h = this.view.observer.selectionRange;
    (o || !h.focusNode || (!an(l.node, l.offset, h.anchorNode, h.anchorOffset) || !an(c.node, c.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, a)) && (this.view.observer.ignore(() => {
      re.android && re.chrome && this.dom.contains(h.focusNode) && _P(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let f = Rn(this.view.root);
      if (f) if (a.empty) {
        if (re.gecko) {
          let u = mP(l.node, l.offset);
          if (u && u != 3) {
            let g = (u == 1 ? wv : xv)(l.node, l.offset);
            g && (l = new at(g.node, g.offset));
          }
        }
        f.collapse(l.node, l.offset), a.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = a.bidiLevel);
      } else if (f.extend) {
        f.collapse(l.node, l.offset);
        try {
          f.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let u = document.createRange();
        a.anchor > a.head && ([l, c] = [c, l]), u.setEnd(c.node, c.offset), u.setStart(l.node, l.offset), f.removeAllRanges(), f.addRange(u);
      }
      n && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new at(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new at(h.focusNode, h.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && an(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = Rn(e.root), { anchorNode: s, anchorOffset: n } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let o = We.find(this, t.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (t.head == a || t.head == a + o.length)
      return;
    let l = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    r.collapse(h.node, h.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let f = e.observer.selectionRange;
    e.docView.posFromDOM(f.anchorNode, f.anchorOffset) != t.from && r.collapse(s, n);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let s = e.offset; !r && s < t.childNodes.length; s++) {
      let n = Re.get(t.childNodes[s]);
      n instanceof We && (r = n.domAtPos(0));
    }
    for (let s = e.offset - 1; !r && s >= 0; s--) {
      let n = Re.get(t.childNodes[s]);
      n instanceof We && (r = n.domAtPos(n.length));
    }
    return r ? new at(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = Re.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let s = this.children[t];
      if (r < s.length || s instanceof We)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, s = 0;
    for (let n = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = n - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof We && !(r instanceof We && t >= 0)))
        r = a, s = c;
      else if (r && c == e && l == e && a instanceof qi && Math.abs(t) < 2) {
        if (a.deco.startSide < 0)
          break;
        o && (r = null);
      }
      n = c;
    }
    return r ? r.coordsAt(e - s, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), s = this.children[t];
    if (!(s instanceof We))
      return null;
    for (; s.children.length; ) {
      let { i: a, off: l } = s.childPos(r, 1);
      for (; ; a++) {
        if (a == s.children.length)
          return null;
        if ((s = s.children[a]).length)
          break;
      }
      r = l;
    }
    if (!(s instanceof Yt))
      return null;
    let n = it(s.text, r);
    if (n == r)
      return null;
    let o = Dr(s.dom, r, n).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: s } = e, n = this.view.contentDOM.clientWidth, o = n > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == Me.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let f = this.children[h], u = c + f.length;
      if (u > s)
        break;
      if (c >= r) {
        let g = f.dom.getBoundingClientRect();
        if (t.push(g.height), o) {
          let S = f.dom.lastChild, v = S ? En(S) : [];
          if (v.length) {
            let d = v[v.length - 1], O = l ? d.right - g.left : g.right - d.left;
            O > a && (a = O, this.minWidth = n, this.minWidthFrom = c, this.minWidthTo = u);
          }
        }
      }
      c = u + f.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Me.RTL : Me.LTR;
  }
  measureTextSize() {
    for (let n of this.children)
      if (n instanceof We) {
        let o = n.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, r, s;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let n = En(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = n ? n.width / 27 : 7, s = n ? n.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: s };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new kv(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, s = 0; ; s++) {
      let n = s == t.viewports.length ? null : t.viewports[s], o = n ? n.from - 1 : this.length;
      if (o > r) {
        let a = (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(ae.replace({
          widget: new tf(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!n)
        break;
      r = n.to + 1;
    }
    return ae.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(An).map((n) => (this.dynamicDecorationMap[e++] = typeof n == "function") ? n(this.view) : n), r = !1, s = this.view.state.facet(Hv).map((n, o) => {
      let a = typeof n == "function";
      return a && (r = !0), a ? n(this.view) : n;
    });
    for (s.length && (this.dynamicDecorationMap[e++] = r, t.push(ye.join(s))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(Nv))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (h) {
        bt(this.view.state, h, "scroll handler");
      }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), s;
    if (!r)
      return;
    !t.empty && (s = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, s.left),
      top: Math.min(r.top, s.top),
      right: Math.max(r.right, s.right),
      bottom: Math.max(r.bottom, s.bottom)
    });
    let n = Tu(this.view), o = {
      left: r.left - n.left,
      top: r.top - n.top,
      right: r.right + n.right,
      bottom: r.bottom + n.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    NQ(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Me.LTR);
  }
}
function pP(i) {
  return i.node.nodeType == 1 && i.node.firstChild && (i.offset == 0 || i.node.childNodes[i.offset - 1].contentEditable == "false") && (i.offset == i.node.childNodes.length || i.node.childNodes[i.offset].contentEditable == "false");
}
function Jv(i, e) {
  let t = i.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let r = wv(t.focusNode, t.focusOffset), s = xv(t.focusNode, t.focusOffset), n = r || s;
  if (s && r && s.node != r.node) {
    let a = Re.get(s.node);
    if (!a || a instanceof Yt && a.text != s.node.nodeValue)
      n = s;
    else if (i.docView.lastCompositionAfterCursor) {
      let l = Re.get(r.node);
      !l || l instanceof Yt && l.text != r.node.nodeValue || (n = s);
    }
  }
  if (i.docView.lastCompositionAfterCursor = n != r, !n)
    return null;
  let o = e - n.offset;
  return { from: o, to: o + n.node.nodeValue.length, node: n.node };
}
function gP(i, e, t) {
  let r = Jv(i, t);
  if (!r)
    return null;
  let { node: s, from: n, to: o } = r, a = s.nodeValue;
  if (/[\n\r]/.test(a) || i.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let l = e.invertedDesc, c = new Xt(l.mapPos(n), l.mapPos(o), n, o), h = [];
  for (let f = s.parentNode; ; f = f.parentNode) {
    let u = Re.get(f);
    if (u instanceof Zi)
      h.push({ node: f, deco: u.mark });
    else {
      if (u instanceof We || f.nodeName == "DIV" && f.parentNode == i.contentDOM)
        return { range: c, text: s, marks: h, line: f };
      if (f != i.contentDOM)
        h.push({ node: f, deco: new co({
          inclusive: !0,
          attributes: rP(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function mP(i, e) {
  return i.nodeType != 1 ? 0 : (e && i.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < i.childNodes.length && i.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let vP = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    fa(e, t, this.changes);
  }
  comparePoint(e, t) {
    fa(e, t, this.changes);
  }
  boundChange(e) {
    fa(e, e, this.changes);
  }
};
function SP(i, e, t) {
  let r = new vP();
  return ye.compare(i, e, t, r), r.changes;
}
function _P(i, e) {
  for (let t = i; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function bP(i, e) {
  let t = !1;
  return e && i.iterChangedRanges((r, s) => {
    r < e.to && s > e.from && (t = !0);
  }), t;
}
function yP(i, e, t = 1) {
  let r = i.charCategorizer(e), s = i.doc.lineAt(e), n = e - s.from;
  if (s.length == 0)
    return V.cursor(e);
  n == 0 ? t = 1 : n == s.length && (t = -1);
  let o = n, a = n;
  t < 0 ? o = it(s.text, n, !1) : a = it(s.text, n);
  let l = r(s.text.slice(o, a));
  for (; o > 0; ) {
    let c = it(s.text, o, !1);
    if (r(s.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < s.length; ) {
    let c = it(s.text, a);
    if (r(s.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return V.range(o + s.from, a + s.from);
}
function wP(i, e) {
  return e.left > i ? e.left - i : Math.max(0, i - e.right);
}
function xP(i, e) {
  return e.top > i ? e.top - i : Math.max(0, i - e.bottom);
}
function gc(i, e) {
  return i.top < e.bottom - 1 && i.bottom > e.top + 1;
}
function DO(i, e) {
  return e < i.top ? { top: e, left: i.left, right: i.right, bottom: i.bottom } : i;
}
function qO(i, e) {
  return e > i.bottom ? { top: i.top, left: i.left, right: i.right, bottom: e } : i;
}
function af(i, e, t) {
  let r, s, n, o, a = !1, l, c, h, f;
  for (let S = i.firstChild; S; S = S.nextSibling) {
    let v = En(S);
    for (let d = 0; d < v.length; d++) {
      let O = v[d];
      s && gc(s, O) && (O = DO(qO(O, s.bottom), s.top));
      let p = wP(e, O), m = xP(t, O);
      if (p == 0 && m == 0)
        return S.nodeType == 3 ? BO(S, e, t) : af(S, e, t);
      if (!r || o > m || o == m && n > p) {
        r = S, s = O, n = p, o = m;
        let _ = m ? t < O.top ? -1 : 1 : p ? e < O.left ? -1 : 1 : 0;
        a = !_ || (_ > 0 ? d < v.length - 1 : d > 0);
      }
      p == 0 ? t > O.bottom && (!h || h.bottom < O.bottom) ? (l = S, h = O) : t < O.top && (!f || f.top > O.top) && (c = S, f = O) : h && gc(h, O) ? h = qO(h, O.bottom) : f && gc(f, O) && (f = DO(f, O.top));
    }
  }
  if (h && h.bottom >= t ? (r = l, s = h) : f && f.top <= t && (r = c, s = f), !r)
    return { node: i, offset: 0 };
  let u = Math.max(s.left, Math.min(s.right, e));
  if (r.nodeType == 3)
    return BO(r, u, t);
  if (a && r.contentEditable != "false")
    return af(r, u, t);
  let g = Array.prototype.indexOf.call(i.childNodes, r) + (e >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: i, offset: g };
}
function BO(i, e, t) {
  let r = i.nodeValue.length, s = -1, n = 1e9, o = 0;
  for (let a = 0; a < r; a++) {
    let l = Dr(i, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let h = l[c];
      if (h.top == h.bottom)
        continue;
      o || (o = e - h.left);
      let f = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && f < n) {
        let u = e >= (h.left + h.right) / 2, g = u;
        if ((re.chrome || re.gecko) && Dr(i, a).getBoundingClientRect().left == h.right && (g = !u), f <= 0)
          return { node: i, offset: a + (g ? 1 : 0) };
        s = a + (g ? 1 : 0), n = f;
      }
    }
  }
  return { node: i, offset: s > -1 ? s : o > 0 ? i.nodeValue.length : 0 };
}
function eS(i, e, t, r = -1) {
  var s, n;
  let o = i.contentDOM.getBoundingClientRect(), a = o.top + i.viewState.paddingTop, l, { docHeight: c } = i.viewState, { x: h, y: f } = e, u = f - a;
  if (u < 0)
    return 0;
  if (u > c)
    return i.state.doc.length;
  for (let _ = i.viewState.heightOracle.textHeight / 2, b = !1; l = i.elementAtHeight(u), l.type != dt.Text; )
    for (; u = r > 0 ? l.bottom + _ : l.top - _, !(u >= 0 && u <= c); ) {
      if (b)
        return t ? null : 0;
      b = !0, r = -r;
    }
  f = a + u;
  let g = l.from;
  if (g < i.viewport.from)
    return i.viewport.from == 0 ? 0 : t ? null : XO(i, o, l, h, f);
  if (g > i.viewport.to)
    return i.viewport.to == i.state.doc.length ? i.state.doc.length : t ? null : XO(i, o, l, h, f);
  let S = i.dom.ownerDocument, v = i.root.elementFromPoint ? i.root : S, d = v.elementFromPoint(h, f);
  d && !i.contentDOM.contains(d) && (d = null), d || (h = Math.max(o.left + 1, Math.min(o.right - 1, h)), d = v.elementFromPoint(h, f), d && !i.contentDOM.contains(d) && (d = null));
  let O, p = -1;
  if (d && ((s = i.docView.nearest(d)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (S.caretPositionFromPoint) {
      let _ = S.caretPositionFromPoint(h, f);
      _ && ({ offsetNode: O, offset: p } = _);
    } else if (S.caretRangeFromPoint) {
      let _ = S.caretRangeFromPoint(h, f);
      _ && ({ startContainer: O, startOffset: p } = _, (!i.contentDOM.contains(O) || re.safari && kP(O, p, h) || re.chrome && CP(O, p, h)) && (O = void 0));
    }
    O && (p = Math.min(_i(O), p));
  }
  if (!O || !i.docView.dom.contains(O)) {
    let _ = We.find(i.docView, g);
    if (!_)
      return u > l.top + l.height / 2 ? l.to : l.from;
    ({ node: O, offset: p } = af(_.dom, h, f));
  }
  let m = i.docView.nearest(O);
  if (!m)
    return null;
  if (m.isWidget && ((n = m.dom) === null || n === void 0 ? void 0 : n.nodeType) == 1) {
    let _ = m.dom.getBoundingClientRect();
    return e.y < _.top || e.y <= _.bottom && e.x <= (_.left + _.right) / 2 ? m.posAtStart : m.posAtEnd;
  } else
    return m.localPosFromDOM(O, p) + m.posAtStart;
}
function XO(i, e, t, r, s) {
  let n = Math.round((r - e.left) * i.defaultCharacterWidth);
  if (i.lineWrapping && t.height > i.defaultLineHeight * 1.5) {
    let a = i.viewState.heightOracle.textHeight, l = Math.floor((s - t.top - (i.defaultLineHeight - a) * 0.5) / a);
    n += l * i.viewState.heightOracle.lineLength;
  }
  let o = i.state.sliceDoc(t.from, t.to);
  return t.from + jh(o, n, i.state.tabSize);
}
function kP(i, e, t) {
  let r;
  if (i.nodeType != 3 || e != (r = i.nodeValue.length))
    return !1;
  for (let s = i.nextSibling; s; s = s.nextSibling)
    if (s.nodeType != 1 || s.nodeName != "BR")
      return !1;
  return Dr(i, r - 1, r).getBoundingClientRect().left > t;
}
function CP(i, e, t) {
  if (e != 0)
    return !1;
  for (let s = i; ; ) {
    let n = s.parentNode;
    if (!n || n.nodeType != 1 || n.firstChild != s)
      return !1;
    if (n.classList.contains("cm-line"))
      break;
    s = n;
  }
  let r = i.nodeType == 1 ? i.getBoundingClientRect() : Dr(i, 0, Math.max(i.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function lf(i, e, t) {
  let r = i.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let s;
    for (let n of r.type) {
      if (n.from > e)
        break;
      if (!(n.to < e)) {
        if (n.from < e && n.to > e)
          return n;
        (!s || n.type == dt.Text && (s.type != n.type || (t < 0 ? n.from < e : n.to > e))) && (s = n);
      }
    }
    return s || r;
  }
  return r;
}
function QP(i, e, t, r) {
  let s = lf(i, e.head, e.assoc || -1), n = !r || s.type != dt.Text || !(i.lineWrapping || s.widgetLineBreaks) ? null : i.coordsAtPos(e.assoc < 0 && e.head > s.from ? e.head - 1 : e.head);
  if (n) {
    let o = i.dom.getBoundingClientRect(), a = i.textDirectionAt(s.from), l = i.posAtCoords({
      x: t == (a == Me.LTR) ? o.right - 1 : o.left + 1,
      y: (n.top + n.bottom) / 2
    });
    if (l != null)
      return V.cursor(l, t ? -1 : 1);
  }
  return V.cursor(t ? s.to : s.from, t ? -1 : 1);
}
function IO(i, e, t, r) {
  let s = i.state.doc.lineAt(e.head), n = i.bidiSpans(s), o = i.textDirectionAt(s.from);
  for (let a = e, l = null; ; ) {
    let c = uP(s, n, o, a, t), h = Bv;
    if (!c) {
      if (s.number == (t ? i.state.doc.lines : 1))
        return a;
      h = `
`, s = i.state.doc.line(s.number + (t ? 1 : -1)), n = i.bidiSpans(s), c = i.visualLineSide(s, !t);
    }
    if (l) {
      if (!l(h))
        return a;
    } else {
      if (!r)
        return c;
      l = r(h);
    }
    a = c;
  }
}
function PP(i, e, t) {
  let r = i.state.charCategorizer(e), s = r(t);
  return (n) => {
    let o = r(n);
    return s == De.Space && (s = o), s == o;
  };
}
function $P(i, e, t, r) {
  let s = e.head, n = t ? 1 : -1;
  if (s == (t ? i.state.doc.length : 0))
    return V.cursor(s, e.assoc);
  let o = e.goalColumn, a, l = i.contentDOM.getBoundingClientRect(), c = i.coordsAtPos(s, e.assoc || -1), h = i.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = n < 0 ? c.top : c.bottom;
  else {
    let g = i.viewState.lineBlockAt(s);
    o == null && (o = Math.min(l.right - l.left, i.defaultCharacterWidth * (s - g.from))), a = (n < 0 ? g.top : g.bottom) + h;
  }
  let f = l.left + o, u = r ?? i.viewState.heightOracle.textHeight >> 1;
  for (let g = 0; ; g += 10) {
    let S = a + (u + g) * n, v = eS(i, { x: f, y: S }, !1, n);
    if (S < l.top || S > l.bottom || (n < 0 ? v < s : v > s)) {
      let d = i.docView.coordsForChar(v), O = !d || S < d.top ? -1 : 1;
      return V.cursor(v, O, void 0, o);
    }
  }
}
function ua(i, e, t) {
  for (; ; ) {
    let r = 0;
    for (let s of i)
      s.between(e - 1, e + 1, (n, o, a) => {
        if (e > n && e < o) {
          let l = r || t || (e - n < o - e ? -1 : 1);
          e = l < 0 ? n : o, r = l;
        }
      });
    if (!r)
      return e;
  }
}
function mc(i, e, t) {
  let r = ua(i.state.facet($u).map((s) => s(i)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : V.cursor(r, r < t.from ? 1 : -1);
}
const Ks = "￿";
class TP {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(_e.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Ks;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let s = e; ; ) {
      this.findPointBefore(r, s);
      let n = this.text.length;
      this.readNode(s);
      let o = s.nextSibling;
      if (o == t)
        break;
      let a = Re.get(s), l = Re.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Wa(s)) || Wa(o) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > n) && this.lineBreak(), s = o;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n = -1, o = 1, a;
      if (this.lineSeparator ? (n = t.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (a = s.exec(t)) && (n = a.index, o = a[0].length), this.append(t.slice(r, n < 0 ? t.length : n)), n < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      r = n + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Re.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let s = r.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (RP(e, r.node, r.offset) ? t : 0));
  }
}
function RP(i, e, t) {
  for (; ; ) {
    if (!e || t < _i(e))
      return !1;
    if (e == i)
      return !0;
    t = Mr(e) + 1, e = e.parentNode;
  }
}
class ZO {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class EP {
  constructor(e, t, r, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: n, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let a = n || o ? [] : MP(e), l = new TP(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = DP(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = n && n.node == a.focusNode && n.offset == a.focusOffset || !Fh(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !Fh(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), h = e.viewport;
      if ((re.ios || re.chrome) && e.state.selection.main.empty && l != c && (h.from > 0 || h.to < e.state.doc.length)) {
        let f = Math.min(l, c), u = Math.max(l, c), g = h.from - f, S = h.to - u;
        (g == 0 || g == 1 || f == 0) && (S == 0 || S == -1 || u == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = V.single(c, l);
    }
  }
}
function tS(i, e) {
  let t, { newSel: r } = e, s = i.state.selection.main, n = i.inputState.lastKeyTime > Date.now() - 100 ? i.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = s.from, c = null;
    (n === 8 || re.android && e.text.length < a - o) && (l = s.to, c = "end");
    let h = LP(i.state.doc.sliceString(o, a, Ks), e.text, l - o, c);
    h && (re.chrome && n == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == Ks + Ks && h.toB--, t = {
      from: o + h.from,
      to: o + h.toA,
      insert: be.of(e.text.slice(h.from, h.toB).split(Ks))
    });
  } else r && (!i.hasFocus && i.state.facet(Mi) || r.main.eq(s)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !s.empty && r && r.main.empty ? t = { from: s.from, to: s.to, insert: i.state.doc.slice(s.from, s.to) } : (re.mac || re.android) && t && t.from == t.to && t.from == s.head - 1 && /^\. ?$/.test(t.insert.toString()) && i.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = V.single(r.main.anchor - 1, r.main.head - 1)), t = { from: t.from, to: t.to, insert: be.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= s.from && t.to <= s.to && (t.from != s.from || t.to != s.to) && s.to - s.from - (t.to - t.from) <= 4 ? t = {
    from: s.from,
    to: s.to,
    insert: i.state.doc.slice(s.from, t.from).append(t.insert).append(i.state.doc.slice(t.to, s.to))
  } : re.chrome && t && t.from == t.to && t.from == s.head && t.insert.toString() == `
 ` && i.lineWrapping && (r && (r = V.single(r.main.anchor - 1, r.main.head - 1)), t = { from: s.from, to: s.to, insert: be.of([" "]) }), t)
    return Ru(i, t, r, n);
  if (r && !r.main.eq(s)) {
    let o = !1, a = "select";
    return i.inputState.lastSelectionTime > Date.now() - 50 && (i.inputState.lastSelectionOrigin == "select" && (o = !0), a = i.inputState.lastSelectionOrigin), i.dispatch({ selection: r, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function Ru(i, e, t, r = -1) {
  if (re.ios && i.inputState.flushIOSKey(e))
    return !0;
  let s = i.state.selection.main;
  if (re.android && (e.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == s.from || e.from == s.from - 1 && i.state.sliceDoc(e.from, s.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && rs(i.contentDOM, "Enter", 13) || (e.from == s.from - 1 && e.to == s.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > s.head) && rs(i.contentDOM, "Backspace", 8) || e.from == s.from && e.to == s.to + 1 && e.insert.length == 0 && rs(i.contentDOM, "Delete", 46)))
    return !0;
  let n = e.insert.toString();
  i.inputState.composing >= 0 && i.inputState.composing++;
  let o, a = () => o || (o = AP(i, e, t));
  return i.state.facet(zv).some((l) => l(i, e.from, e.to, n, a)) || i.dispatch(a()), !0;
}
function AP(i, e, t) {
  let r, s = i.state, n = s.selection.main;
  if (e.from >= n.from && e.to <= n.to && e.to - e.from >= (n.to - n.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && i.inputState.composing < 0) {
    let a = n.from < e.from ? s.sliceDoc(n.from, e.from) : "", l = n.to > e.to ? s.sliceDoc(e.to, n.to) : "";
    r = s.replaceSelection(i.state.toText(a + e.insert.sliceString(0, void 0, i.state.lineBreak) + l));
  } else {
    let a = s.changes(e), l = t && t.main.to <= a.newLength ? t.main : void 0;
    if (s.selection.ranges.length > 1 && i.inputState.composing >= 0 && e.to <= n.to && e.to >= n.to - 10) {
      let c = i.state.sliceDoc(e.from, e.to), h, f = t && Jv(i, t.main.head);
      if (f) {
        let S = e.insert.length - (e.to - e.from);
        h = { from: f.from, to: f.to - S };
      } else
        h = i.state.doc.lineAt(n.head);
      let u = n.to - e.to, g = n.to - n.from;
      r = s.changeByRange((S) => {
        if (S.from == n.from && S.to == n.to)
          return { changes: a, range: l || S.map(a) };
        let v = S.to - u, d = v - c.length;
        if (S.to - S.from != g || i.state.sliceDoc(d, v) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        S.to >= h.from && S.from <= h.to)
          return { range: S };
        let O = s.changes({ from: d, to: v, insert: e.insert }), p = S.to - n.to;
        return {
          changes: O,
          range: l ? V.range(Math.max(0, l.anchor + p), Math.max(0, l.head + p)) : S.map(O)
        };
      });
    } else
      r = {
        changes: a,
        selection: l && s.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (i.composing || i.inputState.compositionPendingChange && i.inputState.compositionEndedAt > Date.now() - 50) && (i.inputState.compositionPendingChange = !1, o += ".compose", i.inputState.compositionFirstChange && (o += ".start", i.inputState.compositionFirstChange = !1)), s.update(r, { userEvent: o, scrollIntoView: !0 });
}
function LP(i, e, t, r) {
  let s = Math.min(i.length, e.length), n = 0;
  for (; n < s && i.charCodeAt(n) == e.charCodeAt(n); )
    n++;
  if (n == s && i.length == e.length)
    return null;
  let o = i.length, a = e.length;
  for (; o > 0 && a > 0 && i.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (r == "end") {
    let l = Math.max(0, n - Math.min(o, a));
    t -= o + l - n;
  }
  if (o < n && i.length < e.length) {
    let l = t <= n && t >= o ? n - t : 0;
    n -= l, a = n + (a - o), o = n;
  } else if (a < n) {
    let l = t <= n && t >= a ? n - t : 0;
    n -= l, o = n + (o - a), a = n;
  }
  return { from: n, toA: o, toB: a };
}
function MP(i) {
  let e = [];
  if (i.root.activeElement != i.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: s, focusOffset: n } = i.observer.selectionRange;
  return t && (e.push(new ZO(t, r)), (s != t || n != r) && e.push(new ZO(s, n))), e;
}
function DP(i, e) {
  if (i.length == 0)
    return null;
  let t = i[0].pos, r = i.length == 2 ? i[1].pos : t;
  return t > -1 && r > -1 ? V.single(t + e, r + e) : null;
}
class qP {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, re.safari && e.contentDOM.addEventListener("input", () => null), re.gecko && JP(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !UP(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let s of r.observers)
        s(this.view, t);
      for (let s of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (s(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = BP(e), r = this.handlers, s = this.view.contentDOM;
    for (let n in t)
      if (n != "scroll") {
        let o = !t[n].handlers.length, a = r[n];
        a && o != !a.handlers.length && (s.removeEventListener(n, this.handleEvent), a = null), a || s.addEventListener(n, this.handleEvent, { passive: o });
      }
    for (let n in r)
      n != "scroll" && !t[n] && s.removeEventListener(n, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && rS.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), re.android && re.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return re.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = iS.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || XP.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, rs(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : re.safari && !re.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function WO(i, e) {
  return (t, r) => {
    try {
      return e.call(i, r, t);
    } catch (s) {
      bt(t.state, s);
    }
  };
}
function BP(i) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of i) {
    let s = r.spec, n = s && s.plugin.domEventHandlers, o = s && s.plugin.domEventObservers;
    if (n)
      for (let a in n) {
        let l = n[a];
        l && t(a).handlers.push(WO(r.value, l));
      }
    if (o)
      for (let a in o) {
        let l = o[a];
        l && t(a).observers.push(WO(r.value, l));
      }
  }
  for (let r in Ft)
    t(r).handlers.push(Ft[r]);
  for (let r in It)
    t(r).observers.push(It[r]);
  return e;
}
const iS = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], XP = "dthko", rS = [16, 17, 18, 20, 91, 92, 224, 225], Eo = 6;
function Ao(i) {
  return Math.max(0, i) * 0.7 + 8;
}
function IP(i, e) {
  return Math.max(Math.abs(i.clientX - e.clientX), Math.abs(i.clientY - e.clientY));
}
class ZP {
  constructor(e, t, r, s) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = YQ(e.contentDOM), this.atoms = e.state.facet($u).map((o) => o(e));
    let n = e.contentDOM.ownerDocument;
    n.addEventListener("mousemove", this.move = this.move.bind(this)), n.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(_e.allowMultipleSelections) && WP(e, t), this.dragging = VP(e, t) && oS(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && IP(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, r = 0, s = 0, n = 0, o = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: n, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = Tu(this.view);
    e.clientX - l.left <= s + Eo ? t = -Ao(s - e.clientX) : e.clientX + l.right >= o - Eo && (t = Ao(e.clientX - o)), e.clientY - l.top <= n + Eo ? r = -Ao(n - e.clientY) : e.clientY + l.bottom >= a - Eo && (r = Ao(e.clientY - a)), this.setScrollSpeed(t, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let s = e.ranges[r], n = null;
      if (s.empty) {
        let o = ua(this.atoms, s.from, 0);
        o != s.from && (n = V.cursor(o, -1));
      } else {
        let o = ua(this.atoms, s.from, -1), a = ua(this.atoms, s.to, 1);
        (o != s.from || a != s.to) && (n = V.range(s.from == s.anchor ? o : a, s.from == s.head ? o : a));
      }
      n && (t || (t = e.ranges.slice()), t[r] = n);
    }
    return t ? V.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function WP(i, e) {
  let t = i.state.facet(Xv);
  return t.length ? t[0](e) : re.mac ? e.metaKey : e.ctrlKey;
}
function zP(i, e) {
  let t = i.state.facet(Iv);
  return t.length ? t[0](e) : re.mac ? !e.altKey : !e.ctrlKey;
}
function VP(i, e) {
  let { main: t } = i.state.selection;
  if (t.empty)
    return !1;
  let r = Rn(i.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let s = r.getRangeAt(0).getClientRects();
  for (let n = 0; n < s.length; n++) {
    let o = s[n];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function UP(i, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != i.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = Re.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const Ft = /* @__PURE__ */ Object.create(null), It = /* @__PURE__ */ Object.create(null), sS = re.ie && re.ie_version < 15 || re.ios && re.webkit_version < 604;
function jP(i) {
  let e = i.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    i.focus(), t.remove(), nS(i, t.value);
  }, 50);
}
function Ll(i, e, t) {
  for (let r of i.facet(e))
    t = r(t, i);
  return t;
}
function nS(i, e) {
  e = Ll(i.state, Cu, e);
  let { state: t } = i, r, s = 1, n = t.toText(e), o = n.lines == t.selection.ranges.length;
  if (cf != null && t.selection.ranges.every((l) => l.empty) && cf == n.toString()) {
    let l = -1;
    r = t.changeByRange((c) => {
      let h = t.doc.lineAt(c.from);
      if (h.from == l)
        return { range: c };
      l = h.from;
      let f = t.toText((o ? n.line(s++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: f },
        range: V.cursor(c.from + f.length)
      };
    });
  } else o ? r = t.changeByRange((l) => {
    let c = n.line(s++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: V.cursor(l.from + c.length)
    };
  }) : r = t.replaceSelection(n);
  i.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
It.scroll = (i) => {
  i.inputState.lastScrollTop = i.scrollDOM.scrollTop, i.inputState.lastScrollLeft = i.scrollDOM.scrollLeft;
};
Ft.keydown = (i, e) => (i.inputState.setSelectionOrigin("select"), e.keyCode == 27 && i.inputState.tabFocusMode != 0 && (i.inputState.tabFocusMode = Date.now() + 2e3), !1);
It.touchstart = (i, e) => {
  i.inputState.lastTouchTime = Date.now(), i.inputState.setSelectionOrigin("select.pointer");
};
It.touchmove = (i) => {
  i.inputState.setSelectionOrigin("select.pointer");
};
Ft.mousedown = (i, e) => {
  if (i.observer.flush(), i.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of i.state.facet(Zv))
    if (t = r(i, e), t)
      break;
  if (!t && e.button == 0 && (t = FP(i, e)), t) {
    let r = !i.hasFocus;
    i.inputState.startMouseSelection(new ZP(i, e, t, r)), r && i.observer.ignore(() => {
      _v(i.contentDOM);
      let n = i.root.activeElement;
      n && !n.contains(i.contentDOM) && n.blur();
    });
    let s = i.inputState.mouseSelection;
    if (s)
      return s.start(e), s.dragging === !1;
  }
  return !1;
};
function zO(i, e, t, r) {
  if (r == 1)
    return V.cursor(e, t);
  if (r == 2)
    return yP(i.state, e, t);
  {
    let s = We.find(i.docView, e), n = i.state.doc.lineAt(s ? s.posAtEnd : e), o = s ? s.posAtStart : n.from, a = s ? s.posAtEnd : n.to;
    return a < i.state.doc.length && a == n.to && a++, V.range(o, a);
  }
}
let VO = (i, e, t) => e >= t.top && e <= t.bottom && i >= t.left && i <= t.right;
function NP(i, e, t, r) {
  let s = We.find(i.docView, e);
  if (!s)
    return 1;
  let n = e - s.posAtStart;
  if (n == 0)
    return 1;
  if (n == s.length)
    return -1;
  let o = s.coordsAt(n, -1);
  if (o && VO(t, r, o))
    return -1;
  let a = s.coordsAt(n, 1);
  return a && VO(t, r, a) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function UO(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: NP(i, t, e.clientX, e.clientY) };
}
const YP = re.ie && re.ie_version <= 11;
let jO = null, NO = 0, YO = 0;
function oS(i) {
  if (!YP)
    return i.detail;
  let e = jO, t = YO;
  return jO = i, YO = Date.now(), NO = !e || t > Date.now() - 400 && Math.abs(e.clientX - i.clientX) < 2 && Math.abs(e.clientY - i.clientY) < 2 ? (NO + 1) % 3 : 1;
}
function FP(i, e) {
  let t = UO(i, e), r = oS(e), s = i.state.selection;
  return {
    update(n) {
      n.docChanged && (t.pos = n.changes.mapPos(t.pos), s = s.map(n.changes));
    },
    get(n, o, a) {
      let l = UO(i, n), c, h = zO(i, l.pos, l.bias, r);
      if (t.pos != l.pos && !o) {
        let f = zO(i, t.pos, t.bias, r), u = Math.min(f.from, h.from), g = Math.max(f.to, h.to);
        h = u < h.from ? V.range(u, g) : V.range(g, u);
      }
      return o ? s.replaceRange(s.main.extend(h.from, h.to)) : a && r == 1 && s.ranges.length > 1 && (c = HP(s, l.pos)) ? c : a ? s.addRange(h) : V.create([h]);
    }
  };
}
function HP(i, e) {
  for (let t = 0; t < i.ranges.length; t++) {
    let { from: r, to: s } = i.ranges[t];
    if (r <= e && s >= e)
      return V.create(i.ranges.slice(0, t).concat(i.ranges.slice(t + 1)), i.mainIndex == t ? 0 : i.mainIndex - (i.mainIndex > t ? 1 : 0));
  }
  return null;
}
Ft.dragstart = (i, e) => {
  let { selection: { main: t } } = i.state;
  if (e.target.draggable) {
    let s = i.docView.nearest(e.target);
    if (s && s.isWidget) {
      let n = s.posAtStart, o = n + s.length;
      (n >= t.to || o <= t.from) && (t = V.range(n, o));
    }
  }
  let { inputState: r } = i;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", Ll(i.state, Qu, i.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Ft.dragend = (i) => (i.inputState.draggedContent = null, !1);
function FO(i, e, t, r) {
  if (t = Ll(i.state, Cu, t), !t)
    return;
  let s = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: n } = i.inputState, o = r && n && zP(i, e) ? { from: n.from, to: n.to } : null, a = { from: s, insert: t }, l = i.state.changes(o ? [o, a] : a);
  i.focus(), i.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(s, -1), head: l.mapPos(s, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), i.inputState.draggedContent = null;
}
Ft.drop = (i, e) => {
  if (!e.dataTransfer)
    return !1;
  if (i.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), s = 0, n = () => {
      ++s == t.length && FO(i, e, r.filter((o) => o != null).join(i.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let a = new FileReader();
      a.onerror = n, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result), n();
      }, a.readAsText(t[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return FO(i, e, r, !0), !0;
  }
  return !1;
};
Ft.paste = (i, e) => {
  if (i.state.readOnly)
    return !0;
  i.observer.flush();
  let t = sS ? null : e.clipboardData;
  return t ? (nS(i, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (jP(i), !1);
};
function GP(i, e) {
  let t = i.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), i.focus();
  }, 50);
}
function KP(i) {
  let e = [], t = [], r = !1;
  for (let s of i.selection.ranges)
    s.empty || (e.push(i.sliceDoc(s.from, s.to)), t.push(s));
  if (!e.length) {
    let s = -1;
    for (let { from: n } of i.selection.ranges) {
      let o = i.doc.lineAt(n);
      o.number > s && (e.push(o.text), t.push({ from: o.from, to: Math.min(i.doc.length, o.to + 1) })), s = o.number;
    }
    r = !0;
  }
  return { text: Ll(i, Qu, e.join(i.lineBreak)), ranges: t, linewise: r };
}
let cf = null;
Ft.copy = Ft.cut = (i, e) => {
  let { text: t, ranges: r, linewise: s } = KP(i.state);
  if (!t && !s)
    return !1;
  cf = s ? t : null, e.type == "cut" && !i.state.readOnly && i.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let n = sS ? null : e.clipboardData;
  return n ? (n.clearData(), n.setData("text/plain", t), !0) : (GP(i, t), !1);
};
const aS = /* @__PURE__ */ Ui.define();
function lS(i, e) {
  let t = [];
  for (let r of i.facet(Vv)) {
    let s = r(i, e);
    s && t.push(s);
  }
  return t.length ? i.update({ effects: t, annotations: aS.of(!0) }) : null;
}
function cS(i) {
  setTimeout(() => {
    let e = i.hasFocus;
    if (e != i.inputState.notifiedFocused) {
      let t = lS(i.state, e);
      t ? i.dispatch(t) : i.update([]);
    }
  }, 10);
}
It.focus = (i) => {
  i.inputState.lastFocusTime = Date.now(), !i.scrollDOM.scrollTop && (i.inputState.lastScrollTop || i.inputState.lastScrollLeft) && (i.scrollDOM.scrollTop = i.inputState.lastScrollTop, i.scrollDOM.scrollLeft = i.inputState.lastScrollLeft), cS(i);
};
It.blur = (i) => {
  i.observer.clearSelectionRange(), cS(i);
};
It.compositionstart = It.compositionupdate = (i) => {
  i.observer.editContext || (i.inputState.compositionFirstChange == null && (i.inputState.compositionFirstChange = !0), i.inputState.composing < 0 && (i.inputState.composing = 0));
};
It.compositionend = (i) => {
  i.observer.editContext || (i.inputState.composing = -1, i.inputState.compositionEndedAt = Date.now(), i.inputState.compositionPendingKey = !0, i.inputState.compositionPendingChange = i.observer.pendingRecords().length > 0, i.inputState.compositionFirstChange = null, re.chrome && re.android ? i.observer.flushSoon() : i.inputState.compositionPendingChange ? Promise.resolve().then(() => i.observer.flush()) : setTimeout(() => {
    i.inputState.composing < 0 && i.docView.hasComposition && i.update([]);
  }, 50));
};
It.contextmenu = (i) => {
  i.inputState.lastContextMenu = Date.now();
};
Ft.beforeinput = (i, e) => {
  var t, r;
  if (e.inputType == "insertReplacementText" && i.observer.editContext) {
    let n = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (n && o.length) {
      let a = o[0], l = i.posAtDOM(a.startContainer, a.startOffset), c = i.posAtDOM(a.endContainer, a.endOffset);
      return Ru(i, { from: l, to: c, insert: i.state.toText(n) }, null), !0;
    }
  }
  let s;
  if (re.chrome && re.android && (s = iS.find((n) => n.inputType == e.inputType)) && (i.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let n = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > n + 10 && i.hasFocus && (i.contentDOM.blur(), i.focus());
    }, 100);
  }
  return re.ios && e.inputType == "deleteContentForward" && i.observer.flushSoon(), re.safari && e.inputType == "insertText" && i.inputState.composing >= 0 && setTimeout(() => It.compositionend(i, e), 20), !1;
};
const HO = /* @__PURE__ */ new Set();
function JP(i) {
  HO.has(i) || (HO.add(i), i.addEventListener("copy", () => {
  }), i.addEventListener("cut", () => {
  }));
}
const GO = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Os = !1;
function KO() {
  Os = !1;
}
class e$ {
  constructor(e) {
    this.lineWrapping = e, this.doc = be.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return GO.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      s < 0 ? r++ : this.heightSamples[Math.floor(s * 10)] || (t = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, s, n, o) {
    let a = GO.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = r, this.textHeight = s, this.lineLength = n, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let h = o[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return l;
  }
}
class t$ {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class fi {
  /**
  @internal
  */
  constructor(e, t, r, s, n) {
    this.from = e, this.length = t, this.top = r, this.height = s, this._content = n;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? dt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof ar ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new fi(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Le = /* @__PURE__ */ function(i) {
  return i[i.ByPos = 0] = "ByPos", i[i.ByHeight = 1] = "ByHeight", i[i.ByPosNoHeight = 2] = "ByPosNoHeight", i;
}(Le || (Le = {}));
const da = 1e-3;
class Ot {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > da && (Os = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return Ot.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, s) {
    let n = this, o = r.doc;
    for (let a = s.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: h, toB: f } = s[a], u = n.lineAt(l, Le.ByPosNoHeight, r.setDoc(t), 0, 0), g = u.to >= c ? u : n.lineAt(c, Le.ByPosNoHeight, r, 0, 0);
      for (f += g.to - c, c = g.to; a > 0 && u.from <= s[a - 1].toA; )
        l = s[a - 1].fromA, h = s[a - 1].fromB, a--, l < u.from && (u = n.lineAt(l, Le.ByPosNoHeight, r, 0, 0));
      h += u.from - l, l = u.from;
      let S = Eu.build(r.setDoc(o), e, h, f);
      n = Ua(n, n.replace(l, c, S));
    }
    return n.updateHeight(r, 0);
  }
  static empty() {
    return new $t(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, s = 0, n = 0;
    for (; ; )
      if (t == r)
        if (s > n * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), r += 1 + a.break, s -= a.size;
        } else if (n > s * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, n -= a.size;
        } else
          break;
      else if (s < n) {
        let a = e[t++];
        a && (s += a.size);
      } else {
        let a = e[--r];
        a && (n += a.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, r++), new i$(Ot.of(e.slice(0, t)), o, Ot.of(e.slice(r)));
  }
}
function Ua(i, e) {
  return i == e ? i : (i.constructor != e.constructor && (Os = !0), e);
}
Ot.prototype.size = 1;
class hS extends Ot {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, s) {
    return new fi(s, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, s, n) {
    return this.blockAt(0, r, s, n);
  }
  forEachLine(e, t, r, s, n, o) {
    e <= n + this.length && t >= n && o(this.blockAt(0, r, s, n));
  }
  updateHeight(e, t = 0, r = !1, s) {
    return s && s.from <= t && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class $t extends hS {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, s) {
    return new fi(s, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let s = r[0];
    return r.length == 1 && (s instanceof $t || s instanceof Je && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof Je ? s = new $t(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : Ot.of(r);
  }
  updateHeight(e, t = 0, r = !1, s) {
    return s && s.from <= t && s.more ? this.setHeight(s.heights[s.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Je extends Ot {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, s = e.doc.lineAt(t + this.length).number, n = s - r + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * n);
      o = l / n, this.length > n + 1 && (a = (this.height - l) / (this.length - n - 1));
    } else
      o = this.height / n;
    return { firstLine: r, lastLine: s, perLine: o, perChar: a };
  }
  blockAt(e, t, r, s) {
    let { firstLine: n, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(t, s);
    if (t.lineWrapping) {
      let c = s + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), h = t.doc.lineAt(c), f = a + h.length * l, u = Math.max(r, e - f / 2);
      return new fi(h.from, h.length, u, f, 0);
    } else {
      let c = Math.max(0, Math.min(o - n, Math.floor((e - r) / a))), { from: h, length: f } = t.doc.line(n + c);
      return new fi(h, f, r + a * c, a, 0);
    }
  }
  lineAt(e, t, r, s, n) {
    if (t == Le.ByHeight)
      return this.blockAt(e, r, s, n);
    if (t == Le.ByPosNoHeight) {
      let { from: g, to: S } = r.doc.lineAt(e);
      return new fi(g, S - g, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, n), c = r.doc.lineAt(e), h = a + c.length * l, f = c.number - o, u = s + a * f + l * (c.from - n - f);
    return new fi(c.from, c.length, Math.max(s, Math.min(u, s + this.height - h)), h, 0);
  }
  forEachLine(e, t, r, s, n, o) {
    e = Math.max(e, n), t = Math.min(t, n + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, n);
    for (let h = e, f = s; h <= t; ) {
      let u = r.doc.lineAt(h);
      if (h == e) {
        let S = u.number - a;
        f += l * S + c * (e - n - S);
      }
      let g = l + c * u.length;
      o(new fi(u.from, u.length, f, g, 0)), f += g, h = u.to + 1;
    }
  }
  replace(e, t, r) {
    let s = this.length - t;
    if (s > 0) {
      let n = r[r.length - 1];
      n instanceof Je ? r[r.length - 1] = new Je(n.length + s) : r.push(null, new Je(s - 1));
    }
    if (e > 0) {
      let n = r[0];
      n instanceof Je ? r[0] = new Je(e + n.length) : r.unshift(new Je(e - 1), null);
    }
    return Ot.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new Je(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Je(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, s) {
    let n = t + this.length;
    if (s && s.from <= t + this.length && s.more) {
      let o = [], a = Math.max(t, s.from), l = -1;
      for (s.from > t && o.push(new Je(s.from - t - 1).updateHeight(e, t)); a <= n && s.more; ) {
        let h = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let f = s.heights[s.index++];
        l == -1 ? l = f : Math.abs(f - l) >= da && (l = -2);
        let u = new $t(h, f);
        u.outdated = !1, o.push(u), a += h + 1;
      }
      a <= n && o.push(null, new Je(n - a).updateHeight(e, a));
      let c = Ot.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= da || Math.abs(l - this.heightMetrics(e, t).perLine) >= da) && (Os = !0), Ua(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class i$ extends Ot {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, s) {
    let n = r + this.left.height;
    return e < n ? this.left.blockAt(e, t, r, s) : this.right.blockAt(e, t, n, s + this.left.length + this.break);
  }
  lineAt(e, t, r, s, n) {
    let o = s + this.left.height, a = n + this.left.length + this.break, l = t == Le.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, t, r, s, n) : this.right.lineAt(e, t, r, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let h = t == Le.ByPosNoHeight ? Le.ByPosNoHeight : Le.ByPos;
    return l ? c.join(this.right.lineAt(a, h, r, o, a)) : this.left.lineAt(a, h, r, s, n).join(c);
  }
  forEachLine(e, t, r, s, n, o) {
    let a = s + this.left.height, l = n + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, r, s, n, o), t >= l && this.right.forEachLine(e, t, r, a, l, o);
    else {
      let c = this.lineAt(l, Le.ByPos, r, s, n);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, s, n, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, r, a, l, o);
    }
  }
  replace(e, t, r) {
    let s = this.left.length + this.break;
    if (t < s)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - s, t - s, r));
    let n = [];
    e > 0 && this.decomposeLeft(e, n);
    let o = n.length;
    for (let a of r)
      n.push(a);
    if (e > 0 && JO(n, o - 1), t < this.length) {
      let a = n.length;
      this.decomposeRight(t, n), JO(n, a);
    }
    return Ot.of(n);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, s = r + this.break;
    if (e >= s)
      return this.right.decomposeRight(e - s, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < s && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Ot.of(this.break ? [e, null, t] : [e, t]) : (this.left = Ua(this.left, e), this.right = Ua(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, s) {
    let { left: n, right: o } = this, a = t + n.length + this.break, l = null;
    return s && s.from <= t + n.length && s.more ? l = n = n.updateHeight(e, t, r, s) : n.updateHeight(e, t, r), s && s.from <= a + o.length && s.more ? l = o = o.updateHeight(e, a, r, s) : o.updateHeight(e, a, r), l ? this.balanced(n, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function JO(i, e) {
  let t, r;
  i[e] == null && (t = i[e - 1]) instanceof Je && (r = i[e + 1]) instanceof Je && i.splice(e - 1, 3, new Je(t.length + 1 + r.length));
}
const r$ = 5;
class Eu {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof $t ? s.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new $t(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let s = r.widget ? r.widget.estimatedHeight : 0, n = r.widget ? r.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let o = t - e;
      r.block ? this.addBlock(new hS(o, s, r)) : (o || n || s >= r$) && this.addLineDeco(s, n, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new $t(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new Je(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof $t)
      return e;
    let t = new $t(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let s = this.ensureLine();
    s.length += r, s.collapsed += r, s.widgetHeight = Math.max(s.widgetHeight, e), s.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof $t) && !this.isCovered ? this.nodes.push(new $t(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let s of this.nodes)
      s instanceof $t && s.updateHeight(this.oracle, r), r += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, s) {
    let n = new Eu(r, e);
    return ye.spans(t, r, s, n, 0), n.finish(r);
  }
}
function s$(i, e, t) {
  let r = new n$();
  return ye.compare(i, e, t, r, 0), r.changes;
}
class n$ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, s) {
    (e < t || r && r.heightRelevant || s && s.heightRelevant) && fa(e, t, this.changes, 5);
  }
}
function o$(i, e) {
  let t = i.getBoundingClientRect(), r = i.ownerDocument, s = r.defaultView || window, n = Math.max(0, t.left), o = Math.min(s.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(s.innerHeight, t.bottom);
  for (let c = i.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let h = c, f = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && f.overflow != "visible") {
        let u = h.getBoundingClientRect();
        n = Math.max(n, u.left), o = Math.min(o, u.right), a = Math.max(a, u.top), l = Math.min(c == i.parentNode ? s.innerHeight : l, u.bottom);
      }
      c = f.position == "absolute" || f.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: n - t.left,
    right: Math.max(n, o) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function a$(i) {
  let e = i.getBoundingClientRect(), t = i.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function l$(i, e) {
  let t = i.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class vc {
  constructor(e, t, r, s) {
    this.from = e, this.to = t, this.size = r, this.displaySize = s;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r], n = t[r];
      if (s.from != n.from || s.to != n.to || s.size != n.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return ae.replace({
      widget: new c$(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class c$ extends ji {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ep {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = tp, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Me.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Pu).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new e$(t), this.stateDeco = e.facet(An).filter((r) => typeof r != "function"), this.heightMap = Ot.empty().applyChanges(this.stateDeco, be.empty, this.heightOracle.setDoc(e.doc), [new Xt(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ae.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let s = r ? t.head : t.anchor;
      if (!e.some(({ from: n, to: o }) => s >= n && s <= o)) {
        let { from: n, to: o } = this.lineBlockAt(s);
        e.push(new Lo(n, o));
      }
    }
    return this.viewports = e.sort((r, s) => r.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? tp : new Au(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(Js(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(An).filter((h) => typeof h != "function");
    let s = e.changedRanges, n = Xt.extendWithRanges(s, s$(r, this.stateDeco, e ? e.changes : je.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    KO(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), n), (this.heightMap.height != o || Os) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let l = n.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(jv) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), s = this.heightOracle, n = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? Me.RTL : Me.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(n), a = t.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (a.width && a.height) {
      let { scaleX: _, scaleY: b } = Sv(t, a);
      (_ > 5e-3 && Math.abs(this.scaleX - _) > 5e-3 || b > 5e-3 && Math.abs(this.scaleY - b) > 5e-3) && (this.scaleX = _, this.scaleY = b, c |= 16, o = l = !0);
    }
    let f = (parseInt(r.paddingTop) || 0) * this.scaleY, u = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != f || this.paddingBottom != u) && (this.paddingTop = f, this.paddingBottom = u, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (s.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let g = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != g && (this.scrollAnchorHeight = -1, this.scrollTop = g), this.scrolledToBottom = yv(e.scrollDOM);
    let S = (this.printing ? l$ : o$)(t, this.paddingTop), v = S.top - this.pixelViewport.top, d = S.bottom - this.pixelViewport.bottom;
    this.pixelViewport = S;
    let O = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (O != this.inView && (this.inView = O, O && (l = !0)), !this.inView && !this.scrollTarget && !a$(e.dom))
      return 0;
    let p = a.width;
    if ((this.contentDOMWidth != p || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
      let _ = e.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(_) && (o = !0), o || s.lineWrapping && Math.abs(p - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: b, charWidth: w, textHeight: x } = e.docView.measureTextSize();
        o = b > 0 && s.refresh(n, b, w, x, p / w, _), o && (e.docView.minWidth = 0, c |= 16);
      }
      v > 0 && d > 0 ? h = Math.max(v, d) : v < 0 && d < 0 && (h = Math.min(v, d)), KO();
      for (let b of this.viewports) {
        let w = b.from == this.viewport.from ? _ : e.docView.measureVisibleLineHeights(b);
        this.heightMap = (o ? Ot.empty().applyChanges(this.stateDeco, be.empty, this.heightOracle, [new Xt(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(s, 0, o, new t$(b.from, w));
      }
      Os && (c |= 2);
    }
    let m = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return m && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(h, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || m) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), s = this.heightMap, n = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new Lo(s.lineAt(o - r * 1e3, Le.ByHeight, n, 0, 0).from, s.lineAt(a + (1 - r) * 1e3, Le.ByHeight, n, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < l.from || c > l.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = s.lineAt(c, Le.ByPos, n, 0, 0), u;
        t.y == "center" ? u = (f.top + f.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && c < l.from ? u = f.top : u = f.bottom - h, l = new Lo(s.lineAt(u - 1e3 / 2, Le.ByHeight, n, 0, 0).from, s.lineAt(u + h + 1e3 / 2, Le.ByHeight, n, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), s = t.mapPos(e.to, 1);
    return new Lo(this.heightMap.lineAt(r, Le.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, Le.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(e, Le.ByPos, this.heightOracle, 0, 0), { bottom: n } = this.heightMap.lineAt(t, Le.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || s <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || n >= a + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && s > o - 2 * 1e3 && n < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let s of e)
      t.touchesRange(s.from, s.to) || r.push(new vc(t.mapPos(s.from), t.mapPos(s.to), s.size, s.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, s = r ? 1e4 : 2e3, n = s >> 1, o = s << 1;
    if (this.defaultTextDirection != Me.LTR && !r)
      return [];
    let a = [], l = (h, f, u, g) => {
      if (f - h < n)
        return;
      let S = this.state.selection.main, v = [S.from];
      S.empty || v.push(S.to);
      for (let O of v)
        if (O > h && O < f) {
          l(h, O - 10, u, g), l(O + 10, f, u, g);
          return;
        }
      let d = f$(e, (O) => O.from >= u.from && O.to <= u.to && Math.abs(O.from - h) < n && Math.abs(O.to - f) < n && !v.some((p) => O.from < p && O.to > p));
      if (!d) {
        if (f < u.to && t && r && t.visibleRanges.some((m) => m.from <= f && m.to >= f)) {
          let m = t.moveToLineBoundary(V.cursor(f), !1, !0).head;
          m > h && (f = m);
        }
        let O = this.gapSize(u, h, f, g), p = r || O < 2e6 ? O : 2e6;
        d = new vc(h, f, O, p);
      }
      a.push(d);
    }, c = (h) => {
      if (h.length < o || h.type != dt.Text)
        return;
      let f = h$(h.from, h.to, this.stateDeco);
      if (f.total < o)
        return;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, g, S;
      if (r) {
        let v = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, d, O;
        if (u != null) {
          let p = Do(f, u), m = ((this.visibleBottom - this.visibleTop) / 2 + v) / h.height;
          d = p - m, O = p + m;
        } else
          d = (this.visibleTop - h.top - v) / h.height, O = (this.visibleBottom - h.top + v) / h.height;
        g = Mo(f, d), S = Mo(f, O);
      } else {
        let v = f.total * this.heightOracle.charWidth, d = s * this.heightOracle.charWidth, O = 0;
        if (v > 2e6)
          for (let w of e)
            w.from >= h.from && w.from < h.to && w.size != w.displaySize && w.from * this.heightOracle.charWidth + O < this.pixelViewport.left && (O = w.size - w.displaySize);
        let p = this.pixelViewport.left + O, m = this.pixelViewport.right + O, _, b;
        if (u != null) {
          let w = Do(f, u), x = ((m - p) / 2 + d) / v;
          _ = w - x, b = w + x;
        } else
          _ = (p - d) / v, b = (m + d) / v;
        g = Mo(f, _), S = Mo(f, b);
      }
      g > h.from && l(h.from, g, h, f), S < h.to && l(S, h.to, h, f);
    };
    for (let h of this.viewportLines)
      Array.isArray(h.type) ? h.type.forEach(c) : c(h);
    return a;
  }
  gapSize(e, t, r, s) {
    let n = Do(s, r) - Do(s, t);
    return this.heightOracle.lineWrapping ? e.height * n : s.total * this.heightOracle.charWidth * n;
  }
  updateLineGaps(e) {
    vc.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = ae.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let r = [];
    ye.spans(t, this.viewport.from, this.viewport.to, {
      span(n, o) {
        r.push({ from: n, to: o });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (r.length != this.visibleRanges.length)
      s = 12;
    else
      for (let n = 0; n < r.length && !(s & 8); n++) {
        let o = this.visibleRanges[n], a = r[n];
        (o.from != a.from || o.to != a.to) && (s |= 4, e && e.mapPos(o.from, -1) == a.from && e.mapPos(o.to, 1) == a.to || (s |= 8));
      }
    return this.visibleRanges = r, s;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Js(this.heightMap.lineAt(e, Le.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || Js(this.heightMap.lineAt(this.scaler.fromDOM(e), Le.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Js(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Lo {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function h$(i, e, t) {
  let r = [], s = i, n = 0;
  return ye.spans(t, i, e, {
    span() {
    },
    point(o, a) {
      o > s && (r.push({ from: s, to: o }), n += o - s), s = a;
    }
  }, 20), s < e && (r.push({ from: s, to: e }), n += e - s), { total: n, ranges: r };
}
function Mo({ total: i, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(i * t);
  for (let s = 0; ; s++) {
    let { from: n, to: o } = e[s], a = o - n;
    if (r <= a)
      return n + r;
    r -= a;
  }
}
function Do(i, e) {
  let t = 0;
  for (let { from: r, to: s } of i.ranges) {
    if (e <= s) {
      t += e - r;
      break;
    }
    t += s - r;
  }
  return t / i.total;
}
function f$(i, e) {
  for (let t of i)
    if (e(t))
      return t;
}
const tp = {
  toDOM(i) {
    return i;
  },
  fromDOM(i) {
    return i;
  },
  scale: 1,
  eq(i) {
    return i == this;
  }
};
class Au {
  constructor(e, t, r) {
    let s = 0, n = 0, o = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let c = t.lineAt(a, Le.ByPos, e, 0, 0).top, h = t.lineAt(l, Le.ByPos, e, 0, 0).bottom;
      return s += h - c, { from: a, to: l, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (t.height - s);
    for (let a of this.viewports)
      a.domTop = o + (a.top - n) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), n = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, s = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.top)
        return s + (e - r) * this.scale;
      if (e <= n.bottom)
        return n.domTop + (e - n.top);
      r = n.bottom, s = n.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, s = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.domTop)
        return r + (e - s) / this.scale;
      if (e <= n.domBottom)
        return n.top + (e - n.domTop);
      r = n.bottom, s = n.domBottom;
    }
  }
  eq(e) {
    return e instanceof Au ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, r) => t.from == e.viewports[r].from && t.to == e.viewports[r].to) : !1;
  }
}
function Js(i, e) {
  if (e.scale == 1)
    return i;
  let t = e.toDOM(i.top), r = e.toDOM(i.bottom);
  return new fi(i.from, i.length, t, r - t, Array.isArray(i._content) ? i._content.map((s) => Js(s, e)) : i._content);
}
const qo = /* @__PURE__ */ ee.define({ combine: (i) => i.join(" ") }), hf = /* @__PURE__ */ ee.define({ combine: (i) => i.indexOf(!0) > -1 }), ff = /* @__PURE__ */ nr.newName(), fS = /* @__PURE__ */ nr.newName(), uS = /* @__PURE__ */ nr.newName(), dS = { "&light": "." + fS, "&dark": "." + uS };
function uf(i, e, t) {
  return new nr(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (s) => {
        if (s == "&")
          return i;
        if (!t || !t[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return t[s];
      }) : i + " " + r;
    }
  });
}
const u$ = /* @__PURE__ */ uf("." + ff, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, dS), d$ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Sc = re.ie && re.ie_version <= 11;
class O$ {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new FQ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (re.ie && re.ie_version <= 11 || re.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(re.chrome && re.chrome_version < 126) && (this.editContext = new g$(e), e.state.facet(Mi) && (e.contentDOM.editContext = this.editContext.editContext)), Sc && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, s = this.selectionRange;
    if (r.state.facet(Mi) ? r.root.activeElement != this.dom : !ha(this.dom, s))
      return;
    let n = s.anchorNode && r.docView.nearest(s.anchorNode);
    if (n && n.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (re.ie && re.ie_version <= 11 || re.android && re.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && an(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Rn(e.root);
    if (!t)
      return !1;
    let r = re.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && p$(this.view, t) || t;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let s = ha(this.dom, r);
    return s && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && GQ(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, d$), Sc && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Sc && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let s = () => {
        let n = this.delayedAndroidKey;
        n && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = n.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && n.force && rs(this.dom, n.key, n.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, s = !1;
    for (let n of e) {
      let o = this.readMutation(n);
      o && (o.typeOver && (s = !0), t == -1 ? { from: t, to: r } = o : (t = Math.min(o.from, t), r = Math.max(o.to, r)));
    }
    return { from: t, to: r, typeOver: s };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), s = this.selectionChanged && ha(this.dom, this.selectionRange);
    if (e < 0 && !s)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let n = new EP(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: n.newSel ? n.newSel.main : null }, n;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, s = tS(this.view, t);
    return this.view.state == r && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = ip(t, e.previousSibling || e.target.previousSibling, -1), s = ip(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: s ? t.posBefore(s) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Mi) != e.state.facet(Mi) && (e.view.contentDOM.editContext = e.state.facet(Mi) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function ip(i, e, t) {
  for (; e; ) {
    let r = Re.get(e);
    if (r && r.parent == i)
      return r;
    let s = e.parentNode;
    e = s != i.dom ? s : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function rp(i, e) {
  let t = e.startContainer, r = e.startOffset, s = e.endContainer, n = e.endOffset, o = i.docView.domAtPos(i.state.selection.main.anchor);
  return an(o.node, o.offset, s, n) && ([t, r, s, n] = [s, n, t, r]), { anchorNode: t, anchorOffset: r, focusNode: s, focusOffset: n };
}
function p$(i, e) {
  if (e.getComposedRanges) {
    let s = e.getComposedRanges(i.root)[0];
    if (s)
      return rp(i, s);
  }
  let t = null;
  function r(s) {
    s.preventDefault(), s.stopImmediatePropagation(), t = s.getTargetRanges()[0];
  }
  return i.contentDOM.addEventListener("beforeinput", r, !0), i.dom.ownerDocument.execCommand("indent"), i.contentDOM.removeEventListener("beforeinput", r, !0), t ? rp(i, t) : null;
}
class g$ {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let s = e.state.selection.main, { anchor: n, head: o } = s, a = this.toEditorPos(r.updateRangeStart), l = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: a, drifted: !1 });
      let c = { from: a, to: l, insert: be.of(r.text.split(`
`)) };
      if (c.from == this.from && n < this.from ? c.from = n : c.to == this.to && n > this.to && (c.to = n), c.from == c.to && !c.insert.length) {
        let h = V.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        h.main.eq(s) || e.dispatch({ selection: h, userEvent: "select" });
        return;
      }
      if ((re.mac || re.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: a, to: l, insert: be.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let h = this.to - this.from + (c.to - c.from + c.insert.length);
        Ru(e, c, V.single(this.toEditorPos(r.selectionStart, h), this.toEditorPos(r.selectionEnd, h)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (r) => {
      let s = [], n = null;
      for (let o = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); o < a; o++) {
        let l = e.coordsForChar(o);
        n = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || n || new DOMRect(), s.push(n);
      }
      t.updateCharacterBounds(r.rangeStart, s);
    }, this.handlers.textformatupdate = (r) => {
      let s = [];
      for (let n of r.getTextFormats()) {
        let o = n.underlineStyle, a = n.underlineThickness;
        if (o != "None" && a != "None") {
          let l = this.toEditorPos(n.rangeStart), c = this.toEditorPos(n.rangeEnd);
          if (l < c) {
            let h = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
            s.push(ae.mark({ attributes: { style: h } }).range(l, c));
          }
        }
      }
      e.dispatch({ effects: Yv.of(ae.set(s)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      t.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let s = Rn(r.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, r = !1, s = this.pendingContextChange;
    return e.changes.iterChanges((n, o, a, l, c) => {
      if (r)
        return;
      let h = c.length - (o - n);
      if (s && o >= s.to)
        if (s.from == n && s.to == o && s.insert.eq(c)) {
          s = this.pendingContextChange = null, t += h, this.to += h;
          return;
        } else
          s = null, this.revertPending(e.state);
      if (n += t, o += t, o <= this.from)
        this.from += h, this.to += h;
      else if (n < this.to) {
        if (n < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(n), this.toContextPos(o), c.toString()), this.to += h;
      }
      t += h;
    }), s && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let t = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((s) => !s.isUserEvent("input.type") && s.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), s = this.toContextPos(t.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != s) && this.editContext.updateSelection(r, s);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class K {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((s) => s.forEach((n) => r(n, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = e.root || HQ(e.parent) || document, this.viewState = new ep(e.state || _e.create(e)), e.scrollTo && e.scrollTo.is(Ro) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Gr).map((s) => new pc(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new O$(this), this.inputState = new qP(this), this.inputState.ensureHandlers(this.plugins), this.docView = new MO(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof ze ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, s, n = this.state;
    for (let u of e) {
      if (u.startState != n)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n = u.state;
    }
    if (this.destroyed) {
      this.viewState.state = n;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((u) => u.annotation(aS)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = lS(n, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(n.doc) || !this.state.selection.eq(n.selection)) && (h = null)) : this.observer.clear(), n.facet(_e.phrases) != this.state.facet(_e.phrases))
      return this.setState(n);
    s = Va.create(this, n, e), s.flags |= a;
    let f = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let u of e) {
        if (f && (f = f.map(u.changes)), u.scrollIntoView) {
          let { main: g } = u.state.selection;
          f = new ss(g.empty ? g : V.cursor(g.head, g.head > g.anchor ? -1 : 1));
        }
        for (let g of u.effects)
          g.is(Ro) && (f = g.value.clip(this.state));
      }
      this.viewState.update(s, f), this.bidiCache = ja.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), t = this.docView.update(s), this.state.facet(Gs) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((u) => u.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(qo) != s.state.facet(qo) && (this.viewState.mustMeasureContent = !0), (t || r || f || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !s.empty)
      for (let u of this.state.facet(of))
        try {
          u(s);
        } catch (g) {
          bt(this.state, g, "update listener");
        }
    (l || h) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), h && !tS(this, h) && c.force && rs(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new ep(e), this.plugins = e.facet(Gr).map((r) => new pc(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new MO(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Gr), r = e.state.facet(Gr);
    if (t != r) {
      let s = [];
      for (let n of r) {
        let o = t.indexOf(n);
        if (o < 0)
          s.push(new pc(n));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, s.push(a);
        }
      }
      for (let n of this.plugins)
        n.mustUpdate != e && n.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = e;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (r) {
          bt(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, s = r.scrollTop * this.scaleY, { scrollAnchorPos: n, scrollAnchorHeight: o } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (yv(r))
            n = -1, o = this.viewState.heightMap.height;
          else {
            let g = this.viewState.scrollAnchorAt(s);
            n = g.from, o = g.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((g) => {
          try {
            return g.read(this);
          } catch (S) {
            return bt(this.state, S), sp;
          }
        }), f = Va.create(this, this.state, []), u = !1;
        f.flags |= l, t ? t.flags |= l : t = f, this.updateState = 2, f.empty || (this.updatePlugins(f), this.inputState.update(f), this.updateAttrs(), u = this.docView.update(f), u && this.docViewUpdate());
        for (let g = 0; g < c.length; g++)
          if (h[g] != sp)
            try {
              let S = c[g];
              S.write && S.write(h[g], this);
            } catch (S) {
              bt(this.state, S);
            }
        if (u && this.docView.updateSelection(!0), !f.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let S = (n < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n).top) - o;
              if (S > 1 || S < -1) {
                s = s + S, r.scrollTop = s / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(of))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return ff + " " + (this.state.facet(hf) ? uS : fS) + " " + this.state.facet(qo);
  }
  updateAttrs() {
    let e = np(this, Fv, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Mi) ? "true" : "false",
      class: "cm-content",
      style: `${re.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), np(this, Pu, t);
    let r = this.observer.ignore(() => {
      let s = ef(this.contentDOM, this.contentAttrs, t), n = ef(this.dom, this.editorAttrs, e);
      return s || n;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let s of r.effects)
        if (s.is(K.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let n = this.announceDOM.appendChild(document.createElement("div"));
          n.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Gs);
    let e = this.state.facet(K.cspNonce);
    nr.mount(this.root, this.styleModules.concat(u$).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return mc(this, e, IO(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return mc(this, e, IO(this, e, t, (r) => PP(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), s = this.textDirectionAt(e.from), n = r[t ? r.length - 1 : 0];
    return V.cursor(n.side(t, s) + e.from, n.forward(!t, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return QP(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return mc(this, e, $P(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), eS(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let s = this.state.doc.lineAt(e), n = this.bidiSpans(s), o = n[tr.find(n, e - s.from, -1, t)];
    return El(r, o.dir == Me.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Uv) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > m$)
      return qv(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let n of this.bidiCache)
      if (n.from == e.from && n.dir == t && (n.fresh || Dv(n.isolates, r = LO(this, e))))
        return n.order;
    r || (r = LO(this, e));
    let s = fP(e.text, t, r);
    return this.bidiCache.push(new ja(e.from, e.to, t, r, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || re.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      _v(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Ro.of(new ss(typeof e == "number" ? V.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return Ro.of(new ss(V.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Ue.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Ue.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = nr.newName(), s = [qo.of(r), Gs.of(uf(`.${r}`, e))];
    return t && t.dark && s.push(hf.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Vi.lowest(Gs.of(uf("." + ff, e, dS)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), s = r && Re.get(r) || Re.get(e);
    return ((t = s?.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
K.styleModule = Gs;
K.inputHandler = zv;
K.clipboardInputFilter = Cu;
K.clipboardOutputFilter = Qu;
K.scrollHandler = Nv;
K.focusChangeEffect = Vv;
K.perLineTextDirection = Uv;
K.exceptionSink = Wv;
K.updateListener = of;
K.editable = Mi;
K.mouseSelectionStyle = Zv;
K.dragMovesSelection = Iv;
K.clickAddsSelectionRange = Xv;
K.decorations = An;
K.outerDecorations = Hv;
K.atomicRanges = $u;
K.bidiIsolatedRanges = Gv;
K.scrollMargins = Kv;
K.darkTheme = hf;
K.cspNonce = /* @__PURE__ */ ee.define({ combine: (i) => i.length ? i[0] : "" });
K.contentAttributes = Pu;
K.editorAttributes = Fv;
K.lineWrapping = /* @__PURE__ */ K.contentAttributes.of({ class: "cm-lineWrapping" });
K.announce = /* @__PURE__ */ he.define();
const m$ = 4096, sp = {};
class ja {
  constructor(e, t, r, s, n, o) {
    this.from = e, this.to = t, this.dir = r, this.isolates = s, this.fresh = n, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((n) => n.fresh))
      return e;
    let r = [], s = e.length ? e[e.length - 1].dir : Me.LTR;
    for (let n = Math.max(0, e.length - 10); n < e.length; n++) {
      let o = e[n];
      o.dir == s && !t.touchesRange(o.from, o.to) && r.push(new ja(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function np(i, e, t) {
  for (let r = i.state.facet(e), s = r.length - 1; s >= 0; s--) {
    let n = r[s], o = typeof n == "function" ? n(i) : n;
    o && Jh(o, t);
  }
  return t;
}
const v$ = re.mac ? "mac" : re.windows ? "win" : re.linux ? "linux" : "key";
function S$(i, e) {
  const t = i.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let s, n, o, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      n = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : n = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return s && (r = "Alt-" + r), n && (r = "Ctrl-" + r), a && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function Bo(i, e, t) {
  return e.altKey && (i = "Alt-" + i), e.ctrlKey && (i = "Ctrl-" + i), e.metaKey && (i = "Meta-" + i), t !== !1 && e.shiftKey && (i = "Shift-" + i), i;
}
const _$ = /* @__PURE__ */ Vi.default(/* @__PURE__ */ K.domEventHandlers({
  keydown(i, e) {
    return pS(OS(e.state), i, e, "editor");
  }
})), fo = /* @__PURE__ */ ee.define({ enables: _$ }), op = /* @__PURE__ */ new WeakMap();
function OS(i) {
  let e = i.facet(fo), t = op.get(e);
  return t || op.set(e, t = w$(e.reduce((r, s) => r.concat(s), []))), t;
}
function b$(i, e, t) {
  return pS(OS(i.state), e, i, t);
}
let Ki = null;
const y$ = 4e3;
function w$(i, e = v$) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), s = (o, a) => {
    let l = r[o];
    if (l == null)
      r[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, n = (o, a, l, c, h) => {
    var f, u;
    let g = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), S = a.split(/ (?!$)/).map((O) => S$(O, e));
    for (let O = 1; O < S.length; O++) {
      let p = S.slice(0, O).join(" ");
      s(p, !0), g[p] || (g[p] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(m) => {
          let _ = Ki = { view: m, prefix: p, scope: o };
          return setTimeout(() => {
            Ki == _ && (Ki = null);
          }, y$), !0;
        }]
      });
    }
    let v = S.join(" ");
    s(v, !1);
    let d = g[v] || (g[v] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((u = (f = g._any) === null || f === void 0 ? void 0 : f.run) === null || u === void 0 ? void 0 : u.slice()) || []
    });
    l && d.run.push(l), c && (d.preventDefault = !0), h && (d.stopPropagation = !0);
  };
  for (let o of i) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let h = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: f } = o;
        for (let u in h)
          h[u].run.push((g) => f(g, df));
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        n(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && n(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let df = null;
function pS(i, e, t, r) {
  df = e;
  let s = UQ(e), n = vt(s, 0), o = hi(n) == s.length && s != " ", a = "", l = !1, c = !1, h = !1;
  Ki && Ki.view == t && Ki.scope == r && (a = Ki.prefix + " ", rS.indexOf(e.keyCode) < 0 && (c = !0, Ki = null));
  let f = /* @__PURE__ */ new Set(), u = (d) => {
    if (d) {
      for (let O of d.run)
        if (!f.has(O) && (f.add(O), O(t)))
          return d.stopPropagation && (h = !0), !0;
      d.preventDefault && (d.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, g = i[r], S, v;
  return g && (u(g[a + Bo(s, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(re.windows && e.ctrlKey && e.altKey) && (S = or[e.keyCode]) && S != s ? (u(g[a + Bo(S, e, !0)]) || e.shiftKey && (v = Tn[e.keyCode]) != s && v != S && u(g[a + Bo(v, e, !1)])) && (l = !0) : o && e.shiftKey && u(g[a + Bo(s, e, !0)]) && (l = !0), !l && u(g._any) && (l = !0)), c && (l = !0), l && h && e.stopPropagation(), df = null, l;
}
class uo {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, s, n) {
    this.className = e, this.left = t, this.top = r, this.width = s, this.height = n;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let s = e.coordsAtPos(r.head, r.assoc || 1);
      if (!s)
        return [];
      let n = gS(e);
      return [new uo(t, s.left - n.left, s.top - n.top, null, s.bottom - s.top)];
    } else
      return x$(e, t, r);
  }
}
function gS(i) {
  let e = i.scrollDOM.getBoundingClientRect();
  return { left: (i.textDirection == Me.LTR ? e.left : e.right - i.scrollDOM.clientWidth * i.scaleX) - i.scrollDOM.scrollLeft * i.scaleX, top: e.top - i.scrollDOM.scrollTop * i.scaleY };
}
function ap(i, e, t, r) {
  let s = i.coordsAtPos(e, t * 2);
  if (!s)
    return r;
  let n = i.dom.getBoundingClientRect(), o = (s.top + s.bottom) / 2, a = i.posAtCoords({ x: n.left + 1, y: o }), l = i.posAtCoords({ x: n.right - 1, y: o });
  return a == null || l == null ? r : { from: Math.max(r.from, Math.min(a, l)), to: Math.min(r.to, Math.max(a, l)) };
}
function x$(i, e, t) {
  if (t.to <= i.viewport.from || t.from >= i.viewport.to)
    return [];
  let r = Math.max(t.from, i.viewport.from), s = Math.min(t.to, i.viewport.to), n = i.textDirection == Me.LTR, o = i.contentDOM, a = o.getBoundingClientRect(), l = gS(i), c = o.querySelector(".cm-line"), h = c && window.getComputedStyle(c), f = a.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), u = a.right - (h ? parseInt(h.paddingRight) : 0), g = lf(i, r, 1), S = lf(i, s, -1), v = g.type == dt.Text ? g : null, d = S.type == dt.Text ? S : null;
  if (v && (i.lineWrapping || g.widgetLineBreaks) && (v = ap(i, r, 1, v)), d && (i.lineWrapping || S.widgetLineBreaks) && (d = ap(i, s, -1, d)), v && d && v.from == d.from && v.to == d.to)
    return p(m(t.from, t.to, v));
  {
    let b = v ? m(t.from, null, v) : _(g, !1), w = d ? m(null, t.to, d) : _(S, !0), x = [];
    return (v || g).to < (d || S).from - (v && d ? 1 : 0) || g.widgetLineBreaks > 1 && b.bottom + i.defaultLineHeight / 2 < w.top ? x.push(O(f, b.bottom, u, w.top)) : b.bottom < w.top && i.elementAtHeight((b.bottom + w.top) / 2).type == dt.Text && (b.bottom = w.top = (b.bottom + w.top) / 2), p(b).concat(x).concat(p(w));
  }
  function O(b, w, x, y) {
    return new uo(e, b - l.left, w - l.top, x - b, y - w);
  }
  function p({ top: b, bottom: w, horizontal: x }) {
    let y = [];
    for (let k = 0; k < x.length; k += 2)
      y.push(O(x[k], b, x[k + 1], w));
    return y;
  }
  function m(b, w, x) {
    let y = 1e9, k = -1e9, T = [];
    function R(D, q, W, z, Q) {
      let A = i.coordsAtPos(D, D == x.to ? -2 : 2), L = i.coordsAtPos(W, W == x.from ? 2 : -2);
      !A || !L || (y = Math.min(A.top, L.top, y), k = Math.max(A.bottom, L.bottom, k), Q == Me.LTR ? T.push(n && q ? f : A.left, n && z ? u : L.right) : T.push(!n && z ? f : L.left, !n && q ? u : A.right));
    }
    let $ = b ?? x.from, E = w ?? x.to;
    for (let D of i.visibleRanges)
      if (D.to > $ && D.from < E)
        for (let q = Math.max(D.from, $), W = Math.min(D.to, E); ; ) {
          let z = i.state.doc.lineAt(q);
          for (let Q of i.bidiSpans(z)) {
            let A = Q.from + z.from, L = Q.to + z.from;
            if (A >= W)
              break;
            L > q && R(Math.max(A, q), b == null && A <= $, Math.min(L, W), w == null && L >= E, Q.dir);
          }
          if (q = z.to + 1, q >= W)
            break;
        }
    return T.length == 0 && R($, b == null, E, w == null, i.textDirection), { top: y, bottom: k, horizontal: T };
  }
  function _(b, w) {
    let x = a.top + (w ? b.top : b.bottom);
    return { top: x, bottom: x, horizontal: [] };
  }
}
function k$(i, e) {
  return i.constructor == e.constructor && i.eq(e);
}
class C$ {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Oa) != e.state.facet(Oa) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(Oa);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !k$(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let s of e)
        s.update && t && s.constructor && this.drawn[r].constructor && s.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(s.draw(), t);
      for (; t; ) {
        let s = t.nextSibling;
        t.remove(), t = s;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Oa = /* @__PURE__ */ ee.define();
function mS(i) {
  return [
    Ue.define((e) => new C$(e, i)),
    Oa.of(i)
  ];
}
const Ln = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function Q$(i = {}) {
  return [
    Ln.of(i),
    P$,
    $$,
    T$,
    jv.of(!0)
  ];
}
function vS(i) {
  return i.startState.facet(Ln) != i.state.facet(Ln);
}
const P$ = /* @__PURE__ */ mS({
  above: !0,
  markers(i) {
    let { state: e } = i, t = e.facet(Ln), r = [];
    for (let s of e.selection.ranges) {
      let n = s == e.selection.main;
      if (s.empty || t.drawRangeCursor) {
        let o = n ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = s.empty ? s : V.cursor(s.head, s.head > s.anchor ? -1 : 1);
        for (let l of uo.forRange(i, o, a))
          r.push(l);
      }
    }
    return r;
  },
  update(i, e) {
    i.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = vS(i);
    return t && lp(i.state, e), i.docChanged || i.selectionSet || t;
  },
  mount(i, e) {
    lp(e.state, i);
  },
  class: "cm-cursorLayer"
});
function lp(i, e) {
  e.style.animationDuration = i.facet(Ln).cursorBlinkRate + "ms";
}
const $$ = /* @__PURE__ */ mS({
  above: !1,
  markers(i) {
    return i.state.selection.ranges.map((e) => e.empty ? [] : uo.forRange(i, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(i, e) {
    return i.docChanged || i.selectionSet || i.viewportChanged || vS(i);
  },
  class: "cm-selectionLayer"
}), T$ = /* @__PURE__ */ Vi.highest(/* @__PURE__ */ K.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), SS = /* @__PURE__ */ he.define({
  map(i, e) {
    return i == null ? null : e.mapPos(i);
  }
}), en = /* @__PURE__ */ Ge.define({
  create() {
    return null;
  },
  update(i, e) {
    return i != null && (i = e.changes.mapPos(i)), e.effects.reduce((t, r) => r.is(SS) ? r.value : t, i);
  }
}), R$ = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.view = i, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(i) {
    var e;
    let t = i.state.field(en);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (i.startState.field(en) != t || i.docChanged || i.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: i } = this, e = i.state.field(en), t = e != null && i.coordsAtPos(e);
    if (!t)
      return null;
    let r = i.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + i.scrollDOM.scrollLeft * i.scaleX,
      top: t.top - r.top + i.scrollDOM.scrollTop * i.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(i) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      i ? (this.cursor.style.left = i.left / e + "px", this.cursor.style.top = i.top / t + "px", this.cursor.style.height = i.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(i) {
    this.view.state.field(en) != i && this.view.dispatch({ effects: SS.of(i) });
  }
}, {
  eventObservers: {
    dragover(i) {
      this.setDropPos(this.view.posAtCoords({ x: i.clientX, y: i.clientY }));
    },
    dragleave(i) {
      (i.target == this.view.contentDOM || !this.view.contentDOM.contains(i.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function E$() {
  return [en, R$];
}
function cp(i, e, t, r, s) {
  e.lastIndex = 0;
  for (let n = i.iterRange(t, r), o = t, a; !n.next().done; o += n.value.length)
    if (!n.lineBreak)
      for (; a = e.exec(n.value); )
        s(o + a.index, a);
}
function A$(i, e) {
  let t = i.visibleRanges;
  if (t.length == 1 && t[0].from == i.viewport.from && t[0].to == i.viewport.to)
    return t;
  let r = [];
  for (let { from: s, to: n } of t)
    s = Math.max(i.state.doc.lineAt(s).from, s - e), n = Math.min(i.state.doc.lineAt(n).to, n + e), r.length && r[r.length - 1].to >= s ? r[r.length - 1].to = n : r.push({ from: s, to: n });
  return r;
}
class L$ {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: s, boundary: n, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, s)
      this.addMatch = (a, l, c, h) => s(h, c, c + a[0].length, a, l);
    else if (typeof r == "function")
      this.addMatch = (a, l, c, h) => {
        let f = r(a, l, c);
        f && h(c, c + a[0].length, f);
      };
    else if (r)
      this.addMatch = (a, l, c, h) => h(c, c + a[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = n, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Ii(), r = t.add.bind(t);
    for (let { from: s, to: n } of A$(e, this.maxLength))
      cp(e.state.doc, this.regexp, s, n, (o, a) => this.addMatch(a, e, o, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, s = -1;
    return e.docChanged && e.changes.iterChanges((n, o, a, l) => {
      l >= e.view.viewport.from && a <= e.view.viewport.to && (r = Math.min(a, r), s = Math.max(l, s));
    }), e.viewportMoved || s - r > 1e3 ? this.createDeco(e.view) : s > -1 ? this.updateRange(e.view, t.map(e.changes), r, s) : t;
  }
  updateRange(e, t, r, s) {
    for (let n of e.visibleRanges) {
      let o = Math.max(n.from, r), a = Math.min(n.to, s);
      if (a >= o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, h = Math.max(n.from, l.from), f = Math.min(n.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              h = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              f = a;
              break;
            }
        }
        let u = [], g, S = (v, d, O) => u.push(O.range(v, d));
        if (l == c)
          for (this.regexp.lastIndex = h - l.from; (g = this.regexp.exec(l.text)) && g.index < f - l.from; )
            this.addMatch(g, e, g.index + l.from, S);
        else
          cp(e.state.doc, this.regexp, h, f, (v, d) => this.addMatch(d, e, v, S));
        t = t.update({ filterFrom: h, filterTo: f, filter: (v, d) => v < h || d > f, add: u });
      }
    }
    return t;
  }
}
const Of = /x/.unicode != null ? "gu" : "g", M$ = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Of), D$ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let _c = null;
function q$() {
  var i;
  if (_c == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    _c = ((i = e.tabSize) !== null && i !== void 0 ? i : e.MozTabSize) != null;
  }
  return _c || !1;
}
const pa = /* @__PURE__ */ ee.define({
  combine(i) {
    let e = xi(i, {
      render: null,
      specialChars: M$,
      addSpecialChars: null
    });
    return (e.replaceTabs = !q$()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Of)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Of)), e;
  }
});
function B$(i = {}) {
  return [pa.of(i), X$()];
}
let hp = null;
function X$() {
  return hp || (hp = Ue.fromClass(class {
    constructor(i) {
      this.view = i, this.decorations = ae.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(i.state.facet(pa)), this.decorations = this.decorator.createDeco(i);
    }
    makeDecorator(i) {
      return new L$({
        regexp: i.specialChars,
        decoration: (e, t, r) => {
          let { doc: s } = t.state, n = vt(e[0], 0);
          if (n == 9) {
            let o = s.lineAt(r), a = t.state.tabSize, l = Nt(o.text, a, r - o.from);
            return ae.replace({
              widget: new z$((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[n] || (this.decorationCache[n] = ae.replace({ widget: new W$(i, n) }));
        },
        boundary: i.replaceTabs ? void 0 : /[^]/
      });
    }
    update(i) {
      let e = i.state.facet(pa);
      i.startState.facet(pa) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(i.view)) : this.decorations = this.decorator.updateDeco(i, this.decorations);
    }
  }, {
    decorations: (i) => i.decorations
  }));
}
const I$ = "•";
function Z$(i) {
  return i >= 32 ? I$ : i == 10 ? "␤" : String.fromCharCode(9216 + i);
}
class W$ extends ji {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = Z$(this.code), r = e.state.phrase("Control character") + " " + (D$[this.code] || "0x" + this.code.toString(16)), s = this.options.render && this.options.render(this.code, r, t);
    if (s)
      return s;
    let n = document.createElement("span");
    return n.textContent = t, n.title = r, n.setAttribute("aria-label", r), n.className = "cm-specialChar", n;
  }
  ignoreEvent() {
    return !1;
  }
}
class z$ extends ji {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function V$() {
  return j$;
}
const U$ = /* @__PURE__ */ ae.line({ class: "cm-activeLine" }), j$ = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.docChanged || i.selectionSet) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = -1, t = [];
    for (let r of i.state.selection.ranges) {
      let s = i.lineBlockAt(r.head);
      s.from > e && (t.push(U$.range(s.from)), e = s.from);
    }
    return ae.set(t);
  }
}, {
  decorations: (i) => i.decorations
}), pf = 2e3;
function N$(i, e, t) {
  let r = Math.min(e.line, t.line), s = Math.max(e.line, t.line), n = [];
  if (e.off > pf || t.off > pf || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), a = Math.max(e.off, t.off);
    for (let l = r; l <= s; l++) {
      let c = i.doc.line(l);
      c.length <= a && n.push(V.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, t.col), a = Math.max(e.col, t.col);
    for (let l = r; l <= s; l++) {
      let c = i.doc.line(l), h = jh(c.text, o, i.tabSize, !0);
      if (h < 0)
        n.push(V.cursor(c.to));
      else {
        let f = jh(c.text, a, i.tabSize);
        n.push(V.range(c.from + h, c.from + f));
      }
    }
  }
  return n;
}
function Y$(i, e) {
  let t = i.coordsAtPos(i.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / i.defaultCharacterWidth)) : -1;
}
function fp(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = i.state.doc.lineAt(t), s = t - r.from, n = s > pf ? -1 : s == r.length ? Y$(i, e.clientX) : Nt(r.text, i.state.tabSize, t - r.from);
  return { line: r.number, col: n, off: s };
}
function F$(i, e) {
  let t = fp(i, e), r = i.state.selection;
  return t ? {
    update(s) {
      if (s.docChanged) {
        let n = s.changes.mapPos(s.startState.doc.line(t.line).from), o = s.state.doc.lineAt(n);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, r = r.map(s.changes);
      }
    },
    get(s, n, o) {
      let a = fp(i, s);
      if (!a)
        return r;
      let l = N$(i.state, t, a);
      return l.length ? o ? V.create(l.concat(r.ranges)) : V.create(l) : r;
    }
  } : null;
}
function H$(i) {
  let e = (t) => t.altKey && t.button == 0;
  return K.mouseSelectionStyle.of((t, r) => e(r) ? F$(t, r) : null);
}
const G$ = {
  Alt: [18, (i) => !!i.altKey],
  Control: [17, (i) => !!i.ctrlKey],
  Shift: [16, (i) => !!i.shiftKey],
  Meta: [91, (i) => !!i.metaKey]
}, K$ = { style: "cursor: crosshair" };
function J$(i = {}) {
  let [e, t] = G$[i.key || "Alt"], r = Ue.fromClass(class {
    constructor(s) {
      this.view = s, this.isDown = !1;
    }
    set(s) {
      this.isDown != s && (this.isDown = s, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(s) {
        this.set(s.keyCode == e || t(s));
      },
      keyup(s) {
        (s.keyCode == e || !t(s)) && this.set(!1);
      },
      mousemove(s) {
        this.set(t(s));
      }
    }
  });
  return [
    r,
    K.contentAttributes.of((s) => {
      var n;
      return !((n = s.plugin(r)) === null || n === void 0) && n.isDown ? K$ : null;
    })
  ];
}
const Is = "-10000px";
class _S {
  constructor(e, t, r, s) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = s, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let n = null;
    this.tooltipViews = this.tooltips.map((o) => n = r(o, n));
  }
  update(e, t) {
    var r;
    let s = e.state.facet(this.facet), n = s.filter((l) => l);
    if (s === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = t ? [] : null;
    for (let l = 0; l < n.length; l++) {
      let c = n[l], h = -1;
      if (c) {
        for (let f = 0; f < this.tooltips.length; f++) {
          let u = this.tooltips[f];
          u && u.create == c.create && (h = f);
        }
        if (h < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let f = o[l] = this.tooltipViews[h];
          a && (a[l] = t[h]), f.update && f.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return t && (a.forEach((l, c) => t[c] = l), t.length = a.length), this.input = s, this.tooltips = n, this.tooltipViews = o, !0;
  }
}
function eT(i) {
  let e = i.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const bc = /* @__PURE__ */ ee.define({
  combine: (i) => {
    var e, t, r;
    return {
      position: re.ios ? "absolute" : ((e = i.find((s) => s.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = i.find((s) => s.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = i.find((s) => s.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || eT
    };
  }
}), up = /* @__PURE__ */ new WeakMap(), Lu = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.view = i, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = i.state.facet(bc);
    this.position = e.position, this.parent = e.parent, this.classes = i.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new _S(i, Mu, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), i.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let i of this.manager.tooltipViews)
        this.intersectionObserver.observe(i.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(i) {
    i.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(i, this.above);
    e && this.observeIntersection();
    let t = e || i.geometryChanged, r = i.state.facet(bc);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(i, e) {
    let t = i.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), i.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", t.dom.appendChild(s);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Is, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var i, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (i = r.destroy) === null || i === void 0 || i.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let i = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (re.gecko)
        t = n.offsetParent != this.container.ownerDocument.body;
      else if (n.style.top == Is && n.style.left == "0px") {
        let o = n.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (i = n.width / this.parent.offsetWidth, e = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: i, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), s = Tu(this.view);
    return {
      visible: {
        left: r.left + s.left,
        top: r.top + s.top,
        right: r.right - s.right,
        bottom: r.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((n, o) => {
        let a = this.manager.tooltipViews[o];
        return a.getCoords ? a.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(bc).tooltipSpace(this.view),
      scaleX: i,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(i) {
    var e;
    if (i.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: t, space: r, scaleX: s, scaleY: n } = i, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: h } = c, f = i.pos[a], u = i.size[a];
      if (!f || l.clip !== !1 && (f.bottom <= Math.max(t.top, r.top) || f.top >= Math.min(t.bottom, r.bottom) || f.right < Math.max(t.left, r.left) - 0.1 || f.left > Math.min(t.right, r.right) + 0.1)) {
        h.style.top = Is;
        continue;
      }
      let g = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, S = g ? 7 : 0, v = u.right - u.left, d = (e = up.get(c)) !== null && e !== void 0 ? e : u.bottom - u.top, O = c.offset || iT, p = this.view.textDirection == Me.LTR, m = u.width > r.right - r.left ? p ? r.left : r.right - u.width : p ? Math.max(r.left, Math.min(f.left - (g ? 14 : 0) + O.x, r.right - v)) : Math.min(Math.max(r.left, f.left - v + (g ? 14 : 0) - O.x), r.right - v), _ = this.above[a];
      !l.strictSide && (_ ? f.top - d - S - O.y < r.top : f.bottom + d + S + O.y > r.bottom) && _ == r.bottom - f.bottom > f.top - r.top && (_ = this.above[a] = !_);
      let b = (_ ? f.top - r.top : r.bottom - f.bottom) - S;
      if (b < d && c.resize !== !1) {
        if (b < this.view.defaultLineHeight) {
          h.style.top = Is;
          continue;
        }
        up.set(c, d), h.style.height = (d = b) / n + "px";
      } else h.style.height && (h.style.height = "");
      let w = _ ? f.top - d - S - O.y : f.bottom + S + O.y, x = m + v;
      if (c.overlap !== !0)
        for (let y of o)
          y.left < x && y.right > m && y.top < w + d && y.bottom > w && (w = _ ? y.top - d - 2 - S : y.bottom + S + 2);
      if (this.position == "absolute" ? (h.style.top = (w - i.parent.top) / n + "px", dp(h, (m - i.parent.left) / s)) : (h.style.top = w / n + "px", dp(h, m / s)), g) {
        let y = f.left + (p ? O.x : -O.x) - (m + 14 - 7);
        g.style.left = y / s + "px";
      }
      c.overlap !== !0 && o.push({ left: m, top: w, right: x, bottom: w + d }), h.classList.toggle("cm-tooltip-above", _), h.classList.toggle("cm-tooltip-below", !_), c.positioned && c.positioned(i.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let i of this.manager.tooltipViews)
        i.dom.style.top = Is;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function dp(i, e) {
  let t = parseInt(i.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (i.style.left = e + "px");
}
const tT = /* @__PURE__ */ K.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), iT = { x: 0, y: 0 }, Mu = /* @__PURE__ */ ee.define({
  enables: [Lu, tT]
}), Na = /* @__PURE__ */ ee.define({
  combine: (i) => i.reduce((e, t) => e.concat(t), [])
});
class Ml {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Ml(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new _S(e, Na, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let s = r[e];
      if (s !== void 0) {
        if (t === void 0)
          t = s;
        else if (t !== s)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const rT = /* @__PURE__ */ Mu.compute([Na], (i) => {
  let e = i.facet(Na);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: Ml.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class sT {
  constructor(e, t, r, s, n) {
    this.view = e, this.source = t, this.field = r, this.setHover = s, this.hoverTime = n, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let s, n = 1;
    if (r instanceof er)
      s = r.posAtStart;
    else {
      if (s = e.posAtCoords(t), s == null)
        return;
      let a = e.coordsAtPos(s);
      if (!a || t.y < a.top || t.y > a.bottom || t.x < a.left - e.defaultCharacterWidth || t.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(s)).find((h) => h.from <= s && h.to >= s), c = l && l.dir == Me.RTL ? -1 : 1;
      n = t.x < a.left ? -c : c;
    }
    let o = this.source(e, s, n);
    if (o?.then) {
      let a = this.pending = { pos: s };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => bt(e.state, l, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(Lu), t = e ? e.manager.tooltips.findIndex((r) => r.create == Ml.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: s, tooltip: n } = this;
    if (s.length && n && !nT(n.dom, e) || this.pending) {
      let { pos: o } = s[0] || this.pending, a = (r = (t = s[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !oT(this.view, o, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Xo = 4;
function nT(i, e) {
  let { left: t, right: r, top: s, bottom: n } = i.getBoundingClientRect(), o;
  if (o = i.querySelector(".cm-tooltip-arrow")) {
    let a = o.getBoundingClientRect();
    s = Math.min(a.top, s), n = Math.max(a.bottom, n);
  }
  return e.clientX >= t - Xo && e.clientX <= r + Xo && e.clientY >= s - Xo && e.clientY <= n + Xo;
}
function oT(i, e, t, r, s, n) {
  let o = i.scrollDOM.getBoundingClientRect(), a = i.documentTop + i.documentPadding.top + i.contentHeight;
  if (o.left > r || o.right < r || o.top > s || Math.min(o.bottom, a) < s)
    return !1;
  let l = i.posAtCoords({ x: r, y: s }, !1);
  return l >= e && l <= t;
}
function aT(i, e = {}) {
  let t = he.define(), r = Ge.define({
    create() {
      return [];
    },
    update(s, n) {
      if (s.length && (e.hideOnChange && (n.docChanged || n.selection) ? s = [] : e.hideOn && (s = s.filter((o) => !e.hideOn(n, o))), n.docChanged)) {
        let o = [];
        for (let a of s) {
          let l = n.changes.mapPos(a.pos, -1, tt.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = l, c.end != null && (c.end = n.changes.mapPos(c.end)), o.push(c);
          }
        }
        s = o;
      }
      for (let o of n.effects)
        o.is(t) && (s = o.value), o.is(lT) && (s = []);
      return s;
    },
    provide: (s) => Na.from(s)
  });
  return {
    active: r,
    extension: [
      r,
      Ue.define((s) => new sT(
        s,
        i,
        r,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      rT
    ]
  };
}
function bS(i, e) {
  let t = i.plugin(Lu);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const lT = /* @__PURE__ */ he.define(), Op = /* @__PURE__ */ ee.define({
  combine(i) {
    let e, t;
    for (let r of i)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Mn(i, e) {
  let t = i.plugin(yS), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const yS = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.input = i.state.facet(Dn), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(i));
    let e = i.state.facet(Op);
    this.top = new Io(i, !0, e.topContainer), this.bottom = new Io(i, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(i) {
    let e = i.state.facet(Op);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Io(i.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Io(i.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = i.state.facet(Dn);
    if (t != this.input) {
      let r = t.filter((l) => l), s = [], n = [], o = [], a = [];
      for (let l of r) {
        let c = this.specs.indexOf(l), h;
        c < 0 ? (h = l(i.view), a.push(h)) : (h = this.panels[c], h.update && h.update(i)), s.push(h), (h.top ? n : o).push(h);
      }
      this.specs = r, this.panels = s, this.top.sync(n), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(i);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (i) => K.scrollMargins.of((e) => {
    let t = e.plugin(i);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class Io {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = pp(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = pp(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function pp(i) {
  let e = i.nextSibling;
  return i.remove(), e;
}
const Dn = /* @__PURE__ */ ee.define({
  enables: yS
});
class Wi extends Lr {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Wi.prototype.elementClass = "";
Wi.prototype.toDOM = void 0;
Wi.prototype.mapMode = tt.TrackBefore;
Wi.prototype.startSide = Wi.prototype.endSide = -1;
Wi.prototype.point = !0;
const ga = /* @__PURE__ */ ee.define(), cT = /* @__PURE__ */ ee.define(), hT = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => ye.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, cn = /* @__PURE__ */ ee.define();
function fT(i) {
  return [wS(), cn.of({ ...hT, ...i })];
}
const gp = /* @__PURE__ */ ee.define({
  combine: (i) => i.some((e) => e)
});
function wS(i) {
  return [
    uT
  ];
}
const uT = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.view = i, this.prevViewport = i.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = i.state.facet(cn).map((e) => new vp(i, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !i.state.facet(gp), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), i.scrollDOM.insertBefore(this.dom, i.contentDOM);
  }
  update(i) {
    if (this.updateGutters(i)) {
      let e = this.prevViewport, t = i.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    i.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(gp) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = i.view.viewport;
  }
  syncGutters(i) {
    let e = this.dom.nextSibling;
    i && this.dom.remove();
    let t = ye.iter(this.view.state.facet(ga), this.view.viewport.from), r = [], s = this.gutters.map((n) => new dT(n, this.view.viewport, -this.view.documentPadding.top));
    for (let n of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(n.type)) {
        let o = !0;
        for (let a of n.type)
          if (a.type == dt.Text && o) {
            gf(t, r, a.from);
            for (let l of s)
              l.line(this.view, a, r);
            o = !1;
          } else if (a.widget)
            for (let l of s)
              l.widget(this.view, a);
      } else if (n.type == dt.Text) {
        gf(t, r, n.from);
        for (let o of s)
          o.line(this.view, n, r);
      } else if (n.widget)
        for (let o of s)
          o.widget(this.view, n);
    for (let n of s)
      n.finish();
    i && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(i) {
    let e = i.startState.facet(cn), t = i.state.facet(cn), r = i.docChanged || i.heightChanged || i.viewportChanged || !ye.eq(i.startState.facet(ga), i.state.facet(ga), i.view.viewport.from, i.view.viewport.to);
    if (e == t)
      for (let s of this.gutters)
        s.update(i) && (r = !0);
    else {
      r = !0;
      let s = [];
      for (let n of t) {
        let o = e.indexOf(n);
        o < 0 ? s.push(new vp(this.view, n)) : (this.gutters[o].update(i), s.push(this.gutters[o]));
      }
      for (let n of this.gutters)
        n.dom.remove(), s.indexOf(n) < 0 && n.destroy();
      for (let n of s)
        this.dom.appendChild(n.dom);
      this.gutters = s;
    }
    return r;
  }
  destroy() {
    for (let i of this.gutters)
      i.destroy();
    this.dom.remove();
  }
}, {
  provide: (i) => K.scrollMargins.of((e) => {
    let t = e.plugin(i);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Me.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function mp(i) {
  return Array.isArray(i) ? i : [i];
}
function gf(i, e, t) {
  for (; i.value && i.from <= t; )
    i.from == t && e.push(i.value), i.next();
}
class dT {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = ye.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: s } = this, n = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == s.elements.length) {
      let a = new xS(e, o, n, r);
      s.elements.push(a), s.dom.appendChild(a.dom);
    } else
      s.elements[this.i].update(e, o, n, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let s = [];
    gf(this.cursor, s, t.from), r.length && (s = s.concat(r));
    let n = this.gutter.config.lineMarker(e, t, s);
    n && s.unshift(n);
    let o = this.gutter;
    s.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, s);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t), s = r ? [r] : null;
    for (let n of e.state.facet(cT)) {
      let o = n(e, t.widget, t);
      o && (s || (s = [])).push(o);
    }
    s && this.addElement(e, t, s);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class vp {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (s) => {
        let n = s.target, o;
        if (n != this.dom && this.dom.contains(n)) {
          for (; n.parentNode != this.dom; )
            n = n.parentNode;
          let l = n.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = s.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[r](e, a, s) && s.preventDefault();
      });
    this.markers = mp(t.markers(e)), t.initialSpacer && (this.spacer = new xS(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = mp(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let s = this.config.updateSpacer(this.spacer.markers[0], e);
      s != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [s]);
    }
    let r = e.view.viewport;
    return !ye.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class xS {
  constructor(e, t, r, s) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, s);
  }
  update(e, t, r, s) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), OT(this.markers, s) || this.setMarkers(e, s);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", s = this.dom.firstChild;
    for (let n = 0, o = 0; ; ) {
      let a = o, l = n < t.length ? t[n++] : null, c = !1;
      if (l) {
        let h = l.elementClass;
        h && (r += " " + h);
        for (let f = o; f < this.markers.length; f++)
          if (this.markers[f].compare(l)) {
            a = f, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let h = this.markers[o++];
        if (h.toDOM) {
          h.destroy(s);
          let f = s.nextSibling;
          s.remove(), s = f;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? s = s.nextSibling : this.dom.insertBefore(l.toDOM(e), s)), c && o++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function OT(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (!i[t].compare(e[t]))
      return !1;
  return !0;
}
const pT = /* @__PURE__ */ ee.define(), gT = /* @__PURE__ */ ee.define(), Kr = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let s in t) {
          let n = r[s], o = t[s];
          r[s] = n ? (a, l, c) => n(a, l, c) || o(a, l, c) : o;
        }
        return r;
      }
    });
  }
});
class yc extends Wi {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function wc(i, e) {
  return i.state.facet(Kr).formatNumber(e, i.state);
}
const mT = /* @__PURE__ */ cn.compute([Kr], (i) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(pT);
  },
  lineMarker(e, t, r) {
    return r.some((s) => s.toDOM) ? null : new yc(wc(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, r) => {
    for (let s of e.state.facet(gT)) {
      let n = s(e, t, r);
      if (n)
        return n;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Kr) != e.state.facet(Kr),
  initialSpacer(e) {
    return new yc(wc(e, Sp(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = wc(t.view, Sp(t.view.state.doc.lines));
    return r == e.number ? e : new yc(r);
  },
  domEventHandlers: i.facet(Kr).domEventHandlers
}));
function vT(i = {}) {
  return [
    Kr.of(i),
    wS(),
    mT
  ];
}
function Sp(i) {
  let e = 9;
  for (; e < i; )
    e = e * 10 + 9;
  return e;
}
const ST = /* @__PURE__ */ new class extends Wi {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), _T = /* @__PURE__ */ ga.compute(["selection"], (i) => {
  let e = [], t = -1;
  for (let r of i.selection.ranges) {
    let s = i.doc.lineAt(r.head).from;
    s > t && (t = s, e.push(ST.range(s)));
  }
  return ye.of(e);
});
function bT() {
  return _T;
}
const kS = 1024;
let yT = 0;
class Mt {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class le {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = yT++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Ne.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
le.closedBy = new le({ deserialize: (i) => i.split(" ") });
le.openedBy = new le({ deserialize: (i) => i.split(" ") });
le.group = new le({ deserialize: (i) => i.split(" ") });
le.isolate = new le({ deserialize: (i) => {
  if (i && i != "rtl" && i != "ltr" && i != "auto")
    throw new RangeError("Invalid value for isolate: " + i);
  return i || "auto";
} });
le.contextHash = new le({ perNode: !0 });
le.lookAhead = new le({ perNode: !0 });
le.mounted = new le({ perNode: !0 });
class qn {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[le.mounted.id];
  }
}
const wT = /* @__PURE__ */ Object.create(null);
class Ne {
  /**
  @internal
  */
  constructor(e, t, r, s = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : wT, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), s = new Ne(e.name || "", t, e.id, r);
    if (e.props) {
      for (let n of e.props)
        if (Array.isArray(n) || (n = n(s)), n) {
          if (n[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[n[0].id] = n[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(le.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let s of r.split(" "))
        t[s] = e[r];
    return (r) => {
      for (let s = r.prop(le.group), n = -1; n < (s ? s.length : 0); n++) {
        let o = t[n < 0 ? r.name : s[n]];
        if (o)
          return o;
      }
    };
  }
}
Ne.none = new Ne(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Oo {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let s = null;
      for (let n of e) {
        let o = n(r);
        o && (s || (s = Object.assign({}, r.props)), s[o[0].id] = o[1]);
      }
      t.push(s ? new Ne(r.name, s, r.id, r.flags) : r);
    }
    return new Oo(t);
  }
}
const Zo = /* @__PURE__ */ new WeakMap(), _p = /* @__PURE__ */ new WeakMap();
var Te;
(function(i) {
  i[i.ExcludeBuffers = 1] = "ExcludeBuffers", i[i.IncludeAnonymous = 2] = "IncludeAnonymous", i[i.IgnoreMounts = 4] = "IgnoreMounts", i[i.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Te || (Te = {}));
class xe {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, s, n) {
    if (this.type = e, this.children = t, this.positions = r, this.length = s, this.props = null, n && n.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of n)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = qn.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let s = r.toString();
      s && (t && (t += ","), t += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Ya(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let s = Zo.get(this) || this.topNode, n = new Ya(s);
    return n.moveTo(e, t), Zo.set(this, n._tree), n;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new ht(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = Bn(Zo.get(this) || this.topNode, e, t, !1);
    return Zo.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = Bn(_p.get(this) || this.topNode, e, t, !0);
    return _p.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return CT(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: s = 0, to: n = this.length } = e, o = e.mode || 0, a = (o & Te.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Te.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= n && l.to >= s && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Bu(Ne.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, s) => new xe(this.type, t, r, s, this.propValues), e.makeTree || ((t, r, s) => new xe(Ne.none, t, r, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return QT(e);
  }
}
xe.empty = new xe(Ne.none, [], [], 0);
class Du {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Du(this.buffer, this.index);
  }
}
class lr {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Ne.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], s = this.set.types[t], n = s.name;
    if (/\W/.test(n) && !s.isError && (n = JSON.stringify(n)), e += 4, r == e)
      return n;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return n + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, s, n) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != t && !(CS(n, s, o[l + 1], o[l + 2]) && (a = l, r > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let s = this.buffer, n = new Uint16Array(t - e), o = 0;
    for (let a = e, l = 0; a < t; ) {
      n[l++] = s[a++], n[l++] = s[a++] - r;
      let c = n[l++] = s[a++] - r;
      n[l++] = s[a++] - e, o = Math.max(o, c);
    }
    return new lr(n, o, this.set);
  }
}
function CS(i, e, t, r) {
  switch (i) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function Bn(i, e, t, r) {
  for (var s; i.from == i.to || (t < 1 ? i.from >= e : i.from > e) || (t > -1 ? i.to <= e : i.to < e); ) {
    let o = !r && i instanceof ht && i.index < 0 ? null : i.parent;
    if (!o)
      return i;
    i = o;
  }
  let n = r ? 0 : Te.IgnoreOverlays;
  if (r)
    for (let o = i, a = o.parent; a; o = a, a = o.parent)
      o instanceof ht && o.index < 0 && ((s = a.enter(e, t, n)) === null || s === void 0 ? void 0 : s.from) != o.from && (i = a);
  for (; ; ) {
    let o = i.enter(e, t, n);
    if (!o)
      return i;
    i = o;
  }
}
class QS {
  cursor(e = 0) {
    return new Ya(this, e);
  }
  getChild(e, t = null, r = null) {
    let s = bp(this, e, t, r);
    return s.length ? s[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return bp(this, e, t, r);
  }
  resolve(e, t = 0) {
    return Bn(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Bn(this, e, t, !0);
  }
  matchContext(e) {
    return mf(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let s = t.lastChild;
      if (!s || s.to != t.to)
        break;
      s.type.isError && s.from == s.to ? (r = t, t = s.prevSibling) : t = s;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class ht extends QS {
  constructor(e, t, r, s) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, s, n = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = t > 0 ? a.length : -1; e != c; e += t) {
        let h = a[e], f = l[e] + o.from;
        if (CS(s, r, f, f + h.length)) {
          if (h instanceof lr) {
            if (n & Te.ExcludeBuffers)
              continue;
            let u = h.findChild(0, h.buffer.length, t, r - f, s);
            if (u > -1)
              return new ui(new xT(o, h, e, f), null, u);
          } else if (n & Te.IncludeAnonymous || !h.type.isAnonymous || qu(h)) {
            let u;
            if (!(n & Te.IgnoreMounts) && (u = qn.get(h)) && !u.overlay)
              return new ht(u.tree, f, e, o);
            let g = new ht(h, f, e, o);
            return n & Te.IncludeAnonymous || !g.type.isAnonymous ? g : g.nextChild(t < 0 ? h.children.length - 1 : 0, t, r, s);
          }
        }
      }
      if (n & Te.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let s;
    if (!(r & Te.IgnoreOverlays) && (s = qn.get(this._tree)) && s.overlay) {
      let n = e - this.from;
      for (let { from: o, to: a } of s.overlay)
        if ((t > 0 ? o <= n : o < n) && (t < 0 ? a >= n : a > n))
          return new ht(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function bp(i, e, t, r) {
  let s = i.cursor(), n = [];
  if (!s.firstChild())
    return n;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = s.type.is(t), !s.nextSibling())
        return n;
  }
  for (; ; ) {
    if (r != null && s.type.is(r))
      return n;
    if (s.type.is(e) && n.push(s.node), !s.nextSibling())
      return r == null ? n : [];
  }
}
function mf(i, e, t = e.length - 1) {
  for (let r = i; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class xT {
  constructor(e, t, r, s) {
    this.parent = e, this.buffer = t, this.index = r, this.start = s;
  }
}
class ui extends QS {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: s } = this.context, n = s.findChild(this.index + 4, s.buffer[this.index + 3], e, t - this.context.start, r);
    return n < 0 ? null : new ui(this.context, this, n);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Te.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, n = s.findChild(this.index + 4, s.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return n < 0 ? null : new ui(this.context, this, n);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new ui(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new ui(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, s = this.index + 4, n = r.buffer[this.index + 3];
    if (n > s) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(s, n, o)), t.push(0);
    }
    return new xe(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function PS(i) {
  if (!i.length)
    return null;
  let e = 0, t = i[0];
  for (let n = 1; n < i.length; n++) {
    let o = i[n];
    (o.from > t.from || o.to < t.to) && (t = o, e = n);
  }
  let r = t instanceof ht && t.index < 0 ? null : t.parent, s = i.slice();
  return r ? s[e] = r : s.splice(e, 1), new kT(s, t);
}
class kT {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return PS(this.heads);
  }
}
function CT(i, e, t) {
  let r = i.resolveInner(e, t), s = null;
  for (let n = r instanceof ht ? r : r.context.parent; n; n = n.parent)
    if (n.index < 0) {
      let o = n.parent;
      (s || (s = [r])).push(o.resolve(e, t)), n = o;
    } else {
      let o = qn.get(n.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new ht(o.tree, o.overlay[0].from + n.from, -1, n);
        (s || (s = [r])).push(Bn(a, e, t, !1));
      }
    }
  return s ? PS(s) : r;
}
class Ya {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof ht)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: s } = this.buffer;
    return this.type = t || s.set.types[s.buffer[e]], this.from = r + s.buffer[e + 1], this.to = r + s.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof ht ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: s } = this.buffer, n = s.findChild(this.index + 4, s.buffer[this.index + 3], e, t - this.buffer.start, r);
    return n < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(n));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Te.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Te.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Te.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let s = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != s)
        return this.yieldBuf(t.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = t.buffer[this.index + 3];
      if (s < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(s);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: s } = this;
    if (s) {
      if (e > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let n = 0; n < this.index; n++)
          if (s.buffer.buffer[n + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = s);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let n = t + e, o = e < 0 ? -1 : r._tree.children.length; n != o; n += e) {
          let a = r._tree.children[n];
          if (this.mode & Te.IncludeAnonymous || a instanceof lr || !a.type.isAnonymous || qu(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let s = this.index, n = this.stack.length; n >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == s) {
            if (s == this.index)
              return o;
            t = o, r = n + 1;
            break e;
          }
        s = this.stack[--n];
      }
    for (let s = r; s < this.stack.length; s++)
      t = new ui(this.buffer, t, this.stack[s]);
    return this.bufferNode = new ui(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && t && t(this), s = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return mf(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let s = e.length - 1, n = this.stack.length - 1; s >= 0; n--) {
      if (n < 0)
        return mf(this._tree, e, s);
      let o = r[t.buffer[this.stack[n]]];
      if (!o.isAnonymous) {
        if (e[s] && e[s] != o.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}
function qu(i) {
  return i.children.some((e) => e instanceof lr || !e.type.isAnonymous || qu(e));
}
function QT(i) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: s = kS, reused: n = [], minRepeatType: o = r.types.length } = i, a = Array.isArray(t) ? new Du(t, t.length) : t, l = r.types, c = 0, h = 0;
  function f(b, w, x, y, k, T) {
    let { id: R, start: $, end: E, size: D } = a, q = h, W = c;
    for (; D < 0; )
      if (a.next(), D == -1) {
        let M = n[R];
        x.push(M), y.push($ - b);
        return;
      } else if (D == -3) {
        c = R;
        return;
      } else if (D == -4) {
        h = R;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${D}`);
    let z = l[R], Q, A, L = $ - b;
    if (E - $ <= s && (A = d(a.pos - w, k))) {
      let M = new Uint16Array(A.size - A.skip), U = a.pos - A.size, F = M.length;
      for (; a.pos > U; )
        F = O(A.start, M, F);
      Q = new lr(M, E - A.start, r), L = A.start - b;
    } else {
      let M = a.pos - D;
      a.next();
      let U = [], F = [], ne = R >= o ? R : -1, te = 0, de = E;
      for (; a.pos > M; )
        ne >= 0 && a.id == ne && a.size >= 0 ? (a.end <= de - s && (S(U, F, $, te, a.end, de, ne, q, W), te = U.length, de = a.end), a.next()) : T > 2500 ? u($, M, U, F) : f($, M, U, F, ne, T + 1);
      if (ne >= 0 && te > 0 && te < U.length && S(U, F, $, te, $, de, ne, q, W), U.reverse(), F.reverse(), ne > -1 && te > 0) {
        let P = g(z, W);
        Q = Bu(z, U, F, 0, U.length, 0, E - $, P, P);
      } else
        Q = v(z, U, F, E - $, q - E, W);
    }
    x.push(Q), y.push(L);
  }
  function u(b, w, x, y) {
    let k = [], T = 0, R = -1;
    for (; a.pos > w; ) {
      let { id: $, start: E, end: D, size: q } = a;
      if (q > 4)
        a.next();
      else {
        if (R > -1 && E < R)
          break;
        R < 0 && (R = D - s), k.push($, E, D), T++, a.next();
      }
    }
    if (T) {
      let $ = new Uint16Array(T * 4), E = k[k.length - 2];
      for (let D = k.length - 3, q = 0; D >= 0; D -= 3)
        $[q++] = k[D], $[q++] = k[D + 1] - E, $[q++] = k[D + 2] - E, $[q++] = q;
      x.push(new lr($, k[2] - E, r)), y.push(E - b);
    }
  }
  function g(b, w) {
    return (x, y, k) => {
      let T = 0, R = x.length - 1, $, E;
      if (R >= 0 && ($ = x[R]) instanceof xe) {
        if (!R && $.type == b && $.length == k)
          return $;
        (E = $.prop(le.lookAhead)) && (T = y[R] + $.length + E);
      }
      return v(b, x, y, k, T, w);
    };
  }
  function S(b, w, x, y, k, T, R, $, E) {
    let D = [], q = [];
    for (; b.length > y; )
      D.push(b.pop()), q.push(w.pop() + x - k);
    b.push(v(r.types[R], D, q, T - k, $ - T, E)), w.push(k - x);
  }
  function v(b, w, x, y, k, T, R) {
    if (T) {
      let $ = [le.contextHash, T];
      R = R ? [$].concat(R) : [$];
    }
    if (k > 25) {
      let $ = [le.lookAhead, k];
      R = R ? [$].concat(R) : [$];
    }
    return new xe(b, w, x, y, R);
  }
  function d(b, w) {
    let x = a.fork(), y = 0, k = 0, T = 0, R = x.end - s, $ = { size: 0, start: 0, skip: 0 };
    e: for (let E = x.pos - b; x.pos > E; ) {
      let D = x.size;
      if (x.id == w && D >= 0) {
        $.size = y, $.start = k, $.skip = T, T += 4, y += 4, x.next();
        continue;
      }
      let q = x.pos - D;
      if (D < 0 || q < E || x.start < R)
        break;
      let W = x.id >= o ? 4 : 0, z = x.start;
      for (x.next(); x.pos > q; ) {
        if (x.size < 0)
          if (x.size == -3)
            W += 4;
          else
            break e;
        else x.id >= o && (W += 4);
        x.next();
      }
      k = z, y += D, T += W;
    }
    return (w < 0 || y == b) && ($.size = y, $.start = k, $.skip = T), $.size > 4 ? $ : void 0;
  }
  function O(b, w, x) {
    let { id: y, start: k, end: T, size: R } = a;
    if (a.next(), R >= 0 && y < o) {
      let $ = x;
      if (R > 4) {
        let E = a.pos - (R - 4);
        for (; a.pos > E; )
          x = O(b, w, x);
      }
      w[--x] = $, w[--x] = T - b, w[--x] = k - b, w[--x] = y;
    } else R == -3 ? c = y : R == -4 && (h = y);
    return x;
  }
  let p = [], m = [];
  for (; a.pos > 0; )
    f(i.start || 0, i.bufferStart || 0, p, m, -1, 0);
  let _ = (e = i.length) !== null && e !== void 0 ? e : p.length ? m[0] + p[0].length : 0;
  return new xe(l[i.topID], p.reverse(), m.reverse(), _);
}
const yp = /* @__PURE__ */ new WeakMap();
function ma(i, e) {
  if (!i.isAnonymous || e instanceof lr || e.type != i)
    return 1;
  let t = yp.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != i || !(r instanceof xe)) {
        t = 1;
        break;
      }
      t += ma(i, r);
    }
    yp.set(e, t);
  }
  return t;
}
function Bu(i, e, t, r, s, n, o, a, l) {
  let c = 0;
  for (let S = r; S < s; S++)
    c += ma(i, e[S]);
  let h = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), f = [], u = [];
  function g(S, v, d, O, p) {
    for (let m = d; m < O; ) {
      let _ = m, b = v[m], w = ma(i, S[m]);
      for (m++; m < O; m++) {
        let x = ma(i, S[m]);
        if (w + x >= h)
          break;
        w += x;
      }
      if (m == _ + 1) {
        if (w > h) {
          let x = S[_];
          g(x.children, x.positions, 0, x.children.length, v[_] + p);
          continue;
        }
        f.push(S[_]);
      } else {
        let x = v[m - 1] + S[m - 1].length - b;
        f.push(Bu(i, S, v, _, m, b, x, null, l));
      }
      u.push(b + p - n);
    }
  }
  return g(e, t, r, s, 0), (a || l)(f, u, o);
}
class Xu {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let s = this.map.get(e);
    s || this.map.set(e, s = /* @__PURE__ */ new Map()), s.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof ui ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof ht && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof ui ? this.getBuffer(e.context.buffer, e.index) : e instanceof ht ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Bi {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, s, n = !1, o = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = s, this.open = (n ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let s = [new Bi(0, e.length, e, 0, !1, r)];
    for (let n of t)
      n.to > e.length && s.push(n);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let s = [], n = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let h = a < t.length ? t[a] : null, f = h ? h.fromA : 1e9;
      if (f - l >= r)
        for (; o && o.from < f; ) {
          let u = o;
          if (l >= u.from || f <= u.to || c) {
            let g = Math.max(u.from, l) - c, S = Math.min(u.to, f) - c;
            u = g >= S ? null : new Bi(g, S, u.tree, u.offset + c, a > 0, !!h);
          }
          if (u && s.push(u), o.to > f)
            break;
          o = n < e.length ? e[n++] : null;
        }
      if (!h)
        break;
      l = h.toA, c = h.toA - h.toB;
    }
    return s;
  }
}
class Iu {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new PT(e)), r = r ? r.length ? r.map((s) => new Mt(s.from, s.to)) : [new Mt(0, 0)] : [new Mt(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let s = this.startParse(e, t, r);
    for (; ; ) {
      let n = s.advance();
      if (n)
        return n;
    }
  }
}
class PT {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function $S(i) {
  return (e, t, r, s) => new TT(e, i, t, r, s);
}
class wp {
  constructor(e, t, r, s, n) {
    this.parser = e, this.parse = t, this.overlay = r, this.target = s, this.from = n;
  }
}
function xp(i) {
  if (!i.length || i.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(i));
}
class $T {
  constructor(e, t, r, s, n, o, a) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = s, this.start = n, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const vf = new le({ perNode: !0 });
class TT {
  constructor(e, t, r, s, n) {
    this.nest = t, this.input = r, this.fragments = s, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let s of this.inner)
          s.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new xe(r.type, r.children, r.positions, r.length, r.propValues.concat([[vf, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[le.mounted.id] = new qn(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new AT(this.fragments), t = null, r = null, s = new Ya(new ht(this.baseTree, this.ranges[0].from, 0, null), Te.IncludeAnonymous | Te.IgnoreMounts);
    e: for (let n, o; ; ) {
      let a = !0, l;
      if (this.stoppedAt != null && s.from >= this.stoppedAt)
        a = !1;
      else if (e.hasNode(s)) {
        if (t) {
          let c = t.mounts.find((h) => h.frag.from <= s.from && h.frag.to >= s.to && h.mount.overlay);
          if (c)
            for (let h of c.mount.overlay) {
              let f = h.from + c.pos, u = h.to + c.pos;
              f >= s.from && u <= s.to && !t.ranges.some((g) => g.from < u && g.to > f) && t.ranges.push({ from: f, to: u });
            }
        }
        a = !1;
      } else if (r && (o = RT(r.ranges, s.from, s.to)))
        a = o != 2;
      else if (!s.type.isAnonymous && (n = this.nest(s, this.input)) && (s.from < s.to || !n.overlay)) {
        s.tree || ET(s);
        let c = e.findMounts(s.from, n.parser);
        if (typeof n.overlay == "function")
          t = new $T(n.parser, n.overlay, c, this.inner.length, s.from, s.tree, t);
        else {
          let h = Qp(this.ranges, n.overlay || (s.from < s.to ? [new Mt(s.from, s.to)] : []));
          h.length && xp(h), (h.length || !n.overlay) && this.inner.push(new wp(n.parser, h.length ? n.parser.startParse(this.input, Pp(c, h), h) : n.parser.startParse(""), n.overlay ? n.overlay.map((f) => new Mt(f.from - s.from, f.to - s.from)) : null, s.tree, h.length ? h[0].from : s.from)), n.overlay ? h.length && (r = { ranges: h, depth: 0, prev: r }) : a = !1;
        }
      } else if (t && (l = t.predicate(s)) && (l === !0 && (l = new Mt(s.from, s.to)), l.from < l.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == l.from ? t.ranges[c] = { from: t.ranges[c].from, to: l.to } : t.ranges.push(l);
      }
      if (a && s.firstChild())
        t && t.depth++, r && r.depth++;
      else
        for (; !s.nextSibling(); ) {
          if (!s.parent())
            break e;
          if (t && !--t.depth) {
            let c = Qp(this.ranges, t.ranges);
            c.length && (xp(c), this.inner.splice(t.index, 0, new wp(t.parser, t.parser.startParse(this.input, Pp(t.mounts, c), c), t.ranges.map((h) => new Mt(h.from - t.start, h.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function RT(i, e, t) {
  for (let r of i) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function kp(i, e, t, r, s, n) {
  if (e < t) {
    let o = i.buffer[e + 1];
    r.push(i.slice(e, t, o)), s.push(o - n);
  }
}
function ET(i) {
  let { node: e } = i, t = [], r = e.context.buffer;
  do
    t.push(i.index), i.parent();
  while (!i.tree);
  let s = i.tree, n = s.children.indexOf(r), o = s.children[n], a = o.buffer, l = [n];
  function c(h, f, u, g, S, v) {
    let d = t[v], O = [], p = [];
    kp(o, h, d, O, p, g);
    let m = a[d + 1], _ = a[d + 2];
    l.push(O.length);
    let b = v ? c(d + 4, a[d + 3], o.set.types[a[d]], m, _ - m, v - 1) : e.toTree();
    return O.push(b), p.push(m - g), kp(o, a[d + 3], f, O, p, g), new xe(u, O, p, S);
  }
  s.children[n] = c(0, a.length, Ne.none, 0, o.length, t.length - 1);
  for (let h of l) {
    let f = i.tree.children[h], u = i.tree.positions[h];
    i.yield(new ht(f, u + i.from, h, i._tree));
  }
}
class Cp {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Te.IncludeAnonymous | Te.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, Te.IgnoreOverlays | Te.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof xe)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let AT = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(vf)) !== null && t !== void 0 ? t : r.to, this.inner = new Cp(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(vf)) !== null && e !== void 0 ? e : t.to, this.inner = new Cp(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let n = this.inner.cursor.node; n; n = n.parent) {
        let o = (r = n.tree) === null || r === void 0 ? void 0 : r.prop(le.mounted);
        if (o && o.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= n.to)
              break;
            l.tree == this.curFrag.tree && s.push({
              frag: l,
              pos: n.from - l.offset,
              mount: o
            });
          }
      }
    }
    return s;
  }
};
function Qp(i, e) {
  let t = null, r = e;
  for (let s = 1, n = 0; s < i.length; s++) {
    let o = i[s - 1].to, a = i[s].from;
    for (; n < r.length; n++) {
      let l = r[n];
      if (l.from >= a)
        break;
      l.to <= o || (t || (r = t = e.slice()), l.from < o ? (t[n] = new Mt(l.from, o), l.to > a && t.splice(n + 1, 0, new Mt(a, l.to))) : l.to > a ? t[n--] = new Mt(a, l.to) : t.splice(n--, 1));
    }
  }
  return r;
}
function LT(i, e, t, r) {
  let s = 0, n = 0, o = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let h = s == i.length ? 1e9 : o ? i[s].to : i[s].from, f = n == e.length ? 1e9 : a ? e[n].to : e[n].from;
    if (o != a) {
      let u = Math.max(l, t), g = Math.min(h, f, r);
      u < g && c.push(new Mt(u, g));
    }
    if (l = Math.min(h, f), l == 1e9)
      break;
    h == l && (o ? (o = !1, s++) : o = !0), f == l && (a ? (a = !1, n++) : a = !0);
  }
  return c;
}
function Pp(i, e) {
  let t = [];
  for (let { pos: r, mount: s, frag: n } of i) {
    let o = r + (s.overlay ? s.overlay[0].from : 0), a = o + s.tree.length, l = Math.max(n.from, o), c = Math.min(n.to, a);
    if (s.overlay) {
      let h = s.overlay.map((u) => new Mt(u.from + r, u.to + r)), f = LT(e, h, l, c);
      for (let u = 0, g = l; ; u++) {
        let S = u == f.length, v = S ? c : f[u].from;
        if (v > g && t.push(new Bi(g, v, s.tree, -o, n.from >= g || n.openStart, n.to <= v || n.openEnd)), S)
          break;
        g = f[u].to;
      }
    } else
      t.push(new Bi(l, c, s.tree, -o, n.from >= o || n.openStart, n.to <= a || n.openEnd));
  }
  return t;
}
let MT = 0, li = class Sf {
  /**
  @internal
  */
  constructor(e, t, r, s) {
    this.name = e, this.set = t, this.base = r, this.modified = s, this.id = MT++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof Sf && (t = e), t?.base)
      throw new Error("Can not derive from a modified tag");
    let s = new Sf(r, [], null, []);
    if (s.set.push(s), t)
      for (let n of t.set)
        s.set.push(n);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new Fa(e);
    return (r) => r.modified.indexOf(t) > -1 ? r : Fa.get(r.base || r, r.modified.concat(t).sort((s, n) => s.id - n.id));
  }
}, DT = 0;
class Fa {
  constructor(e) {
    this.name = e, this.instances = [], this.id = DT++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((a) => a.base == e && qT(t, a.modified));
    if (r)
      return r;
    let s = [], n = new li(e.name, s, e, t);
    for (let a of t)
      a.instances.push(n);
    let o = BT(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          s.push(Fa.get(a, l));
    return n;
  }
}
function qT(i, e) {
  return i.length == e.length && i.every((t, r) => t == e[r]);
}
function BT(i) {
  let e = [[]];
  for (let t = 0; t < i.length; t++)
    for (let r = 0, s = e.length; r < s; r++)
      e.push(e[r].concat(i[t]));
  return e.sort((t, r) => r.length - t.length);
}
function Jt(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in i) {
    let r = i[t];
    Array.isArray(r) || (r = [r]);
    for (let s of t.split(" "))
      if (s) {
        let n = [], o = 2, a = s;
        for (let f = 0; ; ) {
          if (a == "..." && f > 0 && f + 3 == s.length) {
            o = 1;
            break;
          }
          let u = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!u)
            throw new RangeError("Invalid path: " + s);
          if (n.push(u[0] == "*" ? "" : u[0][0] == '"' ? JSON.parse(u[0]) : u[0]), f += u[0].length, f == s.length)
            break;
          let g = s[f++];
          if (f == s.length && g == "!") {
            o = 0;
            break;
          }
          if (g != "/")
            throw new RangeError("Invalid path: " + s);
          a = s.slice(f);
        }
        let l = n.length - 1, c = n[l];
        if (!c)
          throw new RangeError("Invalid path: " + s);
        let h = new Ha(r, o, l > 0 ? n.slice(0, l) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return TS.add(e);
}
const TS = new le();
class Ha {
  constructor(e, t, r, s) {
    this.tags = e, this.mode = t, this.context = r, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Ha.empty = new Ha([], 2, null);
function RS(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n of i)
    if (!Array.isArray(n.tag))
      t[n.tag.id] = n.class;
    else
      for (let o of n.tag)
        t[o.id] = n.class;
  let { scope: r, all: s = null } = e || {};
  return {
    style: (n) => {
      let o = s;
      for (let a of n)
        for (let l of a.set) {
          let c = t[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function XT(i, e) {
  let t = null;
  for (let r of i) {
    let s = r.style(e);
    s && (t = t ? t + " " + s : s);
  }
  return t;
}
function IT(i, e, t, r = 0, s = i.length) {
  let n = new ZT(r, Array.isArray(e) ? e : [e], t);
  n.highlightRange(i.cursor(), r, s, "", n.highlighters), n.flush(s);
}
class ZT {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, s, n) {
    let { type: o, from: a, to: l } = e;
    if (a >= r || l <= t)
      return;
    o.isTop && (n = this.highlighters.filter((g) => !g.scope || g.scope(o)));
    let c = s, h = WT(e) || Ha.empty, f = XT(n, h.tags);
    if (f && (c && (c += " "), c += f, h.mode == 1 && (s += (s ? " " : "") + f)), this.startSpan(Math.max(t, a), c), h.opaque)
      return;
    let u = e.tree && e.tree.prop(le.mounted);
    if (u && u.overlay) {
      let g = e.node.enter(u.overlay[0].from + a, 1), S = this.highlighters.filter((d) => !d.scope || d.scope(u.tree.type)), v = e.firstChild();
      for (let d = 0, O = a; ; d++) {
        let p = d < u.overlay.length ? u.overlay[d] : null, m = p ? p.from + a : l, _ = Math.max(t, O), b = Math.min(r, m);
        if (_ < b && v)
          for (; e.from < b && (this.highlightRange(e, _, b, s, n), this.startSpan(Math.min(b, e.to), c), !(e.to >= m || !e.nextSibling())); )
            ;
        if (!p || m > r)
          break;
        O = p.to + a, O > t && (this.highlightRange(g.cursor(), Math.max(t, p.from + a), Math.min(r, O), "", S), this.startSpan(Math.min(r, O), c));
      }
      v && e.parent();
    } else if (e.firstChild()) {
      u && (s = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, s, n), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function WT(i) {
  let e = i.type.prop(TS);
  for (; e && e.context && !i.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const G = li.define, Wo = G(), Hi = G(), $p = G(Hi), Tp = G(Hi), Gi = G(), zo = G(Gi), xc = G(Gi), ai = G(), ur = G(ai), ni = G(), oi = G(), _f = G(), Zs = G(_f), Vo = G(), C = {
  /**
  A comment.
  */
  comment: Wo,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: G(Wo),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: G(Wo),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: G(Wo),
  /**
  Any kind of identifier.
  */
  name: Hi,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: G(Hi),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: $p,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: G($p),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Tp,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: G(Tp),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: G(Hi),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: G(Hi),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: G(Hi),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: G(Hi),
  /**
  A literal value.
  */
  literal: Gi,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: zo,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: G(zo),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: G(zo),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: G(zo),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: xc,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: G(xc),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: G(xc),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: G(Gi),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: G(Gi),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: G(Gi),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: G(Gi),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: G(Gi),
  /**
  A language keyword.
  */
  keyword: ni,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: G(ni),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: G(ni),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: G(ni),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: G(ni),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: G(ni),
  /**
  An operator.
  */
  operator: oi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: G(oi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: G(oi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: G(oi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: G(oi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: G(oi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: G(oi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: G(oi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: G(oi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: G(oi),
  /**
  Program or markup punctuation.
  */
  punctuation: _f,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: G(_f),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Zs,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: G(Zs),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: G(Zs),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: G(Zs),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: G(Zs),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: ai,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: ur,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: G(ur),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: G(ur),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: G(ur),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: G(ur),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: G(ur),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: G(ur),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: G(ai),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: G(ai),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: G(ai),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: G(ai),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: G(ai),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: G(ai),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: G(ai),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: G(ai),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: G(),
  /**
  Deleted text.
  */
  deleted: G(),
  /**
  Changed text.
  */
  changed: G(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: G(),
  /**
  Metadata or meta-instruction.
  */
  meta: Vo,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: G(Vo),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: G(Vo),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: G(Vo),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: li.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: li.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: li.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: li.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: li.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: li.defineModifier("special")
};
for (let i in C) {
  let e = C[i];
  e instanceof li && (e.name = i);
}
RS([
  { tag: C.link, class: "tok-link" },
  { tag: C.heading, class: "tok-heading" },
  { tag: C.emphasis, class: "tok-emphasis" },
  { tag: C.strong, class: "tok-strong" },
  { tag: C.keyword, class: "tok-keyword" },
  { tag: C.atom, class: "tok-atom" },
  { tag: C.bool, class: "tok-bool" },
  { tag: C.url, class: "tok-url" },
  { tag: C.labelName, class: "tok-labelName" },
  { tag: C.inserted, class: "tok-inserted" },
  { tag: C.deleted, class: "tok-deleted" },
  { tag: C.literal, class: "tok-literal" },
  { tag: C.string, class: "tok-string" },
  { tag: C.number, class: "tok-number" },
  { tag: [C.regexp, C.escape, C.special(C.string)], class: "tok-string2" },
  { tag: C.variableName, class: "tok-variableName" },
  { tag: C.local(C.variableName), class: "tok-variableName tok-local" },
  { tag: C.definition(C.variableName), class: "tok-variableName tok-definition" },
  { tag: C.special(C.variableName), class: "tok-variableName2" },
  { tag: C.definition(C.propertyName), class: "tok-propertyName tok-definition" },
  { tag: C.typeName, class: "tok-typeName" },
  { tag: C.namespace, class: "tok-namespace" },
  { tag: C.className, class: "tok-className" },
  { tag: C.macroName, class: "tok-macroName" },
  { tag: C.propertyName, class: "tok-propertyName" },
  { tag: C.operator, class: "tok-operator" },
  { tag: C.comment, class: "tok-comment" },
  { tag: C.meta, class: "tok-meta" },
  { tag: C.invalid, class: "tok-invalid" },
  { tag: C.punctuation, class: "tok-punctuation" }
]);
var kc;
const wr = /* @__PURE__ */ new le();
function Zu(i) {
  return ee.define({
    combine: i ? (e) => e.concat(i) : void 0
  });
}
const Wu = /* @__PURE__ */ new le();
class Dt {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], s = "") {
    this.data = e, this.name = s, _e.prototype.hasOwnProperty("tree") || Object.defineProperty(_e.prototype, "tree", { get() {
      return ke(this);
    } }), this.parser = t, this.extension = [
      cr.of(this),
      _e.languageData.of((n, o, a) => {
        let l = Rp(n, o, a), c = l.type.prop(wr);
        if (!c)
          return [];
        let h = n.facet(c), f = l.type.prop(Wu);
        if (f) {
          let u = l.resolve(o - l.from, a);
          for (let g of f)
            if (g.test(u, n)) {
              let S = n.facet(g.facet);
              return g.type == "replace" ? S : S.concat(h);
            }
        }
        return h;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return Rp(e, t, r).type.prop(wr) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(cr);
    if (t?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], s = (n, o) => {
      if (n.prop(wr) == this.data) {
        r.push({ from: o, to: o + n.length });
        return;
      }
      let a = n.prop(le.mounted);
      if (a) {
        if (a.tree.prop(wr) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + o, to: l.to + o });
          else
            r.push({ from: o, to: o + n.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (s(a.tree, a.overlay[0].from + o), r.length > l)
            return;
        }
      }
      for (let l = 0; l < n.children.length; l++) {
        let c = n.children[l];
        c instanceof xe && s(c, n.positions[l] + o);
      }
    };
    return s(ke(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Dt.setState = /* @__PURE__ */ he.define();
function Rp(i, e, t) {
  let r = i.facet(cr), s = ke(i).topNode;
  if (!r || r.allowsNesting)
    for (let n = s; n; n = n.enter(e, t, Te.ExcludeBuffers))
      n.type.isTop && (s = n);
  return s;
}
class Ht extends Dt {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = Zu(e.languageData);
    return new Ht(t, e.parser.configure({
      props: [wr.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Ht(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function ke(i) {
  let e = i.field(Dt.state, !1);
  return e ? e.tree : xe.empty;
}
class zT {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let Ws = null;
class Xn {
  constructor(e, t, r = [], s, n, o, a, l) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = s, this.treeLen = n, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Xn(e, t, [], xe.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new zT(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != xe.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let s = Date.now() + e;
        e = () => Date.now() > s;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(Bi.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(Bi.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = Ws;
    Ws = this;
    try {
      return e();
    } finally {
      Ws = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = Ep(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: s, treeLen: n, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, h, f, u) => l.push({ fromA: c, toA: h, fromB: f, toB: u })), r = Bi.applyChanges(r, l), s = xe.empty, n = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), f = e.mapPos(c.to, -1);
          h < f && a.push({ from: h, to: f });
        }
      }
    }
    return new Xn(this.parser, t, r, s, n, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: s, to: n } = this.skipped[r];
      s < e.to && n > e.from && (this.fragments = Ep(this.fragments, s, n), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends Iu {
      createParse(t, r, s) {
        let n = s[0].from, o = s[s.length - 1].to;
        return {
          parsedPos: n,
          advance() {
            let l = Ws;
            if (l) {
              for (let c of s)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new xe(Ne.none, [], [], o - n);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Ws;
  }
}
function Ep(i, e, t) {
  return Bi.applyChanges(i, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class ps {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new ps(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = Xn.create(e.facet(cr).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new ps(r);
  }
}
Dt.state = /* @__PURE__ */ Ge.define({
  create: ps.init,
  update(i, e) {
    for (let t of e.effects)
      if (t.is(Dt.setState))
        return t.value;
    return e.startState.facet(cr) != e.state.facet(cr) ? ps.init(e.state) : i.apply(e);
  }
});
let ES = (i) => {
  let e = setTimeout(
    () => i(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (ES = (i) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(i, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const Cc = typeof navigator < "u" && (!((kc = navigator.scheduling) === null || kc === void 0) && kc.isInputPending) ? () => navigator.scheduling.isInputPending() : null, VT = /* @__PURE__ */ Ue.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Dt.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Dt.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = ES(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: s } } = this.view, n = r.field(Dt.state);
    if (n.tree == n.context.tree && n.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Cc ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = n.context.treeLen < s && r.doc.length > s + 1e3, l = n.context.work(() => Cc && Cc() || Date.now() > o, s + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (n.context.takeTree(), this.view.dispatch({ effects: Dt.setState.of(new ps(n.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(n.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => bt(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), cr = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.length ? i[0] : null;
  },
  enables: (i) => [
    Dt.state,
    VT,
    K.contentAttributes.compute([i], (e) => {
      let t = e.facet(i);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class bi {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class Ga {
  constructor(e, t, r, s, n, o = void 0) {
    this.name = e, this.alias = t, this.extensions = r, this.filename = s, this.loadFunc = n, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: r } = e;
    if (!t) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(r);
    }
    return new Ga(e.name, (e.alias || []).concat(e.name).map((s) => s.toLowerCase()), e.extensions || [], e.filename, t, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let s of e)
      if (s.filename && s.filename.test(t))
        return s;
    let r = /\.([^.]+)$/.exec(t);
    if (r) {
      for (let s of e)
        if (s.extensions.indexOf(r[1]) > -1)
          return s;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, r = !0) {
    t = t.toLowerCase();
    for (let s of e)
      if (s.alias.some((n) => n == t))
        return s;
    if (r)
      for (let s of e)
        for (let n of s.alias) {
          let o = t.indexOf(n);
          if (o > -1 && (n.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + n.length])))
            return s;
        }
    return null;
  }
}
const UT = /* @__PURE__ */ ee.define(), po = /* @__PURE__ */ ee.define({
  combine: (i) => {
    if (!i.length)
      return "  ";
    let e = i[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(i[0]));
    return e;
  }
});
function Ka(i) {
  let e = i.facet(po);
  return e.charCodeAt(0) == 9 ? i.tabSize * e.length : e.length;
}
function In(i, e) {
  let t = "", r = i.tabSize, s = i.facet(po)[0];
  if (s == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    s = " ";
  }
  for (let n = 0; n < e; n++)
    t += s;
  return t;
}
function zu(i, e) {
  i instanceof _e && (i = new Dl(i));
  for (let r of i.state.facet(UT)) {
    let s = r(i, e);
    if (s !== void 0)
      return s;
  }
  let t = ke(i.state);
  return t.length >= e ? jT(i, t, e) : null;
}
class Dl {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Ka(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: s, simulateDoubleBreak: n } = this.options;
    return s != null && s >= r.from && s <= r.to ? n && s == e ? { text: "", from: e } : (t < 0 ? s < e : s <= e) ? { text: r.text.slice(s - r.from), from: s } : { text: r.text.slice(0, s - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: s } = this.lineAt(e, t);
    return r.slice(e - s, Math.min(r.length, e + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: s } = this.lineAt(e, t), n = this.countColumn(r, e - s), o = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return o > -1 && (n += o - this.countColumn(r, r.search(/\S|$/))), n;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Nt(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: s } = this.lineAt(e, t), n = this.options.overrideIndentation;
    if (n) {
      let o = n(s);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const ki = /* @__PURE__ */ new le();
function jT(i, e, t) {
  let r = e.resolveStack(t), s = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (s != r.node) {
    let n = [];
    for (let o = s; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      n.push(o);
    for (let o = n.length - 1; o >= 0; o--)
      r = { node: n[o], next: r };
  }
  return AS(r, i, t);
}
function AS(i, e, t) {
  for (let r = i; r; r = r.next) {
    let s = YT(r.node);
    if (s)
      return s(Vu.create(e, t, r));
  }
  return 0;
}
function NT(i) {
  return i.pos == i.options.simulateBreak && i.options.simulateDoubleBreak;
}
function YT(i) {
  let e = i.type.prop(ki);
  if (e)
    return e;
  let t = i.firstChild, r;
  if (t && (r = t.type.prop(le.closedBy))) {
    let s = i.lastChild, n = s && r.indexOf(s.name) > -1;
    return (o) => LS(o, !0, 1, void 0, n && !NT(o) ? s.from : void 0);
  }
  return i.parent == null ? FT : null;
}
function FT() {
  return 0;
}
class Vu extends Dl {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Vu(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (HT(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return AS(this.context.next, this.base, this.pos);
  }
}
function HT(i, e) {
  for (let t = e; t; t = t.parent)
    if (i == t)
      return !0;
  return !1;
}
function GT(i) {
  let e = i.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let s = i.options.simulateBreak, n = i.state.doc.lineAt(t.from), o = s == null || s <= n.from ? n.to : Math.min(n.to, s);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= o)
        return null;
      let c = /^ */.exec(n.text.slice(t.to - n.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    a = l.to;
  }
}
function ns({ closing: i, align: e = !0, units: t = 1 }) {
  return (r) => LS(r, e, t, i);
}
function LS(i, e, t, r, s) {
  let n = i.textAfter, o = n.match(/^\s*/)[0].length, a = r && n.slice(o, o + r.length) == r || s == i.pos + o, l = e ? GT(i) : null;
  return l ? a ? i.column(l.from) : i.column(l.to) : i.baseIndent + (a ? 0 : i.unit * t);
}
const KT = (i) => i.baseIndent;
function Pr({ except: i, units: e = 1 } = {}) {
  return (t) => {
    let r = i && i.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const JT = 200;
function eR() {
  return _e.transactionFilter.of((i) => {
    if (!i.docChanged || !i.isUserEvent("input.type") && !i.isUserEvent("input.complete"))
      return i;
    let e = i.startState.languageDataAt("indentOnInput", i.startState.selection.main.head);
    if (!e.length)
      return i;
    let t = i.newDoc, { head: r } = i.newSelection.main, s = t.lineAt(r);
    if (r > s.from + JT)
      return i;
    let n = t.sliceString(s.from, r);
    if (!e.some((c) => c.test(n)))
      return i;
    let { state: o } = i, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let h = o.doc.lineAt(c);
      if (h.from == a)
        continue;
      a = h.from;
      let f = zu(o, h.from);
      if (f == null)
        continue;
      let u = /^\s*/.exec(h.text)[0], g = In(o, f);
      u != g && l.push({ from: h.from, to: h.from + u.length, insert: g });
    }
    return l.length ? [i, { changes: l, sequential: !0 }] : i;
  });
}
const MS = /* @__PURE__ */ ee.define(), ei = /* @__PURE__ */ new le();
function go(i) {
  let e = i.firstChild, t = i.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? i.to : t.from } : null;
}
function tR(i, e, t) {
  let r = ke(i);
  if (r.length < t)
    return null;
  let s = r.resolveStack(t, 1), n = null;
  for (let o = s; o; o = o.next) {
    let a = o.node;
    if (a.to <= t || a.from > t)
      continue;
    if (n && a.from < e)
      break;
    let l = a.type.prop(ei);
    if (l && (a.to < r.length - 50 || r.length == i.doc.length || !iR(a))) {
      let c = l(a, i);
      c && c.from <= t && c.from >= e && c.to > t && (n = c);
    }
  }
  return n;
}
function iR(i) {
  let e = i.lastChild;
  return e && e.to == i.to && e.type.isError;
}
function Ja(i, e, t) {
  for (let r of i.facet(MS)) {
    let s = r(i, e, t);
    if (s)
      return s;
  }
  return tR(i, e, t);
}
function DS(i, e) {
  let t = e.mapPos(i.from, 1), r = e.mapPos(i.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const ql = /* @__PURE__ */ he.define({ map: DS }), mo = /* @__PURE__ */ he.define({ map: DS });
function qS(i) {
  let e = [];
  for (let { head: t } of i.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(i.lineBlockAt(t));
  return e;
}
const Br = /* @__PURE__ */ Ge.define({
  create() {
    return ae.none;
  },
  update(i, e) {
    i = i.map(e.changes);
    for (let t of e.effects)
      if (t.is(ql) && !rR(i, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(IS), s = r ? ae.replace({ widget: new hR(r(e.state, t.value)) }) : Ap;
        i = i.update({ add: [s.range(t.value.from, t.value.to)] });
      } else t.is(mo) && (i = i.update({
        filter: (r, s) => t.value.from != r || t.value.to != s,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: r } = e.selection.main;
      i.between(r, r, (s, n) => {
        s < r && n > r && (t = !0);
      }), t && (i = i.update({
        filterFrom: r,
        filterTo: r,
        filter: (s, n) => n <= r || s >= r
      }));
    }
    return i;
  },
  provide: (i) => K.decorations.from(i),
  toJSON(i, e) {
    let t = [];
    return i.between(0, e.doc.length, (r, s) => {
      t.push(r, s);
    }), t;
  },
  fromJSON(i) {
    if (!Array.isArray(i) || i.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < i.length; ) {
      let r = i[t++], s = i[t++];
      if (typeof r != "number" || typeof s != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Ap.range(r, s));
    }
    return ae.set(e, !0);
  }
});
function el(i, e, t) {
  var r;
  let s = null;
  return (r = i.field(Br, !1)) === null || r === void 0 || r.between(e, t, (n, o) => {
    (!s || s.from > n) && (s = { from: n, to: o });
  }), s;
}
function rR(i, e, t) {
  let r = !1;
  return i.between(e, e, (s, n) => {
    s == e && n == t && (r = !0);
  }), r;
}
function BS(i, e) {
  return i.field(Br, !1) ? e : e.concat(he.appendConfig.of(ZS()));
}
const sR = (i) => {
  for (let e of qS(i)) {
    let t = Ja(i.state, e.from, e.to);
    if (t)
      return i.dispatch({ effects: BS(i.state, [ql.of(t), XS(i, t)]) }), !0;
  }
  return !1;
}, nR = (i) => {
  if (!i.state.field(Br, !1))
    return !1;
  let e = [];
  for (let t of qS(i)) {
    let r = el(i.state, t.from, t.to);
    r && e.push(mo.of(r), XS(i, r, !1));
  }
  return e.length && i.dispatch({ effects: e }), e.length > 0;
};
function XS(i, e, t = !0) {
  let r = i.state.doc.lineAt(e.from).number, s = i.state.doc.lineAt(e.to).number;
  return K.announce.of(`${i.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${i.state.phrase("to")} ${s}.`);
}
const oR = (i) => {
  let { state: e } = i, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let s = i.lineBlockAt(r), n = Ja(e, s.from, s.to);
    n && t.push(ql.of(n)), r = (n ? i.lineBlockAt(n.to) : s).to + 1;
  }
  return t.length && i.dispatch({ effects: BS(i.state, t) }), !!t.length;
}, aR = (i) => {
  let e = i.state.field(Br, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, i.state.doc.length, (r, s) => {
    t.push(mo.of({ from: r, to: s }));
  }), i.dispatch({ effects: t }), !0;
}, lR = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: sR },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: nR },
  { key: "Ctrl-Alt-[", run: oR },
  { key: "Ctrl-Alt-]", run: aR }
], cR = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, IS = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, cR);
  }
});
function ZS(i) {
  return [Br, dR];
}
function WS(i, e) {
  let { state: t } = i, r = t.facet(IS), s = (o) => {
    let a = i.lineBlockAt(i.posAtDOM(o.target)), l = el(i.state, a.from, a.to);
    l && i.dispatch({ effects: mo.of(l) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(i, s, e);
  let n = document.createElement("span");
  return n.textContent = r.placeholderText, n.setAttribute("aria-label", t.phrase("folded code")), n.title = t.phrase("unfold"), n.className = "cm-foldPlaceholder", n.onclick = s, n;
}
const Ap = /* @__PURE__ */ ae.replace({ widget: /* @__PURE__ */ new class extends ji {
  toDOM(i) {
    return WS(i, null);
  }
}() });
class hR extends ji {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return WS(e, this.value);
  }
}
const fR = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Qc extends Wi {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function uR(i = {}) {
  let e = { ...fR, ...i }, t = new Qc(e, !0), r = new Qc(e, !1), s = Ue.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(cr) != o.state.facet(cr) || o.startState.field(Br, !1) != o.state.field(Br, !1) || ke(o.startState) != ke(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new Ii();
      for (let l of o.viewportLineBlocks) {
        let c = el(o.state, l.from, l.to) ? r : Ja(o.state, l.from, l.to) ? t : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: n } = e;
  return [
    s,
    fT({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(s)) === null || a === void 0 ? void 0 : a.markers) || ye.empty;
      },
      initialSpacer() {
        return new Qc(e, !1);
      },
      domEventHandlers: {
        ...n,
        click: (o, a, l) => {
          if (n.click && n.click(o, a, l))
            return !0;
          let c = el(o.state, a.from, a.to);
          if (c)
            return o.dispatch({ effects: mo.of(c) }), !0;
          let h = Ja(o.state, a.from, a.to);
          return h ? (o.dispatch({ effects: ql.of(h) }), !0) : !1;
        }
      }
    }),
    ZS()
  ];
}
const dR = /* @__PURE__ */ K.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class ks {
  constructor(e, t) {
    this.specs = e;
    let r;
    function s(a) {
      let l = nr.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const n = typeof t.all == "string" ? t.all : t.all ? s(t.all) : void 0, o = t.scope;
    this.scope = o instanceof Dt ? (a) => a.prop(wr) == o.data : o ? (a) => a == o : void 0, this.style = RS(e.map((a) => ({
      tag: a.tag,
      class: a.class || s(Object.assign({}, a, { tag: null }))
    })), {
      all: n
    }).style, this.module = r ? new nr(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new ks(e, t || {});
  }
}
const bf = /* @__PURE__ */ ee.define(), zS = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.length ? [i[0]] : null;
  }
});
function Pc(i) {
  let e = i.facet(bf);
  return e.length ? e : i.facet(zS);
}
function VS(i, e) {
  let t = [pR], r;
  return i instanceof ks && (i.module && t.push(K.styleModule.of(i.module)), r = i.themeType), e?.fallback ? t.push(zS.of(i)) : r ? t.push(bf.computeN([K.darkTheme], (s) => s.facet(K.darkTheme) == (r == "dark") ? [i] : [])) : t.push(bf.of(i)), t;
}
class OR {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = ke(e.state), this.decorations = this.buildDeco(e, Pc(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = ke(e.state), r = Pc(e.state), s = r != Pc(e.startState), { viewport: n } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < n.to && !s && t.type == this.tree.type && o >= n.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || s) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = n.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return ae.none;
    let r = new Ii();
    for (let { from: s, to: n } of e.visibleRanges)
      IT(this.tree, t, (o, a, l) => {
        r.add(o, a, this.markCache[l] || (this.markCache[l] = ae.mark({ class: l })));
      }, s, n);
    return r.finish();
  }
}
const pR = /* @__PURE__ */ Vi.high(/* @__PURE__ */ Ue.fromClass(OR, {
  decorations: (i) => i.decorations
})), gR = /* @__PURE__ */ ks.define([
  {
    tag: C.meta,
    color: "#404740"
  },
  {
    tag: C.link,
    textDecoration: "underline"
  },
  {
    tag: C.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: C.emphasis,
    fontStyle: "italic"
  },
  {
    tag: C.strong,
    fontWeight: "bold"
  },
  {
    tag: C.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: C.keyword,
    color: "#708"
  },
  {
    tag: [C.atom, C.bool, C.url, C.contentSeparator, C.labelName],
    color: "#219"
  },
  {
    tag: [C.literal, C.inserted],
    color: "#164"
  },
  {
    tag: [C.string, C.deleted],
    color: "#a11"
  },
  {
    tag: [C.regexp, C.escape, /* @__PURE__ */ C.special(C.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ C.definition(C.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ C.local(C.variableName),
    color: "#30a"
  },
  {
    tag: [C.typeName, C.namespace],
    color: "#085"
  },
  {
    tag: C.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ C.special(C.variableName), C.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ C.definition(C.propertyName),
    color: "#00c"
  },
  {
    tag: C.comment,
    color: "#940"
  },
  {
    tag: C.invalid,
    color: "#f00"
  }
]), mR = /* @__PURE__ */ K.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), US = 1e4, jS = "()[]{}", NS = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, {
      afterCursor: !0,
      brackets: jS,
      maxScanDistance: US,
      renderMatch: _R
    });
  }
}), vR = /* @__PURE__ */ ae.mark({ class: "cm-matchingBracket" }), SR = /* @__PURE__ */ ae.mark({ class: "cm-nonmatchingBracket" });
function _R(i) {
  let e = [], t = i.matched ? vR : SR;
  return e.push(t.range(i.start.from, i.start.to)), i.end && e.push(t.range(i.end.from, i.end.to)), e;
}
const bR = /* @__PURE__ */ Ge.define({
  create() {
    return ae.none;
  },
  update(i, e) {
    if (!e.docChanged && !e.selection)
      return i;
    let t = [], r = e.state.facet(NS);
    for (let s of e.state.selection.ranges) {
      if (!s.empty)
        continue;
      let n = di(e.state, s.head, -1, r) || s.head > 0 && di(e.state, s.head - 1, 1, r) || r.afterCursor && (di(e.state, s.head, 1, r) || s.head < e.state.doc.length && di(e.state, s.head + 1, -1, r));
      n && (t = t.concat(r.renderMatch(n, e.state)));
    }
    return ae.set(t, !0);
  },
  provide: (i) => K.decorations.from(i)
}), yR = [
  bR,
  mR
];
function wR(i = {}) {
  return [NS.of(i), yR];
}
const Uu = /* @__PURE__ */ new le();
function yf(i, e, t) {
  let r = i.prop(e < 0 ? le.openedBy : le.closedBy);
  if (r)
    return r;
  if (i.name.length == 1) {
    let s = t.indexOf(i.name);
    if (s > -1 && s % 2 == (e < 0 ? 1 : 0))
      return [t[s + e]];
  }
  return null;
}
function wf(i) {
  let e = i.type.prop(Uu);
  return e ? e(i.node) : i;
}
function di(i, e, t, r = {}) {
  let s = r.maxScanDistance || US, n = r.brackets || jS, o = ke(i), a = o.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let c = yf(l.type, t, n);
    if (c && l.from < l.to) {
      let h = wf(l);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return xR(i, e, t, l, h, c, n);
    }
  }
  return kR(i, e, t, o, a.type, s, n);
}
function xR(i, e, t, r, s, n, o) {
  let a = r.parent, l = { from: s.from, to: s.to }, c = 0, h = a?.cursor();
  if (h && (t < 0 ? h.childBefore(r.from) : h.childAfter(r.to)))
    do
      if (t < 0 ? h.to <= r.from : h.from >= r.to) {
        if (c == 0 && n.indexOf(h.type.name) > -1 && h.from < h.to) {
          let f = wf(h);
          return { start: l, end: f ? { from: f.from, to: f.to } : void 0, matched: !0 };
        } else if (yf(h.type, t, o))
          c++;
        else if (yf(h.type, -t, o)) {
          if (c == 0) {
            let f = wf(h);
            return {
              start: l,
              end: f && f.from < f.to ? { from: f.from, to: f.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: l, matched: !1 };
}
function kR(i, e, t, r, s, n, o) {
  let a = t < 0 ? i.sliceDoc(e - 1, e) : i.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = i.doc.iterRange(e, t > 0 ? i.doc.length : 0), f = 0;
  for (let u = 0; !h.next().done && u <= n; ) {
    let g = h.value;
    t < 0 && (u += g.length);
    let S = e + u * t;
    for (let v = t > 0 ? 0 : g.length - 1, d = t > 0 ? g.length : -1; v != d; v += t) {
      let O = o.indexOf(g[v]);
      if (!(O < 0 || r.resolveInner(S + v, 1).type != s))
        if (O % 2 == 0 == t > 0)
          f++;
        else {
          if (f == 1)
            return { start: c, end: { from: S + v, to: S + v + 1 }, matched: O >> 1 == l >> 1 };
          f--;
        }
    }
    t > 0 && (u += g.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const CR = /* @__PURE__ */ Object.create(null), Lp = [Ne.none], Mp = [], Dp = /* @__PURE__ */ Object.create(null), QR = /* @__PURE__ */ Object.create(null);
for (let [i, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  QR[i] = /* @__PURE__ */ PR(CR, e);
function $c(i, e) {
  Mp.indexOf(i) > -1 || (Mp.push(i), console.warn(e));
}
function PR(i, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let h = i[c] || C[c];
      h ? typeof h == "function" ? l.length ? l = l.map(h) : $c(c, `Modifier ${c} used at start of tag`) : l.length ? $c(c, `Tag ${c} used as modifier`) : l = Array.isArray(h) ? h : [h] : $c(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), s = r + " " + t.map((a) => a.id), n = Dp[s];
  if (n)
    return n.id;
  let o = Dp[s] = Ne.define({
    id: Lp.length,
    name: r,
    props: [Jt({ [r]: t })]
  });
  return Lp.push(o), o.id;
}
Me.RTL, Me.LTR;
const $R = (i) => {
  let { state: e } = i, t = e.doc.lineAt(e.selection.main.from), r = Nu(i.state, t.from);
  return r.line ? TR(i) : r.block ? ER(i) : !1;
};
function ju(i, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let s = i(e, t);
    return s ? (r(t.update(s)), !0) : !1;
  };
}
const TR = /* @__PURE__ */ ju(
  MR,
  0
  /* CommentOption.Toggle */
), RR = /* @__PURE__ */ ju(
  YS,
  0
  /* CommentOption.Toggle */
), ER = /* @__PURE__ */ ju(
  (i, e) => YS(i, e, LR(e)),
  0
  /* CommentOption.Toggle */
);
function Nu(i, e) {
  let t = i.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const zs = 50;
function AR(i, { open: e, close: t }, r, s) {
  let n = i.sliceDoc(r - zs, r), o = i.sliceDoc(s, s + zs), a = /\s*$/.exec(n)[0].length, l = /^\s*/.exec(o)[0].length, c = n.length - a;
  if (n.slice(c - e.length, c) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: s + l, margin: l && 1 }
    };
  let h, f;
  s - r <= 2 * zs ? h = f = i.sliceDoc(r, s) : (h = i.sliceDoc(r, r + zs), f = i.sliceDoc(s - zs, s));
  let u = /^\s*/.exec(h)[0].length, g = /\s*$/.exec(f)[0].length, S = f.length - g - t.length;
  return h.slice(u, u + e.length) == e && f.slice(S, S + t.length) == t ? {
    open: {
      pos: r + u + e.length,
      margin: /\s/.test(h.charAt(u + e.length)) ? 1 : 0
    },
    close: {
      pos: s - g - t.length,
      margin: /\s/.test(f.charAt(S - 1)) ? 1 : 0
    }
  } : null;
}
function LR(i) {
  let e = [];
  for (let t of i.selection.ranges) {
    let r = i.doc.lineAt(t.from), s = t.to <= r.to ? r : i.doc.lineAt(t.to);
    s.from > r.from && s.from == t.to && (s = t.to == r.to + 1 ? r : i.doc.lineAt(t.to - 1));
    let n = e.length - 1;
    n >= 0 && e[n].to > r.from ? e[n].to = s.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: s.to });
  }
  return e;
}
function YS(i, e, t = e.selection.ranges) {
  let r = t.map((n) => Nu(e, n.from).block);
  if (!r.every((n) => n))
    return null;
  let s = t.map((n, o) => AR(e, r[o], n.from, n.to));
  if (i != 2 && !s.every((n) => n))
    return { changes: e.changes(t.map((n, o) => s[o] ? [] : [{ from: n.from, insert: r[o].open + " " }, { from: n.to, insert: " " + r[o].close }])) };
  if (i != 1 && s.some((n) => n)) {
    let n = [];
    for (let o = 0, a; o < s.length; o++)
      if (a = s[o]) {
        let l = r[o], { open: c, close: h } = a;
        n.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + l.close.length });
      }
    return { changes: n };
  }
  return null;
}
function MR(i, e, t = e.selection.ranges) {
  let r = [], s = -1;
  for (let { from: n, to: o } of t) {
    let a = r.length, l = 1e9, c = Nu(e, n).line;
    if (c) {
      for (let h = n; h <= o; ) {
        let f = e.doc.lineAt(h);
        if (f.from > s && (n == o || o > f.from)) {
          s = f.from;
          let u = /^\s*/.exec(f.text)[0].length, g = u == f.length, S = f.text.slice(u, u + c.length) == c ? u : -1;
          u < f.text.length && u < l && (l = u), r.push({ line: f, comment: S, token: c, indent: u, empty: g, single: !1 });
        }
        h = f.to + 1;
      }
      if (l < 1e9)
        for (let h = a; h < r.length; h++)
          r[h].indent < r[h].line.text.length && (r[h].indent = l);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (i != 2 && r.some((n) => n.comment < 0 && (!n.empty || n.single))) {
    let n = [];
    for (let { line: a, token: l, indent: c, empty: h, single: f } of r)
      (f || !h) && n.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(n);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (i != 1 && r.some((n) => n.comment >= 0)) {
    let n = [];
    for (let { line: o, comment: a, token: l } of r)
      if (a >= 0) {
        let c = o.from + a, h = c + l.length;
        o.text[h - o.from] == " " && h++, n.push({ from: c, to: h });
      }
    return { changes: n };
  }
  return null;
}
const xf = /* @__PURE__ */ Ui.define(), DR = /* @__PURE__ */ Ui.define(), qR = /* @__PURE__ */ ee.define(), FS = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, s) => e(r, s) || t(r, s)
    });
  }
}), HS = /* @__PURE__ */ Ge.define({
  create() {
    return Oi.empty;
  },
  update(i, e) {
    let t = e.state.facet(FS), r = e.annotation(xf);
    if (r) {
      let l = yt.fromTransaction(e, r.selection), c = r.side, h = c == 0 ? i.undone : i.done;
      return l ? h = tl(h, h.length, t.minDepth, l) : h = JS(h, e.startState.selection), new Oi(c == 0 ? r.rest : h, c == 0 ? h : r.rest);
    }
    let s = e.annotation(DR);
    if ((s == "full" || s == "before") && (i = i.isolate()), e.annotation(ze.addToHistory) === !1)
      return e.changes.empty ? i : i.addMapping(e.changes.desc);
    let n = yt.fromTransaction(e), o = e.annotation(ze.time), a = e.annotation(ze.userEvent);
    return n ? i = i.addChanges(n, o, a, t, e) : e.selection && (i = i.addSelection(e.startState.selection, o, a, t.newGroupDelay)), (s == "full" || s == "after") && (i = i.isolate()), i;
  },
  toJSON(i) {
    return { done: i.done.map((e) => e.toJSON()), undone: i.undone.map((e) => e.toJSON()) };
  },
  fromJSON(i) {
    return new Oi(i.done.map(yt.fromJSON), i.undone.map(yt.fromJSON));
  }
});
function BR(i = {}) {
  return [
    HS,
    FS.of(i),
    K.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? GS : e.inputType == "historyRedo" ? kf : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function Bl(i, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let s = t.field(HS, !1);
    if (!s)
      return !1;
    let n = s.pop(i, t, e);
    return n ? (r(n), !0) : !1;
  };
}
const GS = /* @__PURE__ */ Bl(0, !1), kf = /* @__PURE__ */ Bl(1, !1), XR = /* @__PURE__ */ Bl(0, !0), IR = /* @__PURE__ */ Bl(1, !0);
class yt {
  constructor(e, t, r, s, n) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = s, this.selectionsAfter = n;
  }
  setSelAfter(e) {
    return new yt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(e) {
    return new yt(e.changes && je.fromJSON(e.changes), [], e.mapped && pi.fromJSON(e.mapped), e.startSelection && V.fromJSON(e.startSelection), e.selectionsAfter.map(V.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = qt;
    for (let s of e.startState.facet(qR)) {
      let n = s(e);
      n.length && (r = r.concat(n));
    }
    return !r.length && e.changes.empty ? null : new yt(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, qt);
  }
  static selection(e) {
    return new yt(void 0, qt, void 0, void 0, e);
  }
}
function tl(i, e, t, r) {
  let s = e + 1 > t + 20 ? e - t - 1 : 0, n = i.slice(s, e);
  return n.push(r), n;
}
function ZR(i, e) {
  let t = [], r = !1;
  return i.iterChangedRanges((s, n) => t.push(s, n)), e.iterChangedRanges((s, n, o, a) => {
    for (let l = 0; l < t.length; ) {
      let c = t[l++], h = t[l++];
      a >= c && o <= h && (r = !0);
    }
  }), r;
}
function WR(i, e) {
  return i.ranges.length == e.ranges.length && i.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function KS(i, e) {
  return i.length ? e.length ? i.concat(e) : i : e;
}
const qt = [], zR = 200;
function JS(i, e) {
  if (i.length) {
    let t = i[i.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - zR));
    return r.length && r[r.length - 1].eq(e) ? i : (r.push(e), tl(i, i.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [yt.selection([e])];
}
function VR(i) {
  let e = i[i.length - 1], t = i.slice();
  return t[i.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function Tc(i, e) {
  if (!i.length)
    return i;
  let t = i.length, r = qt;
  for (; t; ) {
    let s = UR(i[t - 1], e, r);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let n = i.slice(0, t);
      return n[t - 1] = s, n;
    } else
      e = s.mapped, t--, r = s.selectionsAfter;
  }
  return r.length ? [yt.selection(r)] : qt;
}
function UR(i, e, t) {
  let r = KS(i.selectionsAfter.length ? i.selectionsAfter.map((a) => a.map(e)) : qt, t);
  if (!i.changes)
    return yt.selection(r);
  let s = i.changes.map(e), n = e.mapDesc(i.changes, !0), o = i.mapped ? i.mapped.composeDesc(n) : n;
  return new yt(s, he.mapEffects(i.effects, e), o, i.startSelection.map(n), r);
}
const jR = /^(input\.type|delete)($|\.)/;
class Oi {
  constructor(e, t, r = 0, s = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new Oi(this.done, this.undone) : this;
  }
  addChanges(e, t, r, s, n) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!r || jR.test(r)) && (!a.selectionsAfter.length && t - this.prevTime < s.newGroupDelay && s.joinToEvent(n, ZR(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = tl(o, o.length - 1, s.minDepth, new yt(e.changes.compose(a.changes), KS(he.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, qt)) : o = tl(o, o.length, s.minDepth, e), new Oi(o, qt, t, r);
  }
  addSelection(e, t, r, s) {
    let n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : qt;
    return n.length > 0 && t - this.prevTime < s && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && WR(n[n.length - 1], e) ? this : new Oi(JS(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new Oi(Tc(this.done, e), Tc(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let s = e == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let n = s[s.length - 1], o = n.selectionsAfter[0] || t.selection;
    if (r && n.selectionsAfter.length)
      return t.update({
        selection: n.selectionsAfter[n.selectionsAfter.length - 1],
        annotations: xf.of({ side: e, rest: VR(s), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (n.changes) {
      let a = s.length == 1 ? qt : s.slice(0, s.length - 1);
      return n.mapped && (a = Tc(a, n.mapped)), t.update({
        changes: n.changes,
        selection: n.startSelection,
        effects: n.effects,
        annotations: xf.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Oi.empty = /* @__PURE__ */ new Oi(qt, qt);
const NR = [
  { key: "Mod-z", run: GS, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: kf, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: kf, preventDefault: !0 },
  { key: "Mod-u", run: XR, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: IR, preventDefault: !0 }
];
function Cs(i, e) {
  return V.create(i.ranges.map(e), i.mainIndex);
}
function Ci(i, e) {
  return i.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ti({ state: i, dispatch: e }, t) {
  let r = Cs(i.selection, t);
  return r.eq(i.selection, !0) ? !1 : (e(Ci(i, r)), !0);
}
function Xl(i, e) {
  return V.cursor(e ? i.to : i.from);
}
function e_(i, e) {
  return ti(i, (t) => t.empty ? i.moveByChar(t, e) : Xl(t, e));
}
function ut(i) {
  return i.textDirectionAt(i.state.selection.main.head) == Me.LTR;
}
const t_ = (i) => e_(i, !ut(i)), i_ = (i) => e_(i, ut(i));
function r_(i, e) {
  return ti(i, (t) => t.empty ? i.moveByGroup(t, e) : Xl(t, e));
}
const YR = (i) => r_(i, !ut(i)), FR = (i) => r_(i, ut(i));
function HR(i, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(i.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Il(i, e, t) {
  let r = ke(i).resolveInner(e.head), s = t ? le.closedBy : le.openedBy;
  for (let l = e.head; ; ) {
    let c = t ? r.childAfter(l) : r.childBefore(l);
    if (!c)
      break;
    HR(i, c, s) ? r = c : l = t ? c.to : c.from;
  }
  let n = r.type.prop(s), o, a;
  return n && (o = t ? di(i, r.from, 1) : di(i, r.to, -1)) && o.matched ? a = t ? o.end.to : o.end.from : a = t ? r.to : r.from, V.cursor(a, t ? -1 : 1);
}
const GR = (i) => ti(i, (e) => Il(i.state, e, !ut(i))), KR = (i) => ti(i, (e) => Il(i.state, e, ut(i)));
function s_(i, e) {
  return ti(i, (t) => {
    if (!t.empty)
      return Xl(t, e);
    let r = i.moveVertically(t, e);
    return r.head != t.head ? r : i.moveToLineBoundary(t, e);
  });
}
const n_ = (i) => s_(i, !1), o_ = (i) => s_(i, !0);
function a_(i) {
  let e = i.scrollDOM.clientHeight < i.scrollDOM.scrollHeight - 2, t = 0, r = 0, s;
  if (e) {
    for (let n of i.state.facet(K.scrollMargins)) {
      let o = n(i);
      o?.top && (t = Math.max(o?.top, t)), o?.bottom && (r = Math.max(o?.bottom, r));
    }
    s = i.scrollDOM.clientHeight - t - r;
  } else
    s = (i.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(i.defaultLineHeight, s - 5)
  };
}
function l_(i, e) {
  let t = a_(i), { state: r } = i, s = Cs(r.selection, (o) => o.empty ? i.moveVertically(o, e, t.height) : Xl(o, e));
  if (s.eq(r.selection))
    return !1;
  let n;
  if (t.selfScroll) {
    let o = i.coordsAtPos(r.selection.main.head), a = i.scrollDOM.getBoundingClientRect(), l = a.top + t.marginTop, c = a.bottom - t.marginBottom;
    o && o.top > l && o.bottom < c && (n = K.scrollIntoView(s.main.head, { y: "start", yMargin: o.top - l }));
  }
  return i.dispatch(Ci(r, s), { effects: n }), !0;
}
const qp = (i) => l_(i, !1), Cf = (i) => l_(i, !0);
function fr(i, e, t) {
  let r = i.lineBlockAt(e.head), s = i.moveToLineBoundary(e, t);
  if (s.head == e.head && s.head != (t ? r.to : r.from) && (s = i.moveToLineBoundary(e, t, !1)), !t && s.head == r.from && r.length) {
    let n = /^\s*/.exec(i.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    n && e.head != r.from + n && (s = V.cursor(r.from + n));
  }
  return s;
}
const JR = (i) => ti(i, (e) => fr(i, e, !0)), e2 = (i) => ti(i, (e) => fr(i, e, !1)), t2 = (i) => ti(i, (e) => fr(i, e, !ut(i))), i2 = (i) => ti(i, (e) => fr(i, e, ut(i))), r2 = (i) => ti(i, (e) => V.cursor(i.lineBlockAt(e.head).from, 1)), s2 = (i) => ti(i, (e) => V.cursor(i.lineBlockAt(e.head).to, -1));
function n2(i, e, t) {
  let r = !1, s = Cs(i.selection, (n) => {
    let o = di(i, n.head, -1) || di(i, n.head, 1) || n.head > 0 && di(i, n.head - 1, 1) || n.head < i.doc.length && di(i, n.head + 1, -1);
    if (!o || !o.end)
      return n;
    r = !0;
    let a = o.start.from == n.head ? o.end.to : o.end.from;
    return V.cursor(a);
  });
  return r ? (e(Ci(i, s)), !0) : !1;
}
const o2 = ({ state: i, dispatch: e }) => n2(i, e);
function Zt(i, e) {
  let t = Cs(i.state.selection, (r) => {
    let s = e(r);
    return V.range(r.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return t.eq(i.state.selection) ? !1 : (i.dispatch(Ci(i.state, t)), !0);
}
function c_(i, e) {
  return Zt(i, (t) => i.moveByChar(t, e));
}
const h_ = (i) => c_(i, !ut(i)), f_ = (i) => c_(i, ut(i));
function u_(i, e) {
  return Zt(i, (t) => i.moveByGroup(t, e));
}
const a2 = (i) => u_(i, !ut(i)), l2 = (i) => u_(i, ut(i)), c2 = (i) => Zt(i, (e) => Il(i.state, e, !ut(i))), h2 = (i) => Zt(i, (e) => Il(i.state, e, ut(i)));
function d_(i, e) {
  return Zt(i, (t) => i.moveVertically(t, e));
}
const O_ = (i) => d_(i, !1), p_ = (i) => d_(i, !0);
function g_(i, e) {
  return Zt(i, (t) => i.moveVertically(t, e, a_(i).height));
}
const Bp = (i) => g_(i, !1), Xp = (i) => g_(i, !0), f2 = (i) => Zt(i, (e) => fr(i, e, !0)), u2 = (i) => Zt(i, (e) => fr(i, e, !1)), d2 = (i) => Zt(i, (e) => fr(i, e, !ut(i))), O2 = (i) => Zt(i, (e) => fr(i, e, ut(i))), p2 = (i) => Zt(i, (e) => V.cursor(i.lineBlockAt(e.head).from)), g2 = (i) => Zt(i, (e) => V.cursor(i.lineBlockAt(e.head).to)), Ip = ({ state: i, dispatch: e }) => (e(Ci(i, { anchor: 0 })), !0), Zp = ({ state: i, dispatch: e }) => (e(Ci(i, { anchor: i.doc.length })), !0), Wp = ({ state: i, dispatch: e }) => (e(Ci(i, { anchor: i.selection.main.anchor, head: 0 })), !0), zp = ({ state: i, dispatch: e }) => (e(Ci(i, { anchor: i.selection.main.anchor, head: i.doc.length })), !0), m2 = ({ state: i, dispatch: e }) => (e(i.update({ selection: { anchor: 0, head: i.doc.length }, userEvent: "select" })), !0), v2 = ({ state: i, dispatch: e }) => {
  let t = Zl(i).map(({ from: r, to: s }) => V.range(r, Math.min(s + 1, i.doc.length)));
  return e(i.update({ selection: V.create(t), userEvent: "select" })), !0;
}, S2 = ({ state: i, dispatch: e }) => {
  let t = Cs(i.selection, (r) => {
    let s = ke(i), n = s.resolveStack(r.from, 1);
    if (r.empty) {
      let o = s.resolveStack(r.from, -1);
      o.node.from >= n.node.from && o.node.to <= n.node.to && (n = o);
    }
    for (let o = n; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && o.next)
        return V.range(a.to, a.from);
    }
    return r;
  });
  return t.eq(i.selection) ? !1 : (e(Ci(i, t)), !0);
}, _2 = ({ state: i, dispatch: e }) => {
  let t = i.selection, r = null;
  return t.ranges.length > 1 ? r = V.create([t.main]) : t.main.empty || (r = V.create([V.cursor(t.main.head)])), r ? (e(Ci(i, r)), !0) : !1;
};
function vo(i, e) {
  if (i.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = i, s = r.changeByRange((n) => {
    let { from: o, to: a } = n;
    if (o == a) {
      let l = e(n);
      l < o ? (t = "delete.backward", l = Uo(i, l, !1)) : l > o && (t = "delete.forward", l = Uo(i, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = Uo(i, o, !1), a = Uo(i, a, !0);
    return o == a ? { range: n } : { changes: { from: o, to: a }, range: V.cursor(o, o < n.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (i.dispatch(r.update(s, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? K.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function Uo(i, e, t) {
  if (i instanceof K)
    for (let r of i.state.facet(K.atomicRanges).map((s) => s(i)))
      r.between(e, e, (s, n) => {
        s < e && n > e && (e = t ? n : s);
      });
  return e;
}
const m_ = (i, e, t) => vo(i, (r) => {
  let s = r.from, { state: n } = i, o = n.doc.lineAt(s), a, l;
  if (t && !e && s > o.from && s < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, s - o.from))) {
    if (a[a.length - 1] == "	")
      return s - 1;
    let c = Nt(a, n.tabSize), h = c % Ka(n) || Ka(n);
    for (let f = 0; f < h && a[a.length - 1 - f] == " "; f++)
      s--;
    l = s;
  } else
    l = it(o.text, s - o.from, e, e) + o.from, l == s && o.number != (e ? n.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, s - o.from)) && (l = it(o.text, l - o.from, !1, !1) + o.from);
  return l;
}), Qf = (i) => m_(i, !1, !0), v_ = (i) => m_(i, !0, !1), S_ = (i, e) => vo(i, (t) => {
  let r = t.head, { state: s } = i, n = s.doc.lineAt(r), o = s.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (e ? n.to : n.from)) {
      r == t.head && n.number != (e ? s.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let l = it(n.text, r - n.from, e) + n.from, c = n.text.slice(Math.min(r, l) - n.from, Math.max(r, l) - n.from), h = o(c);
    if (a != null && h != a)
      break;
    (c != " " || r != t.head) && (a = h), r = l;
  }
  return r;
}), __ = (i) => S_(i, !1), b2 = (i) => S_(i, !0), y2 = (i) => vo(i, (e) => {
  let t = i.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(i.state.doc.length, e.head + 1);
}), w2 = (i) => vo(i, (e) => {
  let t = i.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), x2 = (i) => vo(i, (e) => {
  let t = i.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(i.state.doc.length, e.head + 1);
}), k2 = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: be.of(["", ""]) },
    range: V.cursor(r.from)
  }));
  return e(i.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, C2 = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == i.doc.length)
      return { range: r };
    let s = r.from, n = i.doc.lineAt(s), o = s == n.from ? s - 1 : it(n.text, s - n.from, !1) + n.from, a = s == n.to ? s + 1 : it(n.text, s - n.from, !0) + n.from;
    return {
      changes: { from: o, to: a, insert: i.doc.slice(s, a).append(i.doc.slice(o, s)) },
      range: V.cursor(a)
    };
  });
  return t.changes.empty ? !1 : (e(i.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Zl(i) {
  let e = [], t = -1;
  for (let r of i.selection.ranges) {
    let s = i.doc.lineAt(r.from), n = i.doc.lineAt(r.to);
    if (!r.empty && r.to == n.from && (n = i.doc.lineAt(r.to - 1)), t >= s.number) {
      let o = e[e.length - 1];
      o.to = n.to, o.ranges.push(r);
    } else
      e.push({ from: s.from, to: n.to, ranges: [r] });
    t = n.number + 1;
  }
  return e;
}
function b_(i, e, t) {
  if (i.readOnly)
    return !1;
  let r = [], s = [];
  for (let n of Zl(i)) {
    if (t ? n.to == i.doc.length : n.from == 0)
      continue;
    let o = i.doc.lineAt(t ? n.to + 1 : n.from - 1), a = o.length + 1;
    if (t) {
      r.push({ from: n.to, to: o.to }, { from: n.from, insert: o.text + i.lineBreak });
      for (let l of n.ranges)
        s.push(V.range(Math.min(i.doc.length, l.anchor + a), Math.min(i.doc.length, l.head + a)));
    } else {
      r.push({ from: o.from, to: n.from }, { from: n.to, insert: i.lineBreak + o.text });
      for (let l of n.ranges)
        s.push(V.range(l.anchor - a, l.head - a));
    }
  }
  return r.length ? (e(i.update({
    changes: r,
    scrollIntoView: !0,
    selection: V.create(s, i.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Q2 = ({ state: i, dispatch: e }) => b_(i, e, !1), P2 = ({ state: i, dispatch: e }) => b_(i, e, !0);
function y_(i, e, t) {
  if (i.readOnly)
    return !1;
  let r = [];
  for (let s of Zl(i))
    t ? r.push({ from: s.from, insert: i.doc.slice(s.from, s.to) + i.lineBreak }) : r.push({ from: s.to, insert: i.lineBreak + i.doc.slice(s.from, s.to) });
  return e(i.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const $2 = ({ state: i, dispatch: e }) => y_(i, e, !1), T2 = ({ state: i, dispatch: e }) => y_(i, e, !0), R2 = (i) => {
  if (i.state.readOnly)
    return !1;
  let { state: e } = i, t = e.changes(Zl(e).map(({ from: s, to: n }) => (s > 0 ? s-- : n < e.doc.length && n++, { from: s, to: n }))), r = Cs(e.selection, (s) => {
    let n;
    if (i.lineWrapping) {
      let o = i.lineBlockAt(s.head), a = i.coordsAtPos(s.head, s.assoc || 1);
      a && (n = o.bottom + i.documentTop - a.bottom + i.defaultLineHeight / 2);
    }
    return i.moveVertically(s, !0, n);
  }).map(t);
  return i.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function E2(i, e) {
  if (/\(\)|\[\]|\{\}/.test(i.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = ke(i).resolveInner(e), r = t.childBefore(e), s = t.childAfter(e), n;
  return r && s && r.to <= e && s.from >= e && (n = r.type.prop(le.closedBy)) && n.indexOf(s.name) > -1 && i.doc.lineAt(r.to).from == i.doc.lineAt(s.from).from && !/\S/.test(i.sliceDoc(r.to, s.from)) ? { from: r.to, to: s.from } : null;
}
const Vp = /* @__PURE__ */ w_(!1), A2 = /* @__PURE__ */ w_(!0);
function w_(i) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((s) => {
      let { from: n, to: o } = s, a = e.doc.lineAt(n), l = !i && n == o && E2(e, n);
      i && (n = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new Dl(e, { simulateBreak: n, simulateDoubleBreak: !!l }), h = zu(c, n);
      for (h == null && (h = Nt(/^\s*/.exec(e.doc.lineAt(n).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: n, to: o } = l : n > a.from && n < a.from + 100 && !/\S/.test(a.text.slice(0, n)) && (n = a.from);
      let f = ["", In(e, h)];
      return l && f.push(In(e, c.lineIndent(a.from, -1))), {
        changes: { from: n, to: o, insert: be.of(f) },
        range: V.cursor(n + 1 + f[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Yu(i, e) {
  let t = -1;
  return i.changeByRange((r) => {
    let s = [];
    for (let o = r.from; o <= r.to; ) {
      let a = i.doc.lineAt(o);
      a.number > t && (r.empty || r.to > a.from) && (e(a, s, r), t = a.number), o = a.to + 1;
    }
    let n = i.changes(s);
    return {
      changes: s,
      range: V.range(n.mapPos(r.anchor, 1), n.mapPos(r.head, 1))
    };
  });
}
const L2 = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new Dl(i, { overrideIndentation: (n) => {
    let o = t[n];
    return o ?? -1;
  } }), s = Yu(i, (n, o, a) => {
    let l = zu(r, n.from);
    if (l == null)
      return;
    /\S/.test(n.text) || (l = 0);
    let c = /^\s*/.exec(n.text)[0], h = In(i, l);
    (c != h || a.from < n.from + c.length) && (t[n.from] = l, o.push({ from: n.from, to: n.from + c.length, insert: h }));
  });
  return s.changes.empty || e(i.update(s, { userEvent: "indent" })), !0;
}, M2 = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(Yu(i, (t, r) => {
  r.push({ from: t.from, insert: i.facet(po) });
}), { userEvent: "input.indent" })), !0), D2 = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(Yu(i, (t, r) => {
  let s = /^\s*/.exec(t.text)[0];
  if (!s)
    return;
  let n = Nt(s, i.tabSize), o = 0, a = In(i, Math.max(0, n - Ka(i)));
  for (; o < s.length && o < a.length && s.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  r.push({ from: t.from + o, to: t.from + s.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), q2 = (i) => (i.setTabFocusMode(), !0), B2 = [
  { key: "Ctrl-b", run: t_, shift: h_, preventDefault: !0 },
  { key: "Ctrl-f", run: i_, shift: f_ },
  { key: "Ctrl-p", run: n_, shift: O_ },
  { key: "Ctrl-n", run: o_, shift: p_ },
  { key: "Ctrl-a", run: r2, shift: p2 },
  { key: "Ctrl-e", run: s2, shift: g2 },
  { key: "Ctrl-d", run: v_ },
  { key: "Ctrl-h", run: Qf },
  { key: "Ctrl-k", run: y2 },
  { key: "Ctrl-Alt-h", run: __ },
  { key: "Ctrl-o", run: k2 },
  { key: "Ctrl-t", run: C2 },
  { key: "Ctrl-v", run: Cf }
], X2 = /* @__PURE__ */ [
  { key: "ArrowLeft", run: t_, shift: h_, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: YR, shift: a2, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: t2, shift: d2, preventDefault: !0 },
  { key: "ArrowRight", run: i_, shift: f_, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: FR, shift: l2, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: i2, shift: O2, preventDefault: !0 },
  { key: "ArrowUp", run: n_, shift: O_, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Ip, shift: Wp },
  { mac: "Ctrl-ArrowUp", run: qp, shift: Bp },
  { key: "ArrowDown", run: o_, shift: p_, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Zp, shift: zp },
  { mac: "Ctrl-ArrowDown", run: Cf, shift: Xp },
  { key: "PageUp", run: qp, shift: Bp },
  { key: "PageDown", run: Cf, shift: Xp },
  { key: "Home", run: e2, shift: u2, preventDefault: !0 },
  { key: "Mod-Home", run: Ip, shift: Wp },
  { key: "End", run: JR, shift: f2, preventDefault: !0 },
  { key: "Mod-End", run: Zp, shift: zp },
  { key: "Enter", run: Vp, shift: Vp },
  { key: "Mod-a", run: m2 },
  { key: "Backspace", run: Qf, shift: Qf },
  { key: "Delete", run: v_ },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: __ },
  { key: "Mod-Delete", mac: "Alt-Delete", run: b2 },
  { mac: "Mod-Backspace", run: w2 },
  { mac: "Mod-Delete", run: x2 }
].concat(/* @__PURE__ */ B2.map((i) => ({ mac: i.key, run: i.run, shift: i.shift }))), I2 = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: GR, shift: c2 },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: KR, shift: h2 },
  { key: "Alt-ArrowUp", run: Q2 },
  { key: "Shift-Alt-ArrowUp", run: $2 },
  { key: "Alt-ArrowDown", run: P2 },
  { key: "Shift-Alt-ArrowDown", run: T2 },
  { key: "Escape", run: _2 },
  { key: "Mod-Enter", run: A2 },
  { key: "Alt-l", mac: "Ctrl-l", run: v2 },
  { key: "Mod-i", run: S2, preventDefault: !0 },
  { key: "Mod-[", run: D2 },
  { key: "Mod-]", run: M2 },
  { key: "Mod-Alt-\\", run: L2 },
  { key: "Shift-Mod-k", run: R2 },
  { key: "Shift-Mod-\\", run: o2 },
  { key: "Mod-/", run: $R },
  { key: "Alt-A", run: RR },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: q2 }
].concat(X2), Up = typeof String.prototype.normalize == "function" ? (i) => i.normalize("NFKD") : (i) => i;
class gs {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, s = e.length, n, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, s), this.bufferStart = r, this.normalize = n ? (a) => n(Up(a)) : Up, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return vt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = _u(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += hi(e);
      let s = this.normalize(t);
      if (s.length)
        for (let n = 0, o = r; ; n++) {
          let a = s.charCodeAt(n), l = this.match(a, o, this.bufferPos + this.bufferStart);
          if (n == s.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          o == r && n < t.length && t.charCodeAt(n) == a && o++;
        }
    }
  }
  match(e, t, r) {
    let s = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let o = this.matches[n], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? s = { from: this.matches[n + 1], to: r } : (this.matches[n]++, a = !0)), a || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? s = { from: t, to: r } : this.matches.push(1, t)), s && this.test && !this.test(s.from, s.to, this.buffer, this.bufferStart) && (s = null), s;
  }
}
typeof Symbol < "u" && (gs.prototype[Symbol.iterator] = function() {
  return this;
});
const x_ = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Fu = "gm" + (/x/.unicode == null ? "" : "u");
class k_ {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, s = 0, n = e.length) {
    if (this.text = e, this.to = n, this.curLine = "", this.done = !1, this.value = x_, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new C_(e, t, r, s, n);
    this.re = new RegExp(t, Fu + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let o = e.lineAt(s);
    this.curLineStart = o.from, this.matchPos = il(e, s), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, s = r + t[0].length;
        if (this.matchPos = il(this.text, s + (r == s ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < s || r > this.value.to) && (!this.test || this.test(r, s, t)))
          return this.value = { from: r, to: s, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Rc = /* @__PURE__ */ new WeakMap();
class os {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let s = Rc.get(e);
    if (!s || s.from >= r || s.to <= t) {
      let a = new os(t, e.sliceString(t, r));
      return Rc.set(e, a), a;
    }
    if (s.from == t && s.to == r)
      return s;
    let { text: n, from: o } = s;
    return o > t && (n = e.sliceString(t, o) + n, o = t), s.to < r && (n += e.sliceString(s.to, r)), Rc.set(e, new os(o, n)), new os(t, n.slice(t - o, r - o));
  }
}
class C_ {
  constructor(e, t, r, s, n) {
    this.text = e, this.to = n, this.done = !1, this.value = x_, this.matchPos = il(e, s), this.re = new RegExp(t, Fu + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = os.get(e, s, this.chunkEnd(
      s + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, s = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, s, t)))
          return this.value = { from: r, to: s, match: t }, this.matchPos = il(this.text, s + (r == s ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = os.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (k_.prototype[Symbol.iterator] = C_.prototype[Symbol.iterator] = function() {
  return this;
});
function Z2(i) {
  try {
    return new RegExp(i, Fu), !0;
  } catch {
    return !1;
  }
}
function il(i, e) {
  if (e >= i.length)
    return e;
  let t = i.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function Pf(i) {
  let e = String(i.state.doc.lineAt(i.state.selection.main.head).number), t = Pe("input", { class: "cm-textfield", name: "line", value: e }), r = Pe("form", {
    class: "cm-gotoLine",
    onkeydown: (n) => {
      n.keyCode == 27 ? (n.preventDefault(), i.dispatch({ effects: hn.of(!1) }), i.focus()) : n.keyCode == 13 && (n.preventDefault(), s());
    },
    onsubmit: (n) => {
      n.preventDefault(), s();
    }
  }, Pe("label", i.state.phrase("Go to line"), ": ", t), " ", Pe("button", { class: "cm-button", type: "submit" }, i.state.phrase("go")), Pe("button", {
    name: "close",
    onclick: () => {
      i.dispatch({ effects: hn.of(!1) }), i.focus();
    },
    "aria-label": i.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function s() {
    let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!n)
      return;
    let { state: o } = i, a = o.doc.lineAt(o.selection.main.head), [, l, c, h, f] = n, u = h ? +h.slice(1) : 0, g = c ? +c : a.number;
    if (c && f) {
      let d = g / 100;
      l && (d = d * (l == "-" ? -1 : 1) + a.number / o.doc.lines), g = Math.round(o.doc.lines * d);
    } else c && l && (g = g * (l == "-" ? -1 : 1) + a.number);
    let S = o.doc.line(Math.max(1, Math.min(o.doc.lines, g))), v = V.cursor(S.from + Math.max(0, Math.min(u, S.length)));
    i.dispatch({
      effects: [hn.of(!1), K.scrollIntoView(v.from, { y: "center" })],
      selection: v
    }), i.focus();
  }
  return { dom: r };
}
const hn = /* @__PURE__ */ he.define(), jp = /* @__PURE__ */ Ge.define({
  create() {
    return !0;
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(hn) && (i = t.value);
    return i;
  },
  provide: (i) => Dn.from(i, (e) => e ? Pf : null)
}), W2 = (i) => {
  let e = Mn(i, Pf);
  if (!e) {
    let t = [hn.of(!0)];
    i.state.field(jp, !1) == null && t.push(he.appendConfig.of([jp, z2])), i.dispatch({ effects: t }), e = Mn(i, Pf);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, z2 = /* @__PURE__ */ K.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), V2 = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, U2 = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, V2, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function j2(i) {
  return [G2, H2];
}
const N2 = /* @__PURE__ */ ae.mark({ class: "cm-selectionMatch" }), Y2 = /* @__PURE__ */ ae.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Np(i, e, t, r) {
  return (t == 0 || i(e.sliceDoc(t - 1, t)) != De.Word) && (r == e.doc.length || i(e.sliceDoc(r, r + 1)) != De.Word);
}
function F2(i, e, t, r) {
  return i(e.sliceDoc(t, t + 1)) == De.Word && i(e.sliceDoc(r - 1, r)) == De.Word;
}
const H2 = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.selectionSet || i.docChanged || i.viewportChanged) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = i.state.facet(U2), { state: t } = i, r = t.selection;
    if (r.ranges.length > 1)
      return ae.none;
    let s = r.main, n, o = null;
    if (s.empty) {
      if (!e.highlightWordAroundCursor)
        return ae.none;
      let l = t.wordAt(s.head);
      if (!l)
        return ae.none;
      o = t.charCategorizer(s.head), n = t.sliceDoc(l.from, l.to);
    } else {
      let l = s.to - s.from;
      if (l < e.minSelectionLength || l > 200)
        return ae.none;
      if (e.wholeWords) {
        if (n = t.sliceDoc(s.from, s.to), o = t.charCategorizer(s.head), !(Np(o, t, s.from, s.to) && F2(o, t, s.from, s.to)))
          return ae.none;
      } else if (n = t.sliceDoc(s.from, s.to), !n)
        return ae.none;
    }
    let a = [];
    for (let l of i.visibleRanges) {
      let c = new gs(t.doc, n, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: h, to: f } = c.value;
        if ((!o || Np(o, t, h, f)) && (s.empty && h <= s.from && f >= s.to ? a.push(Y2.range(h, f)) : (h >= s.to || f <= s.from) && a.push(N2.range(h, f)), a.length > e.maxMatches))
          return ae.none;
      }
    }
    return ae.set(a);
  }
}, {
  decorations: (i) => i.decorations
}), G2 = /* @__PURE__ */ K.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), K2 = ({ state: i, dispatch: e }) => {
  let { selection: t } = i, r = V.create(t.ranges.map((s) => i.wordAt(s.head) || V.cursor(s.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(i.update({ selection: r })), !0);
};
function J2(i, e) {
  let { main: t, ranges: r } = i.selection, s = i.wordAt(t.head), n = s && s.from == t.from && s.to == t.to;
  for (let o = !1, a = new gs(i.doc, e, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new gs(i.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((l) => l.from == a.value.from))
        continue;
      if (n) {
        let l = i.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const eE = ({ state: i, dispatch: e }) => {
  let { ranges: t } = i.selection;
  if (t.some((n) => n.from === n.to))
    return K2({ state: i, dispatch: e });
  let r = i.sliceDoc(t[0].from, t[0].to);
  if (i.selection.ranges.some((n) => i.sliceDoc(n.from, n.to) != r))
    return !1;
  let s = J2(i, r);
  return s ? (e(i.update({
    selection: i.selection.addRange(V.range(s.from, s.to), !1),
    effects: K.scrollIntoView(s.to)
  })), !0) : !1;
}, Qs = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new uE(e),
      scrollToMatch: (e) => K.scrollIntoView(e)
    });
  }
});
class Q_ {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Z2(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new sE(this) : new iE(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let s = e.doc ? e : _e.create({ doc: e });
    return r == null && (r = s.doc.length), this.regexp ? Yr(this, s, t, r) : Nr(this, s, t, r);
  }
}
class P_ {
  constructor(e) {
    this.spec = e;
  }
}
function Nr(i, e, t, r) {
  return new gs(e.doc, i.unquoted, t, r, i.caseSensitive ? void 0 : (s) => s.toLowerCase(), i.wholeWord ? tE(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function tE(i, e) {
  return (t, r, s, n) => ((n > t || n + s.length < r) && (n = Math.max(0, t - 2), s = i.sliceString(n, Math.min(i.length, r + 2))), (e(rl(s, t - n)) != De.Word || e(sl(s, t - n)) != De.Word) && (e(sl(s, r - n)) != De.Word || e(rl(s, r - n)) != De.Word));
}
class iE extends P_ {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let s = Nr(this.spec, e, r, e.doc.length).nextOverlapping();
    if (s.done) {
      let n = Math.min(e.doc.length, t + this.spec.unquoted.length);
      s = Nr(this.spec, e, 0, n).nextOverlapping();
    }
    return s.done || s.value.from == t && s.value.to == r ? null : s.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let s = r; ; ) {
      let n = Math.max(t, s - 1e4 - this.spec.unquoted.length), o = Nr(this.spec, e, n, s), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (n == t)
        return null;
      s -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    let s = this.prevMatchInRange(e, 0, t);
    return s || (s = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), s && (s.from != t || s.to != r) ? s : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = Nr(this.spec, e, 0, e.doc.length), s = [];
    for (; !r.next().done; ) {
      if (s.length >= t)
        return null;
      s.push(r.value);
    }
    return s;
  }
  highlight(e, t, r, s) {
    let n = Nr(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !n.next().done; )
      s(n.value.from, n.value.to);
  }
}
function Yr(i, e, t, r) {
  return new k_(e.doc, i.search, {
    ignoreCase: !i.caseSensitive,
    test: i.wholeWord ? rE(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function rl(i, e) {
  return i.slice(it(i, e, !1), e);
}
function sl(i, e) {
  return i.slice(e, it(i, e));
}
function rE(i) {
  return (e, t, r) => !r[0].length || (i(rl(r.input, r.index)) != De.Word || i(sl(r.input, r.index)) != De.Word) && (i(sl(r.input, r.index + r[0].length)) != De.Word || i(rl(r.input, r.index + r[0].length)) != De.Word);
}
class sE extends P_ {
  nextMatch(e, t, r) {
    let s = Yr(this.spec, e, r, e.doc.length).next();
    return s.done && (s = Yr(this.spec, e, 0, t).next()), s.done ? null : s.value;
  }
  prevMatchInRange(e, t, r) {
    for (let s = 1; ; s++) {
      let n = Math.max(
        t,
        r - s * 1e4
        /* FindPrev.ChunkSize */
      ), o = Yr(this.spec, e, n, r), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (n == t || a.from > n + 10))
        return a;
      if (n == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let s = r.length; s > 0; s--) {
        let n = +r.slice(0, s);
        if (n > 0 && n < e.match.length)
          return e.match[n] + r.slice(s);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let r = Yr(this.spec, e, 0, e.doc.length), s = [];
    for (; !r.next().done; ) {
      if (s.length >= t)
        return null;
      s.push(r.value);
    }
    return s;
  }
  highlight(e, t, r, s) {
    let n = Yr(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !n.next().done; )
      s(n.value.from, n.value.to);
  }
}
const Zn = /* @__PURE__ */ he.define(), Hu = /* @__PURE__ */ he.define(), ir = /* @__PURE__ */ Ge.define({
  create(i) {
    return new Ec($f(i).create(), null);
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(Zn) ? i = new Ec(t.value.create(), i.panel) : t.is(Hu) && (i = new Ec(i.query, t.value ? Gu : null));
    return i;
  },
  provide: (i) => Dn.from(i, (e) => e.panel)
});
class Ec {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const nE = /* @__PURE__ */ ae.mark({ class: "cm-searchMatch" }), oE = /* @__PURE__ */ ae.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), aE = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.view = i, this.decorations = this.highlight(i.state.field(ir));
  }
  update(i) {
    let e = i.state.field(ir);
    (e != i.startState.field(ir) || i.docChanged || i.selectionSet || i.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: i, panel: e }) {
    if (!e || !i.spec.valid)
      return ae.none;
    let { view: t } = this, r = new Ii();
    for (let s = 0, n = t.visibleRanges, o = n.length; s < o; s++) {
      let { from: a, to: l } = n[s];
      for (; s < o - 1 && l > n[s + 1].from - 2 * 250; )
        l = n[++s].to;
      i.highlight(t.state, a, l, (c, h) => {
        let f = t.state.selection.ranges.some((u) => u.from == c && u.to == h);
        r.add(c, h, f ? oE : nE);
      });
    }
    return r.finish();
  }
}, {
  decorations: (i) => i.decorations
});
function So(i) {
  return (e) => {
    let t = e.state.field(ir, !1);
    return t && t.query.spec.valid ? i(e, t) : R_(e);
  };
}
const nl = /* @__PURE__ */ So((i, { query: e }) => {
  let { to: t } = i.state.selection.main, r = e.nextMatch(i.state, t, t);
  if (!r)
    return !1;
  let s = V.single(r.from, r.to), n = i.state.facet(Qs);
  return i.dispatch({
    selection: s,
    effects: [Ku(i, r), n.scrollToMatch(s.main, i)],
    userEvent: "select.search"
  }), T_(i), !0;
}), ol = /* @__PURE__ */ So((i, { query: e }) => {
  let { state: t } = i, { from: r } = t.selection.main, s = e.prevMatch(t, r, r);
  if (!s)
    return !1;
  let n = V.single(s.from, s.to), o = i.state.facet(Qs);
  return i.dispatch({
    selection: n,
    effects: [Ku(i, s), o.scrollToMatch(n.main, i)],
    userEvent: "select.search"
  }), T_(i), !0;
}), lE = /* @__PURE__ */ So((i, { query: e }) => {
  let t = e.matchAll(i.state, 1e3);
  return !t || !t.length ? !1 : (i.dispatch({
    selection: V.create(t.map((r) => V.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), cE = ({ state: i, dispatch: e }) => {
  let t = i.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: s } = t.main, n = [], o = 0;
  for (let a = new gs(i.doc, i.sliceDoc(r, s)); !a.next().done; ) {
    if (n.length > 1e3)
      return !1;
    a.value.from == r && (o = n.length), n.push(V.range(a.value.from, a.value.to));
  }
  return e(i.update({
    selection: V.create(n, o),
    userEvent: "select.search.matches"
  })), !0;
}, Yp = /* @__PURE__ */ So((i, { query: e }) => {
  let { state: t } = i, { from: r, to: s } = t.selection.main;
  if (t.readOnly)
    return !1;
  let n = e.nextMatch(t, r, r);
  if (!n)
    return !1;
  let o = n, a = [], l, c, h = [];
  o.from == r && o.to == s && (c = t.toText(e.getReplacement(o)), a.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), h.push(K.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + ".")));
  let f = i.state.changes(a);
  return o && (l = V.single(o.from, o.to).map(f), h.push(Ku(i, o)), h.push(t.facet(Qs).scrollToMatch(l.main, i))), i.dispatch({
    changes: f,
    selection: l,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), hE = /* @__PURE__ */ So((i, { query: e }) => {
  if (i.state.readOnly)
    return !1;
  let t = e.matchAll(i.state, 1e9).map((s) => {
    let { from: n, to: o } = s;
    return { from: n, to: o, insert: e.getReplacement(s) };
  });
  if (!t.length)
    return !1;
  let r = i.state.phrase("replaced $ matches", t.length) + ".";
  return i.dispatch({
    changes: t,
    effects: K.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Gu(i) {
  return i.state.facet(Qs).createPanel(i);
}
function $f(i, e) {
  var t, r, s, n, o;
  let a = i.selection.main, l = a.empty || a.to > a.from + 100 ? "" : i.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = i.facet(Qs);
  return new Q_({
    search: ((t = e?.literal) !== null && t !== void 0 ? t : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (s = e?.literal) !== null && s !== void 0 ? s : c.literal,
    regexp: (n = e?.regexp) !== null && n !== void 0 ? n : c.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function $_(i) {
  let e = Mn(i, Gu);
  return e && e.dom.querySelector("[main-field]");
}
function T_(i) {
  let e = $_(i);
  e && e == i.root.activeElement && e.select();
}
const R_ = (i) => {
  let e = i.state.field(ir, !1);
  if (e && e.panel) {
    let t = $_(i);
    if (t && t != i.root.activeElement) {
      let r = $f(i.state, e.query.spec);
      r.valid && i.dispatch({ effects: Zn.of(r) }), t.focus(), t.select();
    }
  } else
    i.dispatch({ effects: [
      Hu.of(!0),
      e ? Zn.of($f(i.state, e.query.spec)) : he.appendConfig.of(OE)
    ] });
  return !0;
}, E_ = (i) => {
  let e = i.state.field(ir, !1);
  if (!e || !e.panel)
    return !1;
  let t = Mn(i, Gu);
  return t && t.dom.contains(i.root.activeElement) && i.focus(), i.dispatch({ effects: Hu.of(!1) }), !0;
}, fE = [
  { key: "Mod-f", run: R_, scope: "editor search-panel" },
  { key: "F3", run: nl, shift: ol, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: nl, shift: ol, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: E_, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: cE },
  { key: "Mod-Alt-g", run: W2 },
  { key: "Mod-d", run: eE, preventDefault: !0 }
];
class uE {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(ir).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Pe("input", {
      value: t.search,
      placeholder: Ct(e, "Find"),
      "aria-label": Ct(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Pe("input", {
      value: t.replace,
      placeholder: Ct(e, "Replace"),
      "aria-label": Ct(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Pe("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Pe("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Pe("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(s, n, o) {
      return Pe("button", { class: "cm-button", name: s, onclick: n, type: "button" }, o);
    }
    this.dom = Pe("div", { onkeydown: (s) => this.keydown(s), class: "cm-search" }, [
      this.searchField,
      r("next", () => nl(e), [Ct(e, "next")]),
      r("prev", () => ol(e), [Ct(e, "previous")]),
      r("select", () => lE(e), [Ct(e, "all")]),
      Pe("label", null, [this.caseField, Ct(e, "match case")]),
      Pe("label", null, [this.reField, Ct(e, "regexp")]),
      Pe("label", null, [this.wordField, Ct(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Pe("br"),
        this.replaceField,
        r("replace", () => Yp(e), [Ct(e, "replace")]),
        r("replaceAll", () => hE(e), [Ct(e, "replace all")])
      ],
      Pe("button", {
        name: "close",
        onclick: () => E_(e),
        "aria-label": Ct(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new Q_({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Zn.of(e) }));
  }
  keydown(e) {
    b$(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? ol : nl)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Yp(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Zn) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Qs).top;
  }
}
function Ct(i, e) {
  return i.state.phrase(e);
}
const jo = 30, No = /[\s\.,:;?!]/;
function Ku(i, { from: e, to: t }) {
  let r = i.state.doc.lineAt(e), s = i.state.doc.lineAt(t).to, n = Math.max(r.from, e - jo), o = Math.min(s, t + jo), a = i.state.sliceDoc(n, o);
  if (n != r.from) {
    for (let l = 0; l < jo; l++)
      if (!No.test(a[l + 1]) && No.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != s) {
    for (let l = a.length - 1; l > a.length - jo; l--)
      if (!No.test(a[l - 1]) && No.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return K.announce.of(`${i.state.phrase("current match")}. ${a} ${i.state.phrase("on line")} ${r.number}.`);
}
const dE = /* @__PURE__ */ K.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), OE = [
  ir,
  /* @__PURE__ */ Vi.low(aE),
  dE
];
class Ju {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r, s) {
    this.state = e, this.pos = t, this.explicit = r, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = ke(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), s = t.text.slice(r - t.from, this.pos - t.from), n = s.search(A_(e, !1));
    return n < 0 ? null : { from: r + n, to: this.pos, text: s.slice(n) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function Fp(i) {
  let e = Object.keys(i).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function pE(i) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of i) {
    e[s[0]] = !0;
    for (let n = 1; n < s.length; n++)
      t[s[n]] = !0;
  }
  let r = Fp(e) + Fp(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function Wl(i) {
  let e = i.map((s) => typeof s == "string" ? { label: s } : s), [t, r] = e.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : pE(e);
  return (s) => {
    let n = s.matchBefore(r);
    return n || s.explicit ? { from: n ? n.from : s.pos, options: e, validFor: t } : null;
  };
}
function ed(i, e) {
  return (t) => {
    for (let r = ke(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (i.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class Hp {
  constructor(e, t, r, s) {
    this.completion = e, this.source = t, this.match = r, this.score = s;
  }
}
function $r(i) {
  return i.selection.main.from;
}
function A_(i, e) {
  var t;
  let { source: r } = i, s = e && r[0] != "^", n = r[r.length - 1] != "$";
  return !s && !n ? i : new RegExp(`${s ? "^" : ""}(?:${r})${n ? "$" : ""}`, (t = i.flags) !== null && t !== void 0 ? t : i.ignoreCase ? "i" : "");
}
const td = /* @__PURE__ */ Ui.define();
function gE(i, e, t, r) {
  let { main: s } = i.selection, n = t - s.from, o = r - s.from;
  return Object.assign(Object.assign({}, i.changeByRange((a) => {
    if (a != s && t != r && i.sliceDoc(a.from + n, a.from + o) != i.sliceDoc(t, r))
      return { range: a };
    let l = i.toText(e);
    return {
      changes: { from: a.from + n, to: r == s.from ? a.to : a.from + o, insert: l },
      range: V.cursor(a.from + n + l.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Gp = /* @__PURE__ */ new WeakMap();
function mE(i) {
  if (!Array.isArray(i))
    return i;
  let e = Gp.get(i);
  return e || Gp.set(i, e = Wl(i)), e;
}
const al = /* @__PURE__ */ he.define(), Wn = /* @__PURE__ */ he.define();
class vE {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = vt(e, t), s = hi(r);
      this.chars.push(r);
      let n = e.slice(t, t + s), o = n.toUpperCase();
      this.folded.push(vt(o == n ? n.toLowerCase() : o, 0)), t += s;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: s, precise: n, byWord: o } = this;
    if (t.length == 1) {
      let p = vt(e, 0), m = hi(p), _ = m == e.length ? 0 : -100;
      if (p != t[0]) if (p == r[0])
        _ += -200;
      else
        return null;
      return this.ret(_, [0, m]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, c = 0;
    if (a < 0) {
      for (let p = 0, m = Math.min(e.length, 200); p < m && c < l; ) {
        let _ = vt(e, p);
        (_ == t[c] || _ == r[c]) && (s[c++] = p), p += hi(_);
      }
      if (c < l)
        return null;
    }
    let h = 0, f = 0, u = !1, g = 0, S = -1, v = -1, d = /[a-z]/.test(e), O = !0;
    for (let p = 0, m = Math.min(e.length, 200), _ = 0; p < m && f < l; ) {
      let b = vt(e, p);
      a < 0 && (h < l && b == t[h] && (n[h++] = p), g < l && (b == t[g] || b == r[g] ? (g == 0 && (S = p), v = p + 1, g++) : g = 0));
      let w, x = b < 255 ? b >= 48 && b <= 57 || b >= 97 && b <= 122 ? 2 : b >= 65 && b <= 90 ? 1 : 0 : (w = _u(b)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
      (!p || x == 1 && d || _ == 0 && x != 0) && (t[f] == b || r[f] == b && (u = !0) ? o[f++] = p : o.length && (O = !1)), _ = x, p += hi(b);
    }
    return f == l && o[0] == 0 && O ? this.result(-100 + (u ? -200 : 0), o, e) : g == l && S == 0 ? this.ret(-200 - e.length + (v == e.length ? 0 : -100), [0, v]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : g == l ? this.ret(-900 - e.length, [S, v]) : f == l ? this.result(-100 + (u ? -200 : 0) + -700 + (O ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, e);
  }
  result(e, t, r) {
    let s = [], n = 0;
    for (let o of t) {
      let a = o + (this.astral ? hi(vt(r, o)) : 1);
      n && s[n - 1] == o ? s[n - 1] = a : (s[n++] = o, s[n++] = a);
    }
    return this.ret(e - r.length, s);
  }
}
class SE {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), r = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, t.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Ye = /* @__PURE__ */ ee.define({
  combine(i) {
    return xi(i, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: _E,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => Kp(e(r), t(r)),
      optionClass: (e, t) => (r) => Kp(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function Kp(i, e) {
  return i ? e ? i + " " + e : i : e;
}
function _E(i, e, t, r, s, n) {
  let o = i.textDirection == Me.RTL, a = o, l = !1, c = "top", h, f, u = e.left - s.left, g = s.right - e.right, S = r.right - r.left, v = r.bottom - r.top;
  if (a && u < Math.min(S, g) ? a = !1 : !a && g < Math.min(S, u) && (a = !0), S <= (a ? u : g))
    h = Math.max(s.top, Math.min(t.top, s.bottom - v)) - e.top, f = Math.min(400, a ? u : g);
  else {
    l = !0, f = Math.min(
      400,
      (o ? e.right : s.right - e.left) - 30
      /* Info.Margin */
    );
    let p = s.bottom - e.bottom;
    p >= v || p > e.top ? h = t.bottom - e.top : (c = "bottom", h = e.bottom - t.top);
  }
  let d = (e.bottom - e.top) / n.offsetHeight, O = (e.right - e.left) / n.offsetWidth;
  return {
    style: `${c}: ${h / d}px; max-width: ${f / O}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function bE(i) {
  let e = i.addToOptions.slice();
  return i.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, s, n) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = t.displayLabel || t.label, l = 0;
      for (let c = 0; c < n.length; ) {
        let h = n[c++], f = n[c++];
        h > l && o.appendChild(document.createTextNode(a.slice(l, h)));
        let u = o.appendChild(document.createElement("span"));
        u.appendChild(document.createTextNode(a.slice(h, f))), u.className = "cm-completionMatchedText", l = f;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function Ac(i, e, t) {
  if (i <= t)
    return { from: 0, to: i };
  if (e < 0 && (e = 0), e <= i >> 1) {
    let s = Math.floor(e / t);
    return { from: s * t, to: (s + 1) * t };
  }
  let r = Math.floor((i - e) / t);
  return { from: i - (r + 1) * t, to: i - r * t };
}
class yE {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = e.state.field(t), { options: n, selected: o } = s.open, a = e.state.facet(Ye);
    this.optionContent = bE(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Ac(n.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(t).open;
      for (let h = l.target, f; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (f = /-(\d+)$/.exec(h.id)) && +f[1] < c.length) {
          this.applyCompletion(e, c[+f[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Ye).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: Wn.of(null) });
    }), this.showOptions(n, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), s = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != s) {
      let { options: n, selected: o, disabled: a } = r.open;
      (!s.open || s.open.options != n) && (this.range = Ac(n.length, o, e.state.facet(Ye).maxRenderedOptions), this.showOptions(n, r.id)), this.updateSel(), a != ((t = s.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Ac(t.options.length, t.selected, this.view.state.facet(Ye).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: s } = r;
      if (!s)
        return;
      let n = typeof s == "string" ? document.createTextNode(s) : s(r);
      if (!n)
        return;
      "then" in n ? n.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => bt(this.view.state, o, "completion info")) : this.addInfoPane(n, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: s, destroy: n } = e;
      r.appendChild(s), this.infoDestroy = n || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, s = this.range.from; r; r = r.nextSibling, s++)
      r.nodeName != "LI" || !r.id ? s-- : s == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && xE(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), s = e.getBoundingClientRect(), n = this.space;
    if (!n) {
      let o = this.dom.ownerDocument.documentElement;
      n = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return s.top > Math.min(n.bottom, t.bottom) - 10 || s.bottom < Math.max(n.top, t.top) + 10 ? null : this.view.state.facet(Ye).positionInfo(this.view, t, s, r, n, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const s = document.createElement("ul");
    s.id = t, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")), s.addEventListener("mousedown", (o) => {
      o.target == s && o.preventDefault();
    });
    let n = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let u = typeof c == "string" ? c : c.name;
        if (u != n && (o > r.from || r.from == 0))
          if (n = u, typeof c != "string" && c.header)
            s.appendChild(c.header(c));
          else {
            let g = s.appendChild(document.createElement("completion-section"));
            g.textContent = u;
          }
      }
      const h = s.appendChild(document.createElement("li"));
      h.id = t + "-" + o, h.setAttribute("role", "option");
      let f = this.optionClass(a);
      f && (h.className = f);
      for (let u of this.optionContent) {
        let g = u(a, this.view.state, this.view, l);
        g && h.appendChild(g);
      }
    }
    return r.from && s.classList.add("cm-completionListIncompleteTop"), r.to < e.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function wE(i, e) {
  return (t) => new yE(t, i, e);
}
function xE(i, e) {
  let t = i.getBoundingClientRect(), r = e.getBoundingClientRect(), s = t.height / i.offsetHeight;
  r.top < t.top ? i.scrollTop -= (t.top - r.top) / s : r.bottom > t.bottom && (i.scrollTop += (r.bottom - t.bottom) / s);
}
function Jp(i) {
  return (i.boost || 0) * 100 + (i.apply ? 10 : 0) + (i.info ? 5 : 0) + (i.type ? 1 : 0);
}
function kE(i, e) {
  let t = [], r = null, s = (c) => {
    t.push(c);
    let { section: h } = c.completion;
    if (h) {
      r || (r = []);
      let f = typeof h == "string" ? h : h.name;
      r.some((u) => u.name == f) || r.push(typeof h == "string" ? { name: f } : h);
    }
  }, n = e.facet(Ye);
  for (let c of i)
    if (c.hasResult()) {
      let h = c.result.getMatch;
      if (c.result.filter === !1)
        for (let f of c.result.options)
          s(new Hp(f, c.source, h ? h(f) : [], 1e9 - t.length));
      else {
        let f = e.sliceDoc(c.from, c.to), u, g = n.filterStrict ? new SE(f) : new vE(f);
        for (let S of c.result.options)
          if (u = g.match(S.label)) {
            let v = S.displayLabel ? h ? h(S, u.matched) : [] : u.matched;
            s(new Hp(S, c.source, v, u.score + (S.boost || 0)));
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), h = 0, f = (u, g) => {
      var S, v;
      return ((S = u.rank) !== null && S !== void 0 ? S : 1e9) - ((v = g.rank) !== null && v !== void 0 ? v : 1e9) || (u.name < g.name ? -1 : 1);
    };
    for (let u of r.sort(f))
      h -= 1e5, c[u.name] = h;
    for (let u of t) {
      let { section: g } = u.completion;
      g && (u.score += c[typeof g == "string" ? g : g.name]);
    }
  }
  let o = [], a = null, l = n.compareCompletions;
  for (let c of t.sort((h, f) => f.score - h.score || l(h.completion, f.completion))) {
    let h = c.completion;
    !a || a.label != h.label || a.detail != h.detail || a.type != null && h.type != null && a.type != h.type || a.apply != h.apply || a.boost != h.boost ? o.push(c) : Jp(c.completion) > Jp(a) && (o[o.length - 1] = c), a = c.completion;
  }
  return o;
}
class Jr {
  constructor(e, t, r, s, n, o) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = s, this.selected = n, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Jr(this.options, eg(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, s, n, o) {
    if (s && !o && e.some((c) => c.isPending))
      return s.setDisabled();
    let a = kE(e, t);
    if (!a.length)
      return s && e.some((c) => c.isPending) ? s.setDisabled() : null;
    let l = t.facet(Ye).selectOnOpen ? 0 : -1;
    if (s && s.selected != l && s.selected != -1) {
      let c = s.options[s.selected].completion;
      for (let h = 0; h < a.length; h++)
        if (a[h].completion == c) {
          l = h;
          break;
        }
    }
    return new Jr(a, eg(r, l), {
      pos: e.reduce((c, h) => h.hasResult() ? Math.min(c, h.from) : c, 1e8),
      create: RE,
      above: n.aboveCursor
    }, s ? s.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Jr(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Jr(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class ll {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new ll($E, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(Ye), n = (r.override || t.languageDataAt("autocomplete", $r(t)).map(mE)).map((l) => (this.active.find((h) => h.source == l) || new Bt(
      l,
      this.active.some(
        (h) => h.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    n.length == this.active.length && n.every((l, c) => l == this.active[c]) && (n = this.active);
    let o = this.open, a = e.effects.some((l) => l.is(id));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || n.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !CE(n, this.active) || a ? o = Jr.build(n, t, this.id, o, r, a) : o && o.disabled && !n.some((l) => l.isPending) && (o = null), !o && n.every((l) => !l.isPending) && n.some((l) => l.hasResult()) && (n = n.map((l) => l.hasResult() ? new Bt(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(M_) && (o = o && o.setSelected(l.value, this.id));
    return n == this.active && o == this.open ? this : new ll(n, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? QE : PE;
  }
}
function CE(i, e) {
  if (i == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < i.length && !i[t].hasResult(); )
      t++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let s = t == i.length, n = r == e.length;
    if (s || n)
      return s == n;
    if (i[t++].result != e[r++].result)
      return !1;
  }
}
const QE = {
  "aria-autocomplete": "list"
}, PE = {};
function eg(i, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": i
  };
  return e > -1 && (t["aria-activedescendant"] = i + "-" + e), t;
}
const $E = [];
function L_(i, e) {
  if (i.isUserEvent("input.complete")) {
    let r = i.annotation(td);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let t = i.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : i.isUserEvent("delete.backward") ? 2 : i.selection ? 8 : i.docChanged ? 16 : 0;
}
class Bt {
  constructor(e, t, r = !1) {
    this.source = e, this.state = t, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let r = L_(e, t), s = this;
    (r & 8 || r & 16 && this.touches(e)) && (s = new Bt(
      s.source,
      0
      /* State.Inactive */
    )), r & 4 && s.state == 0 && (s = new Bt(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(e, r);
    for (let n of e.effects)
      if (n.is(al))
        s = new Bt(s.source, 1, n.value);
      else if (n.is(Wn))
        s = new Bt(
          s.source,
          0
          /* State.Inactive */
        );
      else if (n.is(id))
        for (let o of n.value)
          o.source == s.source && (s = o);
    return s;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange($r(e.state));
  }
}
class as extends Bt {
  constructor(e, t, r, s, n, o) {
    super(e, 3, t), this.limit = r, this.result = s, this.from = n, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var r;
    if (!(t & 3))
      return this.map(e.changes);
    let s = this.result;
    s.map && !e.changes.empty && (s = s.map(s, e.changes));
    let n = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = $r(e.state);
    if (a > o || !s || t & 2 && ($r(e.startState) == this.from || a < this.limit))
      return new Bt(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return TE(s.validFor, e.state, n, o) ? new as(this.source, this.explicit, l, s, n, o) : s.update && (s = s.update(s, n, o, new Ju(e.state, a, !1))) ? new as(this.source, this.explicit, l, s, s.from, (r = s.to) !== null && r !== void 0 ? r : $r(e.state)) : new Bt(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new as(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Bt(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function TE(i, e, t, r) {
  if (!i)
    return !1;
  let s = e.sliceDoc(t, r);
  return typeof i == "function" ? i(s, t, r, e) : A_(i, !0).test(s);
}
const id = /* @__PURE__ */ he.define({
  map(i, e) {
    return i.map((t) => t.map(e));
  }
}), M_ = /* @__PURE__ */ he.define(), _t = /* @__PURE__ */ Ge.define({
  create() {
    return ll.start();
  },
  update(i, e) {
    return i.update(e);
  },
  provide: (i) => [
    Mu.from(i, (e) => e.tooltip),
    K.contentAttributes.from(i, (e) => e.attrs)
  ]
});
function rd(i, e) {
  const t = e.completion.apply || e.completion.label;
  let r = i.state.field(_t).active.find((s) => s.source == e.source);
  return r instanceof as ? (typeof t == "string" ? i.dispatch(Object.assign(Object.assign({}, gE(i.state, t, r.from, r.to)), { annotations: td.of(e.completion) })) : t(i, e.completion, r.from, r.to), !0) : !1;
}
const RE = /* @__PURE__ */ wE(_t, rd);
function Yo(i, e = "option") {
  return (t) => {
    let r = t.state.field(_t, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(Ye).interactionDelay)
      return !1;
    let s = 1, n;
    e == "page" && (n = bS(t, r.open.tooltip)) && (s = Math.max(2, Math.floor(n.dom.offsetHeight / n.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, a = r.open.selected > -1 ? r.open.selected + s * (i ? 1 : -1) : i ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), t.dispatch({ effects: M_.of(a) }), !0;
  };
}
const EE = (i) => {
  let e = i.state.field(_t, !1);
  return i.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < i.state.facet(Ye).interactionDelay ? !1 : rd(i, e.open.options[e.open.selected]);
}, tg = (i) => i.state.field(_t, !1) ? (i.dispatch({ effects: al.of(!0) }), !0) : !1, AE = (i) => {
  let e = i.state.field(_t, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (i.dispatch({ effects: Wn.of(null) }), !0);
};
class LE {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const ME = 50, DE = 1e3, qE = /* @__PURE__ */ Ue.fromClass(class {
  constructor(i) {
    this.view = i, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of i.state.field(_t).active)
      e.isPending && this.startQuery(e);
  }
  update(i) {
    let e = i.state.field(_t), t = i.state.facet(Ye);
    if (!i.selectionSet && !i.docChanged && i.startState.field(_t) == e)
      return;
    let r = i.transactions.some((n) => {
      let o = L_(n, t);
      return o & 8 || (n.selection || n.docChanged) && !(o & 3);
    });
    for (let n = 0; n < this.running.length; n++) {
      let o = this.running[n];
      if (r || o.context.abortOnDocChange && i.docChanged || o.updates.length + i.transactions.length > ME && Date.now() - o.time > DE) {
        for (let a of o.context.abortListeners)
          try {
            a();
          } catch (l) {
            bt(this.view.state, l);
          }
        o.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        o.updates.push(...i.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), i.transactions.some((n) => n.effects.some((o) => o.is(al))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((n) => n.isPending && !this.running.some((o) => o.active.source == n.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let n of i.transactions)
        n.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: i } = this.view, e = i.field(_t);
    for (let t of e.active)
      t.isPending && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ye).updateSyncTime));
  }
  startQuery(i) {
    let { state: e } = this.view, t = $r(e), r = new Ju(e, t, i.explicit, this.view), s = new LE(i, r);
    this.running.push(s), Promise.resolve(i.source(r)).then((n) => {
      s.context.aborted || (s.done = n || null, this.scheduleAccept());
    }, (n) => {
      this.view.dispatch({ effects: Wn.of(null) }), bt(this.view.state, n);
    });
  }
  scheduleAccept() {
    this.running.every((i) => i.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ye).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var i;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Ye), r = this.view.state.field(_t);
    for (let s = 0; s < this.running.length; s++) {
      let n = this.running[s];
      if (n.done === void 0)
        continue;
      if (this.running.splice(s--, 1), n.done) {
        let a = $r(n.updates.length ? n.updates[0].startState : this.view.state), l = Math.min(a, n.done.from + (n.active.explicit ? 0 : 1)), c = new as(n.active.source, n.active.explicit, l, n.done, n.done.from, (i = n.done.to) !== null && i !== void 0 ? i : a);
        for (let h of n.updates)
          c = c.update(h, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((a) => a.source == n.active.source);
      if (o && o.isPending)
        if (n.done == null) {
          let a = new Bt(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let l of n.updates)
            a = a.update(l, t);
          a.isPending || e.push(a);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: id.of(e) });
  }
}, {
  eventHandlers: {
    blur(i) {
      let e = this.view.state.field(_t, !1);
      if (e && e.tooltip && this.view.state.facet(Ye).closeOnBlur) {
        let t = e.open && bS(this.view, e.open.tooltip);
        (!t || !t.dom.contains(i.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Wn.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: al.of(!1) }), 20), this.composing = 0;
    }
  }
}), BE = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), XE = /* @__PURE__ */ Vi.highest(/* @__PURE__ */ K.domEventHandlers({
  keydown(i, e) {
    let t = e.state.field(_t, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || i.key.length > 1 || i.ctrlKey && !(BE && i.altKey) || i.metaKey)
      return !1;
    let r = t.open.options[t.open.selected], s = t.active.find((o) => o.source == r.source), n = r.completion.commitCharacters || s.result.commitCharacters;
    return n && n.indexOf(i.key) > -1 && rd(e, r), !1;
  }
})), D_ = /* @__PURE__ */ K.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class IE {
  constructor(e, t, r, s) {
    this.field = e, this.line = t, this.from = r, this.to = s;
  }
}
class sd {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, tt.TrackDel), r = e.mapPos(this.to, 1, tt.TrackDel);
    return t == null || r == null ? null : new sd(this.field, t, r);
  }
}
class nd {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], s = [t], n = e.doc.lineAt(t), o = /^\s*/.exec(n.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let c = o, h = /^\t*/.exec(l)[0].length;
        for (let f = 0; f < h; f++)
          c += e.facet(po);
        s.push(t + c.length - h), l = c + l.slice(h);
      }
      r.push(l), t += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new sd(l.field, s[l.line] + l.from, s[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(e) {
    let t = [], r = [], s = [], n;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; n = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o); ) {
        let a = n[1] ? +n[1] : null, l = n[2] || n[3] || "", c = -1, h = l.replace(/\\[{}]/g, (f) => f[1]);
        for (let f = 0; f < t.length; f++)
          (a != null ? t[f].seq == a : h && t[f].name == h) && (c = f);
        if (c < 0) {
          let f = 0;
          for (; f < t.length && (a == null || t[f].seq != null && t[f].seq < a); )
            f++;
          t.splice(f, 0, { seq: a, name: h }), c = f;
          for (let u of s)
            u.field >= c && u.field++;
        }
        s.push(new IE(c, r.length, n.index, n.index + h.length)), o = o.slice(0, n.index) + l + o.slice(n.index + n[0].length);
      }
      o = o.replace(/\\([{}])/g, (a, l, c) => {
        for (let h of s)
          h.line == r.length && h.from > c && (h.from--, h.to--);
        return l;
      }), r.push(o);
    }
    return new nd(r, s);
  }
}
let ZE = /* @__PURE__ */ ae.widget({ widget: /* @__PURE__ */ new class extends ji {
  toDOM() {
    let i = document.createElement("span");
    return i.className = "cm-snippetFieldPosition", i;
  }
  ignoreEvent() {
    return !1;
  }
}() }), WE = /* @__PURE__ */ ae.mark({ class: "cm-snippetField" });
class Ps {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = ae.set(e.map((r) => (r.from == r.to ? ZE : WE).range(r.from, r.to)));
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let s = r.map(e);
      if (!s)
        return null;
      t.push(s);
    }
    return new Ps(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const _o = /* @__PURE__ */ he.define({
  map(i, e) {
    return i && i.map(e);
  }
}), zE = /* @__PURE__ */ he.define(), zn = /* @__PURE__ */ Ge.define({
  create() {
    return null;
  },
  update(i, e) {
    for (let t of e.effects) {
      if (t.is(_o))
        return t.value;
      if (t.is(zE) && i)
        return new Ps(i.ranges, t.value);
    }
    return i && e.docChanged && (i = i.map(e.changes)), i && e.selection && !i.selectionInsideField(e.selection) && (i = null), i;
  },
  provide: (i) => K.decorations.from(i, (e) => e ? e.deco : ae.none)
});
function od(i, e) {
  return V.create(i.filter((t) => t.field == e).map((t) => V.range(t.from, t.to)));
}
function VE(i) {
  let e = nd.parse(i);
  return (t, r, s, n) => {
    let { text: o, ranges: a } = e.instantiate(t.state, s), { main: l } = t.state.selection, c = {
      changes: { from: s, to: n == l.from ? l.to : n, insert: be.of(o) },
      scrollIntoView: !0,
      annotations: r ? [td.of(r), ze.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (c.selection = od(a, 0)), a.some((h) => h.field > 0)) {
      let h = new Ps(a, 0), f = c.effects = [_o.of(h)];
      t.state.field(zn, !1) === void 0 && f.push(he.appendConfig.of([zn, FE, HE, D_]));
    }
    t.dispatch(t.state.update(c));
  };
}
function q_(i) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(zn, !1);
    if (!r || i < 0 && r.active == 0)
      return !1;
    let s = r.active + i, n = i > 0 && !r.ranges.some((o) => o.field == s + i);
    return t(e.update({
      selection: od(r.ranges, s),
      effects: _o.of(n ? null : new Ps(r.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
const UE = ({ state: i, dispatch: e }) => i.field(zn, !1) ? (e(i.update({ effects: _o.of(null) })), !0) : !1, jE = /* @__PURE__ */ q_(1), NE = /* @__PURE__ */ q_(-1), YE = [
  { key: "Tab", run: jE, shift: NE },
  { key: "Escape", run: UE }
], ig = /* @__PURE__ */ ee.define({
  combine(i) {
    return i.length ? i[0] : YE;
  }
}), FE = /* @__PURE__ */ Vi.highest(/* @__PURE__ */ fo.compute([ig], (i) => i.facet(ig)));
function Be(i, e) {
  return Object.assign(Object.assign({}, e), { apply: VE(i) });
}
const HE = /* @__PURE__ */ K.domEventHandlers({
  mousedown(i, e) {
    let t = e.state.field(zn, !1), r;
    if (!t || (r = e.posAtCoords({ x: i.clientX, y: i.clientY })) == null)
      return !1;
    let s = t.ranges.find((n) => n.from <= r && n.to >= r);
    return !s || s.field == t.active ? !1 : (e.dispatch({
      selection: od(t.ranges, s.field),
      effects: _o.of(t.ranges.some((n) => n.field > s.field) ? new Ps(t.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Vn = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, xr = /* @__PURE__ */ he.define({
  map(i, e) {
    let t = e.mapPos(i, -1, tt.TrackAfter);
    return t ?? void 0;
  }
}), ad = /* @__PURE__ */ new class extends Lr {
}();
ad.startSide = 1;
ad.endSide = -1;
const B_ = /* @__PURE__ */ Ge.define({
  create() {
    return ye.empty;
  },
  update(i, e) {
    if (i = i.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      i = i.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(xr) && (i = i.update({ add: [ad.range(t.value, t.value + 1)] }));
    return i;
  }
});
function GE() {
  return [JE, B_];
}
const Lc = "()[]{}<>«»»«［］｛｝";
function X_(i) {
  for (let e = 0; e < Lc.length; e += 2)
    if (Lc.charCodeAt(e) == i)
      return Lc.charAt(e + 1);
  return _u(i < 128 ? i : i + 1);
}
function I_(i, e) {
  return i.languageDataAt("closeBrackets", e)[0] || Vn;
}
const KE = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), JE = /* @__PURE__ */ K.inputHandler.of((i, e, t, r) => {
  if ((KE ? i.composing : i.compositionStarted) || i.state.readOnly)
    return !1;
  let s = i.state.selection.main;
  if (r.length > 2 || r.length == 2 && hi(vt(r, 0)) == 1 || e != s.from || t != s.to)
    return !1;
  let n = iA(i.state, r);
  return n ? (i.dispatch(n), !0) : !1;
}), eA = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let r = I_(i, i.selection.main.head).brackets || Vn.brackets, s = null, n = i.changeByRange((o) => {
    if (o.empty) {
      let a = rA(i.doc, o.head);
      for (let l of r)
        if (l == a && zl(i.doc, o.head) == X_(vt(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: V.cursor(o.head - l.length)
          };
    }
    return { range: s = o };
  });
  return s || e(i.update(n, { scrollIntoView: !0, userEvent: "delete.backward" })), !s;
}, tA = [
  { key: "Backspace", run: eA }
];
function iA(i, e) {
  let t = I_(i, i.selection.main.head), r = t.brackets || Vn.brackets;
  for (let s of r) {
    let n = X_(vt(s, 0));
    if (e == s)
      return n == s ? oA(i, s, r.indexOf(s + s + s) > -1, t) : sA(i, s, n, t.before || Vn.before);
    if (e == n && Z_(i, i.selection.main.from))
      return nA(i, s, n);
  }
  return null;
}
function Z_(i, e) {
  let t = !1;
  return i.field(B_).between(0, i.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function zl(i, e) {
  let t = i.sliceString(e, e + 2);
  return t.slice(0, hi(vt(t, 0)));
}
function rA(i, e) {
  let t = i.sliceString(e - 2, e);
  return hi(vt(t, 0)) == t.length ? t : t.slice(1);
}
function sA(i, e, t, r) {
  let s = null, n = i.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: xr.of(o.to + e.length),
        range: V.range(o.anchor + e.length, o.head + e.length)
      };
    let a = zl(i.doc, o.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: xr.of(o.head + e.length),
      range: V.cursor(o.head + e.length)
    } : { range: s = o };
  });
  return s ? null : i.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function nA(i, e, t) {
  let r = null, s = i.changeByRange((n) => n.empty && zl(i.doc, n.head) == t ? {
    changes: { from: n.head, to: n.head + t.length, insert: t },
    range: V.cursor(n.head + t.length)
  } : r = { range: n });
  return r ? null : i.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function oA(i, e, t, r) {
  let s = r.stringPrefixes || Vn.stringPrefixes, n = null, o = i.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: xr.of(a.to + e.length),
        range: V.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = zl(i.doc, l), h;
    if (c == e) {
      if (rg(i, l))
        return {
          changes: { insert: e + e, from: l },
          effects: xr.of(l + e.length),
          range: V.cursor(l + e.length)
        };
      if (Z_(i, l)) {
        let u = t && i.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + u.length, insert: u },
          range: V.cursor(l + u.length)
        };
      }
    } else {
      if (t && i.sliceDoc(l - 2 * e.length, l) == e + e && (h = sg(i, l - 2 * e.length, s)) > -1 && rg(i, h))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: xr.of(l + e.length),
          range: V.cursor(l + e.length)
        };
      if (i.charCategorizer(l)(c) != De.Word && sg(i, l, s) > -1 && !aA(i, l, e, s))
        return {
          changes: { insert: e + e, from: l },
          effects: xr.of(l + e.length),
          range: V.cursor(l + e.length)
        };
    }
    return { range: n = a };
  });
  return n ? null : i.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function rg(i, e) {
  let t = ke(i).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function aA(i, e, t, r) {
  let s = ke(i).resolveInner(e, -1), n = r.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = i.sliceDoc(s.from, Math.min(s.to, s.from + t.length + n)), l = a.indexOf(t);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let h = s.firstChild;
      for (; h && h.from == s.from && h.to - h.from > t.length + l; ) {
        if (i.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = s.to == e && s.parent;
    if (!c)
      break;
    s = c;
  }
  return !1;
}
function sg(i, e, t) {
  let r = i.charCategorizer(e);
  if (r(i.sliceDoc(e - 1, e)) != De.Word)
    return e;
  for (let s of t) {
    let n = e - s.length;
    if (i.sliceDoc(n, e) == s && r(i.sliceDoc(n - 1, n)) != De.Word)
      return n;
  }
  return -1;
}
function lA(i = {}) {
  return [
    XE,
    _t,
    Ye.of(i),
    qE,
    cA,
    D_
  ];
}
const W_ = [
  { key: "Ctrl-Space", run: tg },
  { mac: "Alt-`", run: tg },
  { key: "Escape", run: AE },
  { key: "ArrowDown", run: /* @__PURE__ */ Yo(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Yo(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Yo(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Yo(!1, "page") },
  { key: "Enter", run: EE }
], cA = /* @__PURE__ */ Vi.highest(/* @__PURE__ */ fo.computeN([Ye], (i) => i.facet(Ye).defaultKeymap ? [W_] : []));
class ng {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class Sr {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let s = r.facet(Un).markerFilter;
    s && (e = s(e, r));
    let n = e.slice().sort((h, f) => h.from - f.from || h.to - f.to), o = new Ii(), a = [], l = 0;
    for (let h = 0; ; ) {
      let f = h == n.length ? null : n[h];
      if (!f && !a.length)
        break;
      let u, g;
      for (a.length ? (u = l, g = a.reduce((v, d) => Math.min(v, d.to), f && f.from > u ? f.from : 1e8)) : (u = f.from, g = f.to, a.push(f), h++); h < n.length; ) {
        let v = n[h];
        if (v.from == u && (v.to > v.from || v.to == u))
          a.push(v), h++, g = Math.min(v.to, g);
        else {
          g = Math.min(v.from, g);
          break;
        }
      }
      let S = yA(a);
      if (a.some((v) => v.from == v.to || v.from == v.to - 1 && r.doc.lineAt(v.from).to == v.from))
        o.add(u, u, ae.widget({
          widget: new vA(S),
          diagnostics: a.slice()
        }));
      else {
        let v = a.reduce((d, O) => O.markClass ? d + " " + O.markClass : d, "");
        o.add(u, g, ae.mark({
          class: "cm-lintRange cm-lintRange-" + S + v,
          diagnostics: a.slice(),
          inclusiveEnd: a.some((d) => d.to > g)
        }));
      }
      l = g;
      for (let v = 0; v < a.length; v++)
        a[v].to <= l && a.splice(v--, 1);
    }
    let c = o.finish();
    return new Sr(c, t, ms(c));
  }
}
function ms(i, e = null, t = 0) {
  let r = null;
  return i.between(t, 1e9, (s, n, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new ng(s, n, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new ng(r.from, n, r.diagnostic);
      }
  }), r;
}
function hA(i, e) {
  let t = e.pos, r = e.end || t, s = i.state.facet(Un).hideOn(i, t, r);
  if (s != null)
    return s;
  let n = i.startState.doc.lineAt(e.pos);
  return !!(i.effects.some((o) => o.is(z_)) || i.changes.touchesRange(n.from, Math.max(n.to, r)));
}
function fA(i, e) {
  return i.field(Tt, !1) ? e : e.concat(he.appendConfig.of(wA));
}
const z_ = /* @__PURE__ */ he.define(), ld = /* @__PURE__ */ he.define(), V_ = /* @__PURE__ */ he.define(), Tt = /* @__PURE__ */ Ge.define({
  create() {
    return new Sr(ae.none, null, null);
  },
  update(i, e) {
    if (e.docChanged && i.diagnostics.size) {
      let t = i.diagnostics.map(e.changes), r = null, s = i.panel;
      if (i.selected) {
        let n = e.changes.mapPos(i.selected.from, 1);
        r = ms(t, i.selected.diagnostic, n) || ms(t, null, n);
      }
      !t.size && s && e.state.facet(Un).autoPanel && (s = null), i = new Sr(t, s, r);
    }
    for (let t of e.effects)
      if (t.is(z_)) {
        let r = e.state.facet(Un).autoPanel ? t.value.length ? jn.open : null : i.panel;
        i = Sr.init(t.value, r, e.state);
      } else t.is(ld) ? i = new Sr(i.diagnostics, t.value ? jn.open : null, i.selected) : t.is(V_) && (i = new Sr(i.diagnostics, i.panel, t.value));
    return i;
  },
  provide: (i) => [
    Dn.from(i, (e) => e.panel),
    K.decorations.from(i, (e) => e.diagnostics)
  ]
}), uA = /* @__PURE__ */ ae.mark({ class: "cm-lintRange cm-lintRange-active" });
function dA(i, e, t) {
  let { diagnostics: r } = i.state.field(Tt), s, n = -1, o = -1;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: h }) => {
    if (e >= l && e <= c && (l == c || (e > l || t > 0) && (e < c || t < 0)))
      return s = h.diagnostics, n = l, o = c, !1;
  });
  let a = i.state.facet(Un).tooltipFilter;
  return s && a && (s = a(s, i.state)), s ? {
    pos: n,
    end: o,
    above: i.state.doc.lineAt(n).to < o,
    create() {
      return { dom: OA(i, s) };
    }
  } : null;
}
function OA(i, e) {
  return Pe("ul", { class: "cm-tooltip-lint" }, e.map((t) => j_(i, t, !1)));
}
const pA = (i) => {
  let e = i.state.field(Tt, !1);
  (!e || !e.panel) && i.dispatch({ effects: fA(i.state, [ld.of(!0)]) });
  let t = Mn(i, jn.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, og = (i) => {
  let e = i.state.field(Tt, !1);
  return !e || !e.panel ? !1 : (i.dispatch({ effects: ld.of(!1) }), !0);
}, gA = (i) => {
  let e = i.state.field(Tt, !1);
  if (!e)
    return !1;
  let t = i.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (i.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, mA = [
  { key: "Mod-Shift-m", run: pA, preventDefault: !0 },
  { key: "F8", run: gA }
], Un = /* @__PURE__ */ ee.define({
  combine(i) {
    return Object.assign({ sources: i.map((e) => e.source).filter((e) => e != null) }, xi(i.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t
    }));
  }
});
function U_(i) {
  let e = [];
  if (i)
    e: for (let { name: t } of i) {
      for (let r = 0; r < t.length; r++) {
        let s = t[r];
        if (/[a-zA-Z]/.test(s) && !e.some((n) => n.toLowerCase() == s.toLowerCase())) {
          e.push(s);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function j_(i, e, t) {
  var r;
  let s = t ? U_(e.actions) : [];
  return Pe("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Pe("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(i) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((n, o) => {
    let a = !1, l = (u) => {
      if (u.preventDefault(), a)
        return;
      a = !0;
      let g = ms(i.state.field(Tt).diagnostics, e);
      g && n.apply(i, g.from, g.to);
    }, { name: c } = n, h = s[o] ? c.indexOf(s[o]) : -1, f = h < 0 ? c : [
      c.slice(0, h),
      Pe("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return Pe("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${s[o]})"`}.`
    }, f);
  }), e.source && Pe("div", { class: "cm-diagnosticSource" }, e.source));
}
class vA extends ji {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Pe("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class ag {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = j_(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class jn {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (s) => {
      if (s.keyCode == 27)
        og(this.view), this.view.focus();
      else if (s.keyCode == 38 || s.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (s.keyCode == 40 || s.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (s.keyCode == 36)
        this.moveSelection(0);
      else if (s.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (s.keyCode == 13)
        this.view.focus();
      else if (s.keyCode >= 65 && s.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: n } = this.items[this.selectedIndex], o = U_(n.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == s.keyCode) {
            let l = ms(this.view.state.field(Tt).diagnostics, n);
            l && n.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      s.preventDefault();
    }, r = (s) => {
      for (let n = 0; n < this.items.length; n++)
        this.items[n].dom.contains(s.target) && this.moveSelection(n);
    };
    this.list = Pe("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = Pe("div", { class: "cm-panel-lint" }, this.list, Pe("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => og(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Tt).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Tt), r = 0, s = !1, n = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: c }) => {
      for (let h of c.diagnostics) {
        if (o.has(h))
          continue;
        o.add(h);
        let f = -1, u;
        for (let g = r; g < this.items.length; g++)
          if (this.items[g].diagnostic == h) {
            f = g;
            break;
          }
        f < 0 ? (u = new ag(this.view, h), this.items.splice(r, 0, u), s = !0) : (u = this.items[f], f > r && (this.items.splice(r, f - r), s = !0)), t && u.diagnostic == t.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), n = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      s = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new ag(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), s = !0), n ? (this.list.setAttribute("aria-activedescendant", n.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: n.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let c = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / c : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), s && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Tt), r = ms(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: V_.of(r)
    });
  }
  static open(e) {
    return new jn(e);
  }
}
function SA(i, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(i)}</svg>')`;
}
function Fo(i) {
  return SA(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${i}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const _A = /* @__PURE__ */ K.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Fo("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Fo("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Fo("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Fo("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function bA(i) {
  return i == "error" ? 4 : i == "warning" ? 3 : i == "info" ? 2 : 1;
}
function yA(i) {
  let e = "hint", t = 1;
  for (let r of i) {
    let s = bA(r.severity);
    s > t && (t = s, e = r.severity);
  }
  return e;
}
const wA = [
  Tt,
  /* @__PURE__ */ K.decorations.compute([Tt], (i) => {
    let { selected: e, panel: t } = i.field(Tt);
    return !e || !t || e.from == e.to ? ae.none : ae.set([
      uA.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ aT(dA, { hideOn: hA }),
  _A
], xA = [
  vT(),
  bT(),
  B$(),
  BR(),
  uR(),
  Q$(),
  E$(),
  _e.allowMultipleSelections.of(!0),
  eR(),
  VS(gR, { fallback: !0 }),
  wR(),
  GE(),
  lA(),
  H$(),
  J$(),
  V$(),
  j2(),
  fo.of([
    ...tA,
    ...I2,
    ...fE,
    ...NR,
    ...lR,
    ...W_,
    ...mA
  ])
];
class cl {
  /**
  @internal
  */
  constructor(e, t, r, s, n, o, a, l, c, h = 0, f) {
    this.p = e, this.stack = t, this.state = r, this.reducePos = s, this.pos = n, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = h, this.parent = f;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, r = 0) {
    let s = e.parser.context;
    return new cl(e, [], t, r, r, 0, [], 0, s ? new lg(s, s.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let r = e >> 19, s = e & 65535, { parser: n } = this.p, o = this.reducePos < this.pos - 25;
    o && this.setLookAhead(this.pos);
    let a = n.dynamicPrecedence(s);
    if (a && (this.score += a), r == 0) {
      this.pushState(n.getGoto(this.state, s, !0), this.reducePos), s < n.minRepeatTerm && this.storeNode(s, this.reducePos, this.reducePos, o ? 8 : 4, !0), this.reduceContext(s, this.reducePos);
      return;
    }
    let l = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), c = l ? this.stack[l - 2] : this.p.ranges[0].from, h = this.reducePos - c;
    h >= 2e3 && !(!((t = this.p.parser.nodeSet.types[s]) === null || t === void 0) && t.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = h));
    let f = l ? this.stack[l - 1] : 0, u = this.bufferBase + this.buffer.length - f;
    if (s < n.minRepeatTerm || e & 131072) {
      let g = n.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(s, c, g, u + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let g = this.stack[l - 3];
      this.state = n.getGoto(g, s, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(s, c);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, r, s = 4, n = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, a = this.buffer.length;
      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {
        if (t == r)
          return;
        if (o.buffer[a - 2] >= t) {
          o.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!n || this.pos == r)
      this.buffer.push(e, t, r, s);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0) {
        let a = !1;
        for (let l = o; l > 0 && this.buffer[l - 2] > r; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; o > 0 && this.buffer[o - 2] > r; )
            this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, s > 4 && (s -= 4);
      }
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = r, this.buffer[o + 3] = s;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, r, s) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let n = e, { parser: o } = this.p;
      (s > this.pos || t <= o.maxNode) && (this.pos = s, o.stateFlag(
        n,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = s)), this.pushState(n, r), this.shiftContext(t, r), t <= o.maxNode && this.buffer.push(t, r, s, 4);
    } else
      this.pos = s, this.shiftContext(t, r), t <= this.p.parser.maxNode && this.buffer.push(t, r, s, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, r, s) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, r, s);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let s = this.pos;
    this.reducePos = this.pos = s + e.length, this.pushState(t, s), this.buffer.push(
      r,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let r = e.buffer.slice(t), s = e.bufferBase + t;
    for (; e && s == e.bufferBase; )
      e = e.parent;
    return new cl(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, s, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, r ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new kA(this); ; ) {
      let r = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (r == 0)
        return !1;
      if ((r & 65536) == 0)
        return !0;
      t.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let n = 0, o; n < t.length; n += 2)
        (o = t[n + 1]) != this.state && this.p.parser.hasAction(o, e) && s.push(t[n], o);
      if (this.stack.length < 120)
        for (let n = 0; s.length < 8 && n < t.length; n += 2) {
          let o = t[n + 1];
          s.some((a, l) => l & 1 && a == o) || s.push(t[n], o);
        }
      t = s;
    }
    let r = [];
    for (let s = 0; s < t.length && r.length < 4; s += 2) {
      let n = t[s + 1];
      if (n == this.state)
        continue;
      let o = this.split();
      o.pushState(n, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(t[s], this.pos), o.reducePos = this.pos, o.score -= 200, r.push(o);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((t & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, t)) {
      let r = t >> 19, s = t & 65535, n = this.stack.length - r * 3;
      if (n < 0 || e.getGoto(this.stack[n], s, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        t = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], r = (s, n) => {
      if (!t.includes(s))
        return t.push(s), e.allActions(s, (o) => {
          if (!(o & 393216)) if (o & 65536) {
            let a = (o >> 19) - n;
            if (a > 1) {
              let l = o & 65535, c = this.stack.length - a * 3;
              if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                return a << 19 | 65536 | l;
            }
          } else {
            let a = r(o, n + 1);
            if (a != null)
              return a;
          }
        });
    };
    return r(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new lg(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class lg {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class kA {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = s;
  }
}
class hl {
  constructor(e, t, r) {
    this.stack = e, this.pos = t, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new hl(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new hl(this.stack, this.pos, this.index);
  }
}
function tn(i, e = Uint16Array) {
  if (typeof i != "string")
    return i;
  let t = null;
  for (let r = 0, s = 0; r < i.length; ) {
    let n = 0;
    for (; ; ) {
      let o = i.charCodeAt(r++), a = !1;
      if (o == 126) {
        n = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, a = !0), n += l, a)
        break;
      n *= 46;
    }
    t ? t[s++] = n : t = new e(n);
  }
  return t;
}
class va {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const cg = new va();
class CA {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = cg, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let r = this.range, s = this.rangeIndex, n = this.pos + e;
    for (; n < r.from; ) {
      if (!s)
        return null;
      let o = this.ranges[--s];
      n -= r.from - o.to, r = o;
    }
    for (; t < 0 ? n > r.to : n >= r.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let o = this.ranges[++s];
      n += o.from - r.to, r = o;
    }
    return n;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, r, s;
    if (t >= 0 && t < this.chunk.length)
      r = this.pos + e, s = this.chunk.charCodeAt(t);
    else {
      let n = this.resolveOffset(e, 1);
      if (n == null)
        return -1;
      if (r = n, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let o = this.rangeIndex, a = this.range;
        for (; a.to <= r; )
          a = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), s = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), s;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let r = t ? this.resolveOffset(t, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, t) {
    this.token.value = e, this.token.end = t;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = cg, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let r = "";
    for (let s of this.ranges) {
      if (s.from >= t)
        break;
      s.to > e && (r += this.input.read(Math.max(s.from, e), Math.min(s.to, t)));
    }
    return r;
  }
}
class ls {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: r } = t.p;
    N_(this.data, e, t, this.id, r.data, r.tokenPrecTable);
  }
}
ls.prototype.contextual = ls.prototype.fallback = ls.prototype.extend = !1;
class fl {
  constructor(e, t, r) {
    this.precTable = t, this.elseToken = r, this.data = typeof e == "string" ? tn(e) : e;
  }
  token(e, t) {
    let r = e.pos, s = 0;
    for (; ; ) {
      let n = e.next < 0, o = e.resolveOffset(1, 1);
      if (N_(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (n || s++, o == null)
        break;
      e.reset(o, e.token);
    }
    s && (e.reset(r, e.token), e.acceptToken(this.elseToken, s));
  }
}
fl.prototype.contextual = ls.prototype.fallback = ls.prototype.extend = !1;
class Xe {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function N_(i, e, t, r, s, n) {
  let o = 0, a = 1 << r, { dialect: l } = t.p.parser;
  e: for (; (a & i[o]) != 0; ) {
    let c = i[o + 1];
    for (let g = o + 3; g < c; g += 2)
      if ((i[g + 1] & a) > 0) {
        let S = i[g];
        if (l.allows(S) && (e.token.value == -1 || e.token.value == S || QA(S, e.token.value, s, n))) {
          e.acceptToken(S);
          break;
        }
      }
    let h = e.next, f = 0, u = i[o + 2];
    if (e.next < 0 && u > f && i[c + u * 3 - 3] == 65535) {
      o = i[c + u * 3 - 1];
      continue e;
    }
    for (; f < u; ) {
      let g = f + u >> 1, S = c + g + (g << 1), v = i[S], d = i[S + 1] || 65536;
      if (h < v)
        u = g;
      else if (h >= d)
        f = g + 1;
      else {
        o = i[S + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function hg(i, e, t) {
  for (let r = e, s; (s = i[r]) != 65535; r++)
    if (s == t)
      return r - e;
  return -1;
}
function QA(i, e, t, r) {
  let s = hg(t, r, e);
  return s < 0 || hg(t, r, i) < s;
}
const Qt = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Mc = null;
function fg(i, e, t) {
  let r = i.cursor(Te.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(t < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            r.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(i.length, Math.max(
            r.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (t < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return t < 0 ? 0 : i.length;
      }
}
let PA = class {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? fg(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? fg(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let r = this.trees[t], s = this.index[t];
      if (s == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let n = r.children[s], o = this.start[t] + r.positions[s];
      if (o > e)
        return this.nextStart = o, null;
      if (n instanceof xe) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let a = o + n.length;
          if (a <= this.safeTo) {
            let l = n.prop(le.lookAhead);
            if (!l || a + l < this.fragment.to)
              return n;
          }
        }
        this.index[t]++, o + n.length >= Math.max(this.safeFrom, e) && (this.trees.push(n), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + n.length;
    }
  }
};
class $A {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new va());
  }
  getActions(e) {
    let t = 0, r = null, { parser: s } = e.p, { tokenizers: n } = s, o = s.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < n.length; c++) {
      if ((1 << c & o) == 0)
        continue;
      let h = n[c], f = this.tokens[c];
      if (!(r && !h.fallback) && ((h.contextual || f.start != e.pos || f.mask != o || f.context != a) && (this.updateCachedToken(f, h, e), f.mask = o, f.context = a), f.lookAhead > f.end + 25 && (l = Math.max(f.lookAhead, l)), f.value != 0)) {
        let u = t;
        if (f.extended > -1 && (t = this.addActions(e, f.extended, f.end, t)), t = this.addActions(e, f.value, f.end, t), !h.extend && (r = f, t > u))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !r && e.pos == this.stream.end && (r = new va(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, t = this.addActions(e, r.value, r.end, t)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new va(), { pos: r, p: s } = e;
    return t.start = r, t.end = Math.min(r + 1, s.stream.end), t.value = r == s.stream.end ? s.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, r) {
    let s = this.stream.clipPos(r.pos);
    if (t.token(this.stream.reset(s, e), r), e.value > -1) {
      let { parser: n } = r.p;
      for (let o = 0; o < n.specialized.length; o++)
        if (n.specialized[o] == e.value) {
          let a = n.specializers[o](this.stream.read(e.start, e.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            (a & 1) == 0 ? e.value = a >> 1 : e.extended = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(s + 1);
  }
  putAction(e, t, r, s) {
    for (let n = 0; n < s; n += 3)
      if (this.actions[n] == e)
        return s;
    return this.actions[s++] = e, this.actions[s++] = t, this.actions[s++] = r, s;
  }
  addActions(e, t, r, s) {
    let { state: n } = e, { parser: o } = e.p, { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(
        n,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = Li(a, c + 2);
          else {
            s == 0 && a[c + 1] == 2 && (s = this.putAction(Li(a, c + 2), t, r, s));
            break;
          }
        a[c] == t && (s = this.putAction(Li(a, c + 1), t, r, s));
      }
    return s;
  }
}
class TA {
  constructor(e, t, r, s) {
    this.parser = e, this.input = t, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new CA(t, s), this.tokens = new $A(e, this.stream), this.topTerm = e.top[1];
    let { from: n } = s[0];
    this.stacks = [cl.start(this, e.top[0], n)], this.fragments = r.length && this.stream.end - n > e.bufferLength * 4 ? new PA(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, r = this.stacks = [], s, n;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > t)
          r.push(a);
        else {
          if (this.advanceStack(a, r, e))
            continue;
          {
            s || (s = [], n = []), s.push(a);
            let l = this.tokens.getMainToken(a);
            n.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let o = s && EA(s);
      if (o)
        return Qt && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw Qt && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let o = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, n, r);
      if (o)
        return Qt && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > o)
        for (r.sort((a, l) => l.score - a.score); r.length > o; )
          r.pop();
      r.some((a) => a.reducePos > t) && this.recovering--;
    } else if (r.length > 1) {
      e: for (let o = 0; o < r.length - 1; o++) {
        let a = r[o];
        for (let l = o + 1; l < r.length; l++) {
          let c = r[l];
          if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
            if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
              r.splice(l--, 1);
            else {
              r.splice(o--, 1);
              continue e;
            }
        }
      }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let o = 1; o < r.length; o++)
      r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, r) {
    let s = e.pos, { parser: n } = this, o = Qt ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let f = this.fragments.nodeAt(s); f; ) {
        let u = this.parser.nodeSet.types[f.type.id] == f.type ? n.getGoto(e.state, f.type.id) : -1;
        if (u > -1 && f.length && (!c || (f.prop(le.contextHash) || 0) == h))
          return e.useNode(f, u), Qt && console.log(o + this.stackID(e) + ` (via reuse of ${n.getName(f.type.id)})`), !0;
        if (!(f instanceof xe) || f.children.length == 0 || f.positions[0] > 0)
          break;
        let g = f.children[0];
        if (g instanceof xe && f.positions[0] == 0)
          f = g;
        else
          break;
      }
    }
    let a = n.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), Qt && console.log(o + this.stackID(e) + ` (via always-reduce ${n.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let h = l[c++], f = l[c++], u = l[c++], g = c == l.length || !r, S = g ? e : e.split(), v = this.tokens.mainToken;
      if (S.apply(h, f, v ? v.start : S.pos, u), Qt && console.log(o + this.stackID(S) + ` (via ${(h & 65536) == 0 ? "shift" : `reduce of ${n.getName(
        h & 65535
        /* Action.ValueMask */
      )}`} for ${n.getName(f)} @ ${s}${S == e ? "" : ", split"})`), g)
        return !0;
      S.pos > s ? t.push(S) : r.push(S);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > r)
        return ug(e, t), !0;
    }
  }
  runRecovery(e, t, r) {
    let s = null, n = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = t[o << 1], c = t[(o << 1) + 1], h = Qt ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (n || (n = !0, a.restart(), Qt && console.log(h + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let f = a.split(), u = h;
      for (let g = 0; f.forceReduce() && g < 10 && (Qt && console.log(u + this.stackID(f) + " (via force-reduce)"), !this.advanceFully(f, r)); g++)
        Qt && (u = this.stackID(f) + " -> ");
      for (let g of a.recoverByInsert(l))
        Qt && console.log(h + this.stackID(g) + " (via recover-insert)"), this.advanceFully(g, r);
      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), Qt && console.log(h + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), ug(a, r)) : (!s || s.score < a.score) && (s = a);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), xe.build({
      buffer: hl.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (Mc || (Mc = /* @__PURE__ */ new WeakMap())).get(e);
    return t || Mc.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function ug(i, e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    if (r.pos == i.pos && r.sameState(i)) {
      e[t].score < i.score && (e[t] = i);
      return;
    }
  }
  e.push(i);
}
class RA {
  constructor(e, t, r) {
    this.source = e, this.flags = t, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Dc = (i) => i;
class bo {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Dc, this.reduce = e.reduce || Dc, this.reuse = e.reuse || Dc, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Gt extends Iu {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      t.push("");
    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]), s = [];
    for (let a = 0; a < t.length; a++)
      s.push([]);
    function n(a, l, c) {
      s[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = le[l]);
        for (let c = 1; c < a.length; ) {
          let h = a[c++];
          if (h >= 0)
            n(h, l, a[c++]);
          else {
            let f = a[c + -h];
            for (let u = -h; u > 0; u--)
              n(a[c++], l, f);
            c++;
          }
        }
      }
    this.nodeSet = new Oo(t.map((a, l) => Ne.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: s[l],
      top: r.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = kS;
    let o = tn(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(dg), this.states = tn(e.states, Uint32Array), this.data = tn(e.stateData), this.goto = tn(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new ls(o, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, r) {
    let s = new TA(this, e, t, r);
    for (let n of this.wrappers)
      s = n(s, e, t, r);
    return s;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, r = !1) {
    let s = this.goto;
    if (t >= s[0])
      return -1;
    for (let n = s[t + 1]; ; ) {
      let o = s[n++], a = o & 1, l = s[n++];
      if (a && r)
        return l;
      for (let c = n + (o >> 1); n < c; n++)
        if (s[n] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let r = this.data;
    for (let s = 0; s < 2; s++)
      for (let n = this.stateSlot(
        e,
        s ? 2 : 1
        /* ParseState.Actions */
      ), o; ; n += 3) {
        if ((o = r[n]) == 65535)
          if (r[n + 1] == 1)
            o = r[n = Li(r, n + 2)];
          else {
            if (r[n + 1] == 2)
              return Li(r, n + 2);
            break;
          }
        if (o == t || o == 0)
          return Li(r, n + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (r) => r == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let r = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), s = r ? t(r) : void 0;
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); s == null; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = Li(this.data, n + 2);
        else
          break;
      s = t(Li(this.data, n + 1));
    }
    return s;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Li(this.data, r + 2);
        else
          break;
      if ((this.data[r + 2] & 1) == 0) {
        let s = this.data[r + 1];
        t.some((n, o) => o & 1 && n == s) || t.push(this.data[r], s);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(Gt.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = r;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((r) => {
      let s = e.tokenizers.find((n) => n.from == r);
      return s ? s.to : r;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((r, s) => {
      let n = e.specializers.find((a) => a.from == r.external);
      if (!n)
        return r;
      let o = Object.assign(Object.assign({}, r), { external: n.to });
      return t.specializers[s] = dg(o), o;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), r = t.map(() => !1);
    if (e)
      for (let n of e.split(" ")) {
        let o = t.indexOf(n);
        o >= 0 && (r[o] = !0);
      }
    let s = null;
    for (let n = 0; n < t.length; n++)
      if (!r[n])
        for (let o = this.dialects[t[n]], a; (a = this.data[o++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new RA(e, r, s);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Gt(e);
  }
}
function Li(i, e) {
  return i[e] | i[e + 1] << 16;
}
function EA(i) {
  let e = null;
  for (let t of i) {
    let r = t.p.stoppedAt;
    (t.pos == t.p.stream.end || r != null && t.pos > r) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function dg(i) {
  if (i.external) {
    let e = i.extend ? 1 : 0;
    return (t, r) => i.external(t, r) << 1 | e;
  }
  return i.get;
}
const AA = 315, LA = 316, Og = 1, MA = 2, DA = 3, qA = 4, BA = 317, XA = 319, IA = 320, ZA = 5, WA = 6, zA = 0, Tf = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Y_ = 125, VA = 59, Rf = 47, UA = 42, jA = 43, NA = 45, YA = 60, FA = 44, HA = 63, GA = 46, KA = 91, JA = new bo({
  start: !1,
  shift(i, e) {
    return e == ZA || e == WA || e == XA ? i : e == IA;
  },
  strict: !1
}), e5 = new Xe((i, e) => {
  let { next: t } = i;
  (t == Y_ || t == -1 || e.context) && i.acceptToken(BA);
}, { contextual: !0, fallback: !0 }), t5 = new Xe((i, e) => {
  let { next: t } = i, r;
  Tf.indexOf(t) > -1 || t == Rf && ((r = i.peek(1)) == Rf || r == UA) || t != Y_ && t != VA && t != -1 && !e.context && i.acceptToken(AA);
}, { contextual: !0 }), i5 = new Xe((i, e) => {
  i.next == KA && !e.context && i.acceptToken(LA);
}, { contextual: !0 }), r5 = new Xe((i, e) => {
  let { next: t } = i;
  if (t == jA || t == NA) {
    if (i.advance(), t == i.next) {
      i.advance();
      let r = !e.context && e.canShift(Og);
      i.acceptToken(r ? Og : MA);
    }
  } else t == HA && i.peek(1) == GA && (i.advance(), i.advance(), (i.next < 48 || i.next > 57) && i.acceptToken(DA));
}, { contextual: !0 });
function qc(i, e) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i == 95 || i >= 192 || !e && i >= 48 && i <= 57;
}
const s5 = new Xe((i, e) => {
  if (i.next != YA || !e.dialectEnabled(zA) || (i.advance(), i.next == Rf)) return;
  let t = 0;
  for (; Tf.indexOf(i.next) > -1; )
    i.advance(), t++;
  if (qc(i.next, !0)) {
    for (i.advance(), t++; qc(i.next, !1); )
      i.advance(), t++;
    for (; Tf.indexOf(i.next) > -1; )
      i.advance(), t++;
    if (i.next == FA) return;
    for (let r = 0; ; r++) {
      if (r == 7) {
        if (!qc(i.next, !0)) return;
        break;
      }
      if (i.next != "extends".charCodeAt(r)) break;
      i.advance(), t++;
    }
  }
  i.acceptToken(qA, -t);
}), n5 = Jt({
  "get set async static": C.modifier,
  "for while do if else switch try catch finally return throw break continue default case": C.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": C.operatorKeyword,
  "let var const using function class extends": C.definitionKeyword,
  "import export from": C.moduleKeyword,
  "with debugger new": C.keyword,
  TemplateString: C.special(C.string),
  super: C.atom,
  BooleanLiteral: C.bool,
  this: C.self,
  null: C.null,
  Star: C.modifier,
  VariableName: C.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": C.function(C.variableName),
  VariableDefinition: C.definition(C.variableName),
  Label: C.labelName,
  PropertyName: C.propertyName,
  PrivatePropertyName: C.special(C.propertyName),
  "CallExpression/MemberExpression/PropertyName": C.function(C.propertyName),
  "FunctionDeclaration/VariableDefinition": C.function(C.definition(C.variableName)),
  "ClassDeclaration/VariableDefinition": C.definition(C.className),
  "NewExpression/VariableName": C.className,
  PropertyDefinition: C.definition(C.propertyName),
  PrivatePropertyDefinition: C.definition(C.special(C.propertyName)),
  UpdateOp: C.updateOperator,
  "LineComment Hashbang": C.lineComment,
  BlockComment: C.blockComment,
  Number: C.number,
  String: C.string,
  Escape: C.escape,
  ArithOp: C.arithmeticOperator,
  LogicOp: C.logicOperator,
  BitOp: C.bitwiseOperator,
  CompareOp: C.compareOperator,
  RegExp: C.regexp,
  Equals: C.definitionOperator,
  Arrow: C.function(C.punctuation),
  ": Spread": C.punctuation,
  "( )": C.paren,
  "[ ]": C.squareBracket,
  "{ }": C.brace,
  "InterpolationStart InterpolationEnd": C.special(C.brace),
  ".": C.derefOperator,
  ", ;": C.separator,
  "@": C.meta,
  TypeName: C.typeName,
  TypeDefinition: C.definition(C.typeName),
  "type enum interface implements namespace module declare": C.definitionKeyword,
  "abstract global Privacy readonly override": C.modifier,
  "is keyof unique infer asserts": C.operatorKeyword,
  JSXAttributeValue: C.attributeValue,
  JSXText: C.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": C.angleBracket,
  "JSXIdentifier JSXNameSpacedName": C.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": C.attributeName,
  "JSXBuiltin/JSXIdentifier": C.standard(C.tagName)
}), o5 = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, for: 474, of: 483, while: 486, with: 490, do: 494, if: 498, else: 500, switch: 504, case: 510, try: 516, catch: 520, finally: 524, return: 528, throw: 532, break: 536, continue: 540, debugger: 544 }, a5 = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, l5 = { __proto__: null, "<": 193 }, c5 = Gt.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]",
  stateData: "((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~",
  goto: "$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 379,
  context: JA,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 236, 242, 244, 246, 248, 251, 257, 263, 265, 267, 269, 271, 273, 274, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [n5],
  skippedNodes: [0, 5, 6, 277],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [t5, i5, r5, s5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, e5, new fl("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~", 141, 339), new fl("j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~", 25, 322)],
  topRules: { Script: [0, 7], SingleExpression: [1, 275], SingleClassItem: [2, 276] },
  dialects: { jsx: 0, ts: 15098 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 326, get: (i) => o5[i] || -1 }, { term: 342, get: (i) => a5[i] || -1 }, { term: 95, get: (i) => l5[i] || -1 }],
  tokenPrec: 15124
}), F_ = [
  /* @__PURE__ */ Be("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Be('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], h5 = /* @__PURE__ */ F_.concat([
  /* @__PURE__ */ Be("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), pg = /* @__PURE__ */ new Xu(), H_ = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Vs(i) {
  return (e, t) => {
    let r = e.node.getChild("VariableDefinition");
    return r && t(r, i), !0;
  };
}
const f5 = ["FunctionDeclaration"], u5 = {
  FunctionDeclaration: /* @__PURE__ */ Vs("function"),
  ClassDeclaration: /* @__PURE__ */ Vs("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Vs("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Vs("type"),
  NamespaceDeclaration: /* @__PURE__ */ Vs("namespace"),
  VariableDefinition(i, e) {
    i.matchContext(f5) || e(i, "variable");
  },
  TypeDefinition(i, e) {
    e(i, "type");
  },
  __proto__: null
};
function G_(i, e) {
  let t = pg.get(e);
  if (t)
    return t;
  let r = [], s = !0;
  function n(o, a) {
    let l = i.sliceString(o.from, o.to);
    r.push({ label: l, type: a });
  }
  return e.cursor(Te.IncludeAnonymous).iterate((o) => {
    if (s)
      s = !1;
    else if (o.name) {
      let a = u5[o.name];
      if (a && a(o, n) || H_.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let a of G_(i, o.node))
        r.push(a);
      return !1;
    }
  }), pg.set(e, r), r;
}
const gg = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, K_ = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function d5(i) {
  let e = ke(i.state).resolveInner(i.pos, -1);
  if (K_.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && gg.test(i.state.sliceDoc(e.from, e.to));
  if (!t && !i.explicit)
    return null;
  let r = [];
  for (let s = e; s; s = s.parent)
    H_.has(s.name) && (r = r.concat(G_(i.state.doc, s)));
  return {
    options: r,
    from: t ? e.from : i.pos,
    validFor: gg
  };
}
const gi = /* @__PURE__ */ Ht.define({
  name: "javascript",
  parser: /* @__PURE__ */ c5.configure({
    props: [
      /* @__PURE__ */ ki.add({
        IfStatement: /* @__PURE__ */ Pr({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Pr({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: KT,
        SwitchBody: (i) => {
          let e = i.textAfter, t = /^\s*\}/.test(e), r = /^\s*(case|default)\b/.test(e);
          return i.baseIndent + (t ? 0 : r ? 1 : 2) * i.unit;
        },
        Block: /* @__PURE__ */ ns({ closing: "}" }),
        ArrowFunction: (i) => i.baseIndent + i.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Pr({ except: /^\s*{/ }),
        JSXElement(i) {
          let e = /^\s*<\//.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        JSXEscape(i) {
          let e = /\s*\}/.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        }
      }),
      /* @__PURE__ */ ei.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": go,
        BlockComment(i) {
          return { from: i.from + 2, to: i.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), J_ = {
  test: (i) => /^JSX/.test(i.name),
  facet: /* @__PURE__ */ Zu({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, eb = /* @__PURE__ */ gi.configure({ dialect: "ts" }, "typescript"), tb = /* @__PURE__ */ gi.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Wu.add((i) => i.isTop ? [J_] : void 0)]
}), ib = /* @__PURE__ */ gi.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Wu.add((i) => i.isTop ? [J_] : void 0)]
}, "typescript");
let rb = (i) => ({ label: i, type: "keyword" });
const sb = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(rb), O5 = /* @__PURE__ */ sb.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(rb));
function nb(i = {}) {
  let e = i.jsx ? i.typescript ? ib : tb : i.typescript ? eb : gi, t = i.typescript ? h5.concat(O5) : F_.concat(sb);
  return new bi(e, [
    gi.data.of({
      autocomplete: ed(K_, Wl(t))
    }),
    gi.data.of({
      autocomplete: d5
    }),
    i.jsx ? m5 : []
  ]);
}
function p5(i) {
  for (; ; ) {
    if (i.name == "JSXOpenTag" || i.name == "JSXSelfClosingTag" || i.name == "JSXFragmentTag")
      return i;
    if (i.name == "JSXEscape" || !i.parent)
      return null;
    i = i.parent;
  }
}
function mg(i, e, t = i.length) {
  for (let r = e?.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return i.sliceString(r.from, Math.min(r.to, t));
  return "";
}
const g5 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), m5 = /* @__PURE__ */ K.inputHandler.of((i, e, t, r, s) => {
  if ((g5 ? i.composing : i.compositionStarted) || i.state.readOnly || e != t || r != ">" && r != "/" || !gi.isActiveAt(i.state, e, -1))
    return !1;
  let n = s(), { state: o } = n, a = o.changeByRange((l) => {
    var c;
    let { head: h } = l, f = ke(o).resolveInner(h - 1, -1), u;
    if (f.name == "JSXStartTag" && (f = f.parent), !(o.doc.sliceString(h - 1, h) != r || f.name == "JSXAttributeValue" && f.to > h)) {
      if (r == ">" && f.name == "JSXFragmentTag")
        return { range: l, changes: { from: h, insert: "</>" } };
      if (r == "/" && f.name == "JSXStartCloseTag") {
        let g = f.parent, S = g.parent;
        if (S && g.from == h - 2 && ((u = mg(o.doc, S.firstChild, h)) || ((c = S.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let v = `${u}>`;
          return { range: V.cursor(h + v.length, -1), changes: { from: h, insert: v } };
        }
      } else if (r == ">") {
        let g = p5(f);
        if (g && g.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(h, h + 2)) && (u = mg(o.doc, g, h)))
          return { range: l, changes: { from: h, insert: `</${u}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    n,
    o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
class ul {
  static create(e, t, r, s, n) {
    let o = s + (s << 8) + e + (t << 4) | 0;
    return new ul(e, t, r, o, n, [], []);
  }
  constructor(e, t, r, s, n, o, a) {
    this.type = e, this.value = t, this.from = r, this.hash = s, this.end = n, this.children = o, this.positions = a, this.hashProp = [[le.contextHash, s]];
  }
  addChild(e, t) {
    e.prop(le.contextHash) != this.hash && (e = new xe(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(t);
  }
  toTree(e, t = this.end) {
    let r = this.children.length - 1;
    return r >= 0 && (t = Math.max(t, this.positions[r] + this.children[r].length + this.from)), new xe(e.types[this.type], this.children, this.positions, t - this.from).balance({
      makeTree: (s, n, o) => new xe(Ne.none, s, n, o, this.hashProp)
    });
  }
}
var H;
(function(i) {
  i[i.Document = 1] = "Document", i[i.CodeBlock = 2] = "CodeBlock", i[i.FencedCode = 3] = "FencedCode", i[i.Blockquote = 4] = "Blockquote", i[i.HorizontalRule = 5] = "HorizontalRule", i[i.BulletList = 6] = "BulletList", i[i.OrderedList = 7] = "OrderedList", i[i.ListItem = 8] = "ListItem", i[i.ATXHeading1 = 9] = "ATXHeading1", i[i.ATXHeading2 = 10] = "ATXHeading2", i[i.ATXHeading3 = 11] = "ATXHeading3", i[i.ATXHeading4 = 12] = "ATXHeading4", i[i.ATXHeading5 = 13] = "ATXHeading5", i[i.ATXHeading6 = 14] = "ATXHeading6", i[i.SetextHeading1 = 15] = "SetextHeading1", i[i.SetextHeading2 = 16] = "SetextHeading2", i[i.HTMLBlock = 17] = "HTMLBlock", i[i.LinkReference = 18] = "LinkReference", i[i.Paragraph = 19] = "Paragraph", i[i.CommentBlock = 20] = "CommentBlock", i[i.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", i[i.Escape = 22] = "Escape", i[i.Entity = 23] = "Entity", i[i.HardBreak = 24] = "HardBreak", i[i.Emphasis = 25] = "Emphasis", i[i.StrongEmphasis = 26] = "StrongEmphasis", i[i.Link = 27] = "Link", i[i.Image = 28] = "Image", i[i.InlineCode = 29] = "InlineCode", i[i.HTMLTag = 30] = "HTMLTag", i[i.Comment = 31] = "Comment", i[i.ProcessingInstruction = 32] = "ProcessingInstruction", i[i.Autolink = 33] = "Autolink", i[i.HeaderMark = 34] = "HeaderMark", i[i.QuoteMark = 35] = "QuoteMark", i[i.ListMark = 36] = "ListMark", i[i.LinkMark = 37] = "LinkMark", i[i.EmphasisMark = 38] = "EmphasisMark", i[i.CodeMark = 39] = "CodeMark", i[i.CodeText = 40] = "CodeText", i[i.CodeInfo = 41] = "CodeInfo", i[i.LinkTitle = 42] = "LinkTitle", i[i.LinkLabel = 43] = "LinkLabel", i[i.URL = 44] = "URL";
})(H || (H = {}));
class v5 {
  /**
  @internal
  */
  constructor(e, t) {
    this.start = e, this.content = t, this.marks = [], this.parsers = [];
  }
}
class S5 {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(e) {
    return fn(this.text, e);
  }
  /**
  @internal
  */
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(e) {
    this.markers.push(e);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(e, t = 0, r = 0) {
    for (let s = t; s < e; s++)
      r += this.text.charCodeAt(s) == 9 ? 4 - r % 4 : 1;
    return r;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(e) {
    let t = 0;
    for (let r = 0; t < this.text.length && r < e; t++)
      r += this.text.charCodeAt(t) == 9 ? 4 - r % 4 : 1;
    return t;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let t = 0; t < this.basePos; t++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function vg(i, e, t) {
  if (t.pos == t.text.length || i != e.block && t.indent >= e.stack[t.depth + 1].value + t.baseIndent)
    return !0;
  if (t.indent >= t.baseIndent + 4)
    return !1;
  let r = (i.type == H.OrderedList ? fd : hd)(t, e, !1);
  return r > 0 && (i.type != H.BulletList || cd(t, e, !1) < 0) && t.text.charCodeAt(t.pos + r - 1) == i.value;
}
const ob = {
  [H.Blockquote](i, e, t) {
    return t.next != 62 ? !1 : (t.markers.push(Se(H.QuoteMark, e.lineStart + t.pos, e.lineStart + t.pos + 1)), t.moveBase(t.pos + (Wt(t.text.charCodeAt(t.pos + 1)) ? 2 : 1)), i.end = e.lineStart + t.text.length, !0);
  },
  [H.ListItem](i, e, t) {
    return t.indent < t.baseIndent + i.value && t.next > -1 ? !1 : (t.moveBaseColumn(t.baseIndent + i.value), !0);
  },
  [H.OrderedList]: vg,
  [H.BulletList]: vg,
  [H.Document]() {
    return !0;
  }
};
function Wt(i) {
  return i == 32 || i == 9 || i == 10 || i == 13;
}
function fn(i, e = 0) {
  for (; e < i.length && Wt(i.charCodeAt(e)); )
    e++;
  return e;
}
function Sg(i, e, t) {
  for (; e > t && Wt(i.charCodeAt(e - 1)); )
    e--;
  return e;
}
function ab(i) {
  if (i.next != 96 && i.next != 126)
    return -1;
  let e = i.pos + 1;
  for (; e < i.text.length && i.text.charCodeAt(e) == i.next; )
    e++;
  if (e < i.pos + 3)
    return -1;
  if (i.next == 96) {
    for (let t = e; t < i.text.length; t++)
      if (i.text.charCodeAt(t) == 96)
        return -1;
  }
  return e;
}
function lb(i) {
  return i.next != 62 ? -1 : i.text.charCodeAt(i.pos + 1) == 32 ? 2 : 1;
}
function cd(i, e, t) {
  if (i.next != 42 && i.next != 45 && i.next != 95)
    return -1;
  let r = 1;
  for (let s = i.pos + 1; s < i.text.length; s++) {
    let n = i.text.charCodeAt(s);
    if (n == i.next)
      r++;
    else if (!Wt(n))
      return -1;
  }
  return t && i.next == 45 && fb(i) > -1 && i.depth == e.stack.length && e.parser.leafBlockParsers.indexOf(pb.SetextHeading) > -1 || r < 3 ? -1 : 1;
}
function cb(i, e) {
  for (let t = i.stack.length - 1; t >= 0; t--)
    if (i.stack[t].type == e)
      return !0;
  return !1;
}
function hd(i, e, t) {
  return (i.next == 45 || i.next == 43 || i.next == 42) && (i.pos == i.text.length - 1 || Wt(i.text.charCodeAt(i.pos + 1))) && (!t || cb(e, H.BulletList) || i.skipSpace(i.pos + 2) < i.text.length) ? 1 : -1;
}
function fd(i, e, t) {
  let r = i.pos, s = i.next;
  for (; s >= 48 && s <= 57; ) {
    r++;
    if (r == i.text.length)
      return -1;
    s = i.text.charCodeAt(r);
  }
  return r == i.pos || r > i.pos + 9 || s != 46 && s != 41 || r < i.text.length - 1 && !Wt(i.text.charCodeAt(r + 1)) || t && !cb(e, H.OrderedList) && (i.skipSpace(r + 1) == i.text.length || r > i.pos + 1 || i.next != 49) ? -1 : r + 1 - i.pos;
}
function hb(i) {
  if (i.next != 35)
    return -1;
  let e = i.pos + 1;
  for (; e < i.text.length && i.text.charCodeAt(e) == 35; )
    e++;
  if (e < i.text.length && i.text.charCodeAt(e) != 32)
    return -1;
  let t = e - i.pos;
  return t > 6 ? -1 : t;
}
function fb(i) {
  if (i.next != 45 && i.next != 61 || i.indent >= i.baseIndent + 4)
    return -1;
  let e = i.pos + 1;
  for (; e < i.text.length && i.text.charCodeAt(e) == i.next; )
    e++;
  let t = e;
  for (; e < i.text.length && Wt(i.text.charCodeAt(e)); )
    e++;
  return e == i.text.length ? t : -1;
}
const Ef = /^[ \t]*$/, ub = /-->/, db = /\?>/, Af = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, ub],
  [/^\s*<\?/, db],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Ef],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Ef]
];
function Ob(i, e, t) {
  if (i.next != 60)
    return -1;
  let r = i.text.slice(i.pos);
  for (let s = 0, n = Af.length - (t ? 1 : 0); s < n; s++)
    if (Af[s][0].test(r))
      return s;
  return -1;
}
function _g(i, e) {
  let t = i.countIndent(e, i.pos, i.indent), r = i.countIndent(i.skipSpace(e), e, t);
  return r >= t + 5 ? t + 1 : r;
}
function dr(i, e, t) {
  let r = i.length - 1;
  r >= 0 && i[r].to == e && i[r].type == H.CodeText ? i[r].to = t : i.push(Se(H.CodeText, e, t));
}
const Ho = {
  LinkReference: void 0,
  IndentedCode(i, e) {
    let t = e.baseIndent + 4;
    if (e.indent < t)
      return !1;
    let r = e.findColumn(t), s = i.lineStart + r, n = i.lineStart + e.text.length, o = [], a = [];
    for (dr(o, s, n); i.nextLine() && e.depth >= i.stack.length; )
      if (e.pos == e.text.length) {
        dr(a, i.lineStart - 1, i.lineStart);
        for (let l of e.markers)
          a.push(l);
      } else {
        if (e.indent < t)
          break;
        {
          if (a.length) {
            for (let c of a)
              c.type == H.CodeText ? dr(o, c.from, c.to) : o.push(c);
            a = [];
          }
          dr(o, i.lineStart - 1, i.lineStart);
          for (let c of e.markers)
            o.push(c);
          n = i.lineStart + e.text.length;
          let l = i.lineStart + e.findColumn(e.baseIndent + 4);
          l < n && dr(o, l, n);
        }
      }
    return a.length && (a = a.filter((l) => l.type != H.CodeText), a.length && (e.markers = a.concat(e.markers))), i.addNode(i.buffer.writeElements(o, -s).finish(H.CodeBlock, n - s), s), !0;
  },
  FencedCode(i, e) {
    let t = ab(e);
    if (t < 0)
      return !1;
    let r = i.lineStart + e.pos, s = e.next, n = t - e.pos, o = e.skipSpace(t), a = Sg(e.text, e.text.length, o), l = [Se(H.CodeMark, r, r + n)];
    o < a && l.push(Se(H.CodeInfo, i.lineStart + o, i.lineStart + a));
    for (let c = !0; i.nextLine() && e.depth >= i.stack.length; c = !1) {
      let h = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; h < e.text.length && e.text.charCodeAt(h) == s; )
          h++;
      if (h - e.pos >= n && e.skipSpace(h) == e.text.length) {
        for (let f of e.markers)
          l.push(f);
        l.push(Se(H.CodeMark, i.lineStart + e.pos, i.lineStart + h)), i.nextLine();
        break;
      } else {
        c || dr(l, i.lineStart - 1, i.lineStart);
        for (let g of e.markers)
          l.push(g);
        let f = i.lineStart + e.basePos, u = i.lineStart + e.text.length;
        f < u && dr(l, f, u);
      }
    }
    return i.addNode(i.buffer.writeElements(l, -r).finish(H.FencedCode, i.prevLineEnd() - r), r), !0;
  },
  Blockquote(i, e) {
    let t = lb(e);
    return t < 0 ? !1 : (i.startContext(H.Blockquote, e.pos), i.addNode(H.QuoteMark, i.lineStart + e.pos, i.lineStart + e.pos + 1), e.moveBase(e.pos + t), null);
  },
  HorizontalRule(i, e) {
    if (cd(e, i, !1) < 0)
      return !1;
    let t = i.lineStart + e.pos;
    return i.nextLine(), i.addNode(H.HorizontalRule, t), !0;
  },
  BulletList(i, e) {
    let t = hd(e, i, !1);
    if (t < 0)
      return !1;
    i.block.type != H.BulletList && i.startContext(H.BulletList, e.basePos, e.next);
    let r = _g(e, e.pos + 1);
    return i.startContext(H.ListItem, e.basePos, r - e.baseIndent), i.addNode(H.ListMark, i.lineStart + e.pos, i.lineStart + e.pos + t), e.moveBaseColumn(r), null;
  },
  OrderedList(i, e) {
    let t = fd(e, i, !1);
    if (t < 0)
      return !1;
    i.block.type != H.OrderedList && i.startContext(H.OrderedList, e.basePos, e.text.charCodeAt(e.pos + t - 1));
    let r = _g(e, e.pos + t);
    return i.startContext(H.ListItem, e.basePos, r - e.baseIndent), i.addNode(H.ListMark, i.lineStart + e.pos, i.lineStart + e.pos + t), e.moveBaseColumn(r), null;
  },
  ATXHeading(i, e) {
    let t = hb(e);
    if (t < 0)
      return !1;
    let r = e.pos, s = i.lineStart + r, n = Sg(e.text, e.text.length, r), o = n;
    for (; o > r && e.text.charCodeAt(o - 1) == e.next; )
      o--;
    (o == n || o == r || !Wt(e.text.charCodeAt(o - 1))) && (o = e.text.length);
    let a = i.buffer.write(H.HeaderMark, 0, t).writeElements(i.parser.parseInline(e.text.slice(r + t + 1, o), s + t + 1), -s);
    o < e.text.length && a.write(H.HeaderMark, o - r, n - r);
    let l = a.finish(H.ATXHeading1 - 1 + t, e.text.length - r);
    return i.nextLine(), i.addNode(l, s), !0;
  },
  HTMLBlock(i, e) {
    let t = Ob(e, i, !1);
    if (t < 0)
      return !1;
    let r = i.lineStart + e.pos, s = Af[t][1], n = [], o = s != Ef;
    for (; !s.test(e.text) && i.nextLine(); ) {
      if (e.depth < i.stack.length) {
        o = !1;
        break;
      }
      for (let c of e.markers)
        n.push(c);
    }
    o && i.nextLine();
    let a = s == ub ? H.CommentBlock : s == db ? H.ProcessingInstructionBlock : H.HTMLBlock, l = i.prevLineEnd();
    return i.addNode(i.buffer.writeElements(n, -r).finish(a, l - r), r), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
class _5 {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, t, r) {
    if (this.stage == -1)
      return !1;
    let s = r.content + `
` + t.scrub(), n = this.advance(s);
    return n > -1 && n < s.length ? this.complete(e, r, n) : !1;
  }
  finish(e, t) {
    return (this.stage == 2 || this.stage == 3) && fn(t.content, this.pos) == t.content.length ? this.complete(e, t, t.content.length) : !1;
  }
  complete(e, t, r) {
    return e.addLeafElement(t, Se(H.LinkReference, this.start, this.start + r, this.elts)), !0;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(xb(e, this.pos, this.start, !0)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(Se(H.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(yb(e, fn(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let t = fn(e, this.pos), r = 0;
        if (t > this.pos) {
          let s = wb(e, t, this.start);
          if (s) {
            let n = Bc(e, s.to - this.start);
            n > 0 && (this.nextStage(s), r = n);
          }
        }
        return r || (r = Bc(e, this.pos)), r > 0 && r < e.length ? r : -1;
      } else
        return Bc(e, this.pos);
    }
  }
}
function Bc(i, e) {
  for (; e < i.length; e++) {
    let t = i.charCodeAt(e);
    if (t == 10)
      break;
    if (!Wt(t))
      return -1;
  }
  return e;
}
class b5 {
  nextLine(e, t, r) {
    let s = t.depth < e.stack.length ? -1 : fb(t), n = t.next;
    if (s < 0)
      return !1;
    let o = Se(H.HeaderMark, e.lineStart + t.pos, e.lineStart + s);
    return e.nextLine(), e.addLeafElement(r, Se(n == 61 ? H.SetextHeading1 : H.SetextHeading2, r.start, e.prevLineEnd(), [
      ...e.parser.parseInline(r.content, r.start),
      o
    ])), !0;
  }
  finish() {
    return !1;
  }
}
const pb = {
  LinkReference(i, e) {
    return e.content.charCodeAt(0) == 91 ? new _5(e) : null;
  },
  SetextHeading() {
    return new b5();
  }
}, y5 = [
  (i, e) => hb(e) >= 0,
  (i, e) => ab(e) >= 0,
  (i, e) => lb(e) >= 0,
  (i, e) => hd(e, i, !0) >= 0,
  (i, e) => fd(e, i, !0) >= 0,
  (i, e) => cd(e, i, !0) >= 0,
  (i, e) => Ob(e, i, !0) >= 0
], w5 = { text: "", end: 0 };
class x5 {
  /**
  @internal
  */
  constructor(e, t, r, s) {
    this.parser = e, this.input = t, this.ranges = s, this.line = new S5(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = s[s.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = s[0].from, this.block = ul.create(H.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = r.length ? new P5(r, t) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (let r = 0; ; ) {
        let s = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; r < e.markers.length && (!s || e.markers[r].from < s.end); ) {
          let n = e.markers[r++];
          this.addNode(n.type, n.from, n.to);
        }
        if (!s)
          break;
        this.finishContext();
      }
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e: for (; ; ) {
      for (let r of this.parser.blockParsers)
        if (r) {
          let s = r(this, e);
          if (s != !1) {
            if (s == !0)
              return null;
            e.forward();
            continue e;
          }
        }
      break;
    }
    let t = new v5(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let r of this.parser.leafBlockParsers)
      if (r) {
        let s = r(this, t);
        s && t.parsers.push(s);
      }
    e: for (; this.nextLine() && e.pos != e.text.length; ) {
      if (e.indent < e.baseIndent + 4) {
        for (let r of this.parser.endLeafBlock)
          if (r(this, e, t))
            break e;
      }
      for (let r of t.parsers)
        if (r.nextLine(this, e, t))
          return null;
      t.content += `
` + e.scrub();
      for (let r of e.markers)
        t.marks.push(r);
    }
    return this.finishLeaf(t), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let t = this.fragments.takeNodes(this);
    return t ? (this.absoluteLineStart += t, this.lineStart = kb(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(e) {
    let t = w5;
    if (t.end = e, e >= this.to)
      t.text = "";
    else if (t.text = this.lineChunkAt(e), t.end += t.text.length, this.ranges.length > 1) {
      let r = this.absoluteLineStart, s = this.rangeI;
      for (; this.ranges[s].to < t.end; ) {
        s++;
        let n = this.ranges[s].from, o = this.lineChunkAt(n);
        t.end = n + o.length, t.text = t.text.slice(0, this.ranges[s - 1].to - r) + o, r = t.end - t.text.length;
      }
    }
    return t;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: e } = this, { text: t, end: r } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = r, e.reset(t); e.depth < this.stack.length; e.depth++) {
      let s = this.stack[e.depth], n = this.parser.skipContextMarkup[s.type];
      if (!n)
        throw new Error("Unhandled block context " + H[s.type]);
      if (!n(s, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let t = this.input.chunk(e), r;
    if (this.input.lineChunks)
      r = t == `
` ? "" : t;
    else {
      let s = t.indexOf(`
`);
      r = s < 0 ? t : t.slice(0, s);
    }
    return e + r.length > this.to ? r.slice(0, this.to - e) : r;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(e, t, r = 0) {
    this.block = ul.create(e, r, this.lineStart + t, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(e, t, r = 0) {
    this.startContext(this.parser.getNodeType(e), t, r);
  }
  /**
  @internal
  */
  addNode(e, t, r) {
    typeof e == "number" && (e = new xe(this.parser.nodeSet.types[e], vs, vs, (r ?? this.prevLineEnd()) - t)), this.block.addChild(e, t - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(e, t) {
    this.addNode(this.buffer.writeElements(Df(t.children, e.marks), -t.from).finish(t.type, t.to - t.from), t.from);
  }
  /**
  @internal
  */
  finishContext() {
    let e = this.stack.pop(), t = this.stack[this.stack.length - 1];
    t.addChild(e.toTree(this.parser.nodeSet), e.from - t.from), this.block = t;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? gb(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  /**
  @internal
  */
  finishLeaf(e) {
    for (let r of e.parsers)
      if (r.finish(this, e))
        return;
    let t = Df(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(t, -e.start).finish(H.Paragraph, e.content.length), e.start);
  }
  elt(e, t, r, s) {
    return typeof e == "string" ? Se(this.parser.getNodeType(e), t, r, s) : new Sb(e, t);
  }
  /**
  @internal
  */
  get buffer() {
    return new vb(this.parser.nodeSet);
  }
}
function gb(i, e, t, r, s) {
  let n = i[e].to, o = [], a = [], l = t.from + r;
  function c(h, f) {
    for (; f ? h >= n : h > n; ) {
      let u = i[e + 1].from - n;
      r += u, h += u, e++, n = i[e].to;
    }
  }
  for (let h = t.firstChild; h; h = h.nextSibling) {
    c(h.from + r, !0);
    let f = h.from + r, u, g = s.get(h.tree);
    g ? u = g : h.to + r > n ? (u = gb(i, e, h, r, s), c(h.to + r, !1)) : u = h.toTree(), o.push(u), a.push(f - l);
  }
  return c(t.to + r, !1), new xe(t.type, o, a, t.to + r - l, t.tree ? t.tree.propValues : void 0);
}
class Vl extends Iu {
  /**
  @internal
  */
  constructor(e, t, r, s, n, o, a, l, c) {
    super(), this.nodeSet = e, this.blockParsers = t, this.leafBlockParsers = r, this.blockNames = s, this.endLeafBlock = n, this.skipContextMarkup = o, this.inlineParsers = a, this.inlineNames = l, this.wrappers = c, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let h of e.types)
      this.nodeTypes[h.name] = h.id;
  }
  createParse(e, t, r) {
    let s = new x5(this, e, t, r);
    for (let n of this.wrappers)
      s = n(s, e, t, r);
    return s;
  }
  /**
  Reconfigure the parser.
  */
  configure(e) {
    let t = Lf(e);
    if (!t)
      return this;
    let { nodeSet: r, skipContextMarkup: s } = this, n = this.blockParsers.slice(), o = this.leafBlockParsers.slice(), a = this.blockNames.slice(), l = this.inlineParsers.slice(), c = this.inlineNames.slice(), h = this.endLeafBlock.slice(), f = this.wrappers;
    if (Us(t.defineNodes)) {
      s = Object.assign({}, s);
      let u = r.types.slice(), g;
      for (let S of t.defineNodes) {
        let { name: v, block: d, composite: O, style: p } = typeof S == "string" ? { name: S } : S;
        if (u.some((b) => b.name == v))
          continue;
        O && (s[u.length] = (b, w, x) => O(w, x, b.value));
        let m = u.length, _ = O ? ["Block", "BlockContext"] : d ? m >= H.ATXHeading1 && m <= H.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        u.push(Ne.define({
          id: m,
          name: v,
          props: _ && [[le.group, _]]
        })), p && (g || (g = {}), Array.isArray(p) || p instanceof li ? g[v] = p : Object.assign(g, p));
      }
      r = new Oo(u), g && (r = r.extend(Jt(g)));
    }
    if (Us(t.props) && (r = r.extend(...t.props)), Us(t.remove))
      for (let u of t.remove) {
        let g = this.blockNames.indexOf(u), S = this.inlineNames.indexOf(u);
        g > -1 && (n[g] = o[g] = void 0), S > -1 && (l[S] = void 0);
      }
    if (Us(t.parseBlock))
      for (let u of t.parseBlock) {
        let g = a.indexOf(u.name);
        if (g > -1)
          n[g] = u.parse, o[g] = u.leaf;
        else {
          let S = u.before ? Go(a, u.before) : u.after ? Go(a, u.after) + 1 : a.length - 1;
          n.splice(S, 0, u.parse), o.splice(S, 0, u.leaf), a.splice(S, 0, u.name);
        }
        u.endLeaf && h.push(u.endLeaf);
      }
    if (Us(t.parseInline))
      for (let u of t.parseInline) {
        let g = c.indexOf(u.name);
        if (g > -1)
          l[g] = u.parse;
        else {
          let S = u.before ? Go(c, u.before) : u.after ? Go(c, u.after) + 1 : c.length - 1;
          l.splice(S, 0, u.parse), c.splice(S, 0, u.name);
        }
      }
    return t.wrap && (f = f.concat(t.wrap)), new Vl(r, n, o, a, h, s, l, c, f);
  }
  /**
  @internal
  */
  getNodeType(e) {
    let t = this.nodeTypes[e];
    if (t == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return t;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(e, t) {
    let r = new C5(this, e, t);
    e: for (let s = t; s < r.end; ) {
      let n = r.char(s);
      for (let o of this.inlineParsers)
        if (o) {
          let a = o(r, n, s);
          if (a >= 0) {
            s = a;
            continue e;
          }
        }
      s++;
    }
    return r.resolveMarkers(0);
  }
}
function Us(i) {
  return i != null && i.length > 0;
}
function Lf(i) {
  if (!Array.isArray(i))
    return i;
  if (i.length == 0)
    return null;
  let e = Lf(i[0]);
  if (i.length == 1)
    return e;
  let t = Lf(i.slice(1));
  if (!t || !e)
    return e || t;
  let r = (o, a) => (o || vs).concat(a || vs), s = e.wrap, n = t.wrap;
  return {
    props: r(e.props, t.props),
    defineNodes: r(e.defineNodes, t.defineNodes),
    parseBlock: r(e.parseBlock, t.parseBlock),
    parseInline: r(e.parseInline, t.parseInline),
    remove: r(e.remove, t.remove),
    wrap: s ? n ? (o, a, l, c) => s(n(o, a, l, c), a, l, c) : s : n
  };
}
function Go(i, e) {
  let t = i.indexOf(e);
  if (t < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return t;
}
let mb = [Ne.none];
for (let i = 1, e; e = H[i]; i++)
  mb[i] = Ne.define({
    id: i,
    name: e,
    props: i >= H.Escape ? [] : [[le.group, i in ob ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document"
  });
const vs = [];
let vb = class {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, t, r, s = 0) {
    return this.content.push(e, t, r, 4 + s * 4), this;
  }
  writeElements(e, t = 0) {
    for (let r of e)
      r.writeTo(this, t);
    return this;
  }
  finish(e, t) {
    return xe.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: t
    });
  }
}, Nn = class {
  /**
  @internal
  */
  constructor(e, t, r, s = vs) {
    this.type = e, this.from = t, this.to = r, this.children = s;
  }
  /**
  @internal
  */
  writeTo(e, t) {
    let r = e.content.length;
    e.writeElements(this.children, t), e.content.push(this.type, this.from + t, this.to + t, e.content.length + 4 - r);
  }
  /**
  @internal
  */
  toTree(e) {
    return new vb(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
class Sb {
  constructor(e, t) {
    this.tree = e, this.from = t;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return vs;
  }
  writeTo(e, t) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + t, this.to + t, -1);
  }
  toTree() {
    return this.tree;
  }
}
function Se(i, e, t, r) {
  return new Nn(i, e, t, r);
}
const _b = { resolve: "Emphasis", mark: "EmphasisMark" }, bb = { resolve: "Emphasis", mark: "EmphasisMark" }, Fr = {}, Mf = {};
class At {
  constructor(e, t, r, s) {
    this.type = e, this.from = t, this.to = r, this.side = s;
  }
}
const bg = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Yn = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Yn = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const Xc = {
  Escape(i, e, t) {
    if (e != 92 || t == i.end - 1)
      return -1;
    let r = i.char(t + 1);
    for (let s = 0; s < bg.length; s++)
      if (bg.charCodeAt(s) == r)
        return i.append(Se(H.Escape, t, t + 2));
    return -1;
  },
  Entity(i, e, t) {
    if (e != 38)
      return -1;
    let r = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(i.slice(t + 1, t + 31));
    return r ? i.append(Se(H.Entity, t, t + 1 + r[0].length)) : -1;
  },
  InlineCode(i, e, t) {
    if (e != 96 || t && i.char(t - 1) == 96)
      return -1;
    let r = t + 1;
    for (; r < i.end && i.char(r) == 96; )
      r++;
    let s = r - t, n = 0;
    for (; r < i.end; r++)
      if (i.char(r) == 96) {
        if (n++, n == s && i.char(r + 1) != 96)
          return i.append(Se(H.InlineCode, t, r + 1, [
            Se(H.CodeMark, t, t + s),
            Se(H.CodeMark, r + 1 - s, r + 1)
          ]));
      } else
        n = 0;
    return -1;
  },
  HTMLTag(i, e, t) {
    if (e != 60 || t == i.end - 1)
      return -1;
    let r = i.slice(t + 1, i.end), s = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(r);
    if (s)
      return i.append(Se(H.Autolink, t, t + 1 + s[0].length, [
        Se(H.LinkMark, t, t + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        Se(H.URL, t + 1, t + s[0].length),
        Se(H.LinkMark, t + s[0].length, t + 1 + s[0].length)
      ]));
    let n = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(r);
    if (n)
      return i.append(Se(H.Comment, t, t + 1 + n[0].length));
    let o = /^\?[^]*?\?>/.exec(r);
    if (o)
      return i.append(Se(H.ProcessingInstruction, t, t + 1 + o[0].length));
    let a = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(r);
    return a ? i.append(Se(H.HTMLTag, t, t + 1 + a[0].length)) : -1;
  },
  Emphasis(i, e, t) {
    if (e != 95 && e != 42)
      return -1;
    let r = t + 1;
    for (; i.char(r) == e; )
      r++;
    let s = i.slice(t - 1, t), n = i.slice(r, r + 1), o = Yn.test(s), a = Yn.test(n), l = /\s|^$/.test(s), c = /\s|^$/.test(n), h = !c && (!a || l || o), f = !l && (!o || c || a), u = h && (e == 42 || !f || o), g = f && (e == 42 || !h || a);
    return i.append(new At(e == 95 ? _b : bb, t, r, (u ? 1 : 0) | (g ? 2 : 0)));
  },
  HardBreak(i, e, t) {
    if (e == 92 && i.char(t + 1) == 10)
      return i.append(Se(H.HardBreak, t, t + 2));
    if (e == 32) {
      let r = t + 1;
      for (; i.char(r) == 32; )
        r++;
      if (i.char(r) == 10 && r >= t + 2)
        return i.append(Se(H.HardBreak, t, r + 1));
    }
    return -1;
  },
  Link(i, e, t) {
    return e == 91 ? i.append(new At(
      Fr,
      t,
      t + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(i, e, t) {
    return e == 33 && i.char(t + 1) == 91 ? i.append(new At(
      Mf,
      t,
      t + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(i, e, t) {
    if (e != 93)
      return -1;
    for (let r = i.parts.length - 1; r >= 0; r--) {
      let s = i.parts[r];
      if (s instanceof At && (s.type == Fr || s.type == Mf)) {
        if (!s.side || i.skipSpace(s.to) == t && !/[(\[]/.test(i.slice(t + 1, t + 2)))
          return i.parts[r] = null, -1;
        let n = i.takeContent(r), o = i.parts[r] = k5(i, n, s.type == Fr ? H.Link : H.Image, s.from, t + 1);
        if (s.type == Fr)
          for (let a = 0; a < r; a++) {
            let l = i.parts[a];
            l instanceof At && l.type == Fr && (l.side = 0);
          }
        return o.to;
      }
    }
    return -1;
  }
};
function k5(i, e, t, r, s) {
  let { text: n } = i, o = i.char(s), a = s;
  if (e.unshift(Se(H.LinkMark, r, r + (t == H.Image ? 2 : 1))), e.push(Se(H.LinkMark, s - 1, s)), o == 40) {
    let l = i.skipSpace(s + 1), c = yb(n, l - i.offset, i.offset), h;
    c && (l = i.skipSpace(c.to), l != c.to && (h = wb(n, l - i.offset, i.offset), h && (l = i.skipSpace(h.to)))), i.char(l) == 41 && (e.push(Se(H.LinkMark, s, s + 1)), a = l + 1, c && e.push(c), h && e.push(h), e.push(Se(H.LinkMark, l, a)));
  } else if (o == 91) {
    let l = xb(n, s - i.offset, i.offset, !1);
    l && (e.push(l), a = l.to);
  }
  return Se(t, r, a, e);
}
function yb(i, e, t) {
  if (i.charCodeAt(e) == 60) {
    for (let s = e + 1; s < i.length; s++) {
      let n = i.charCodeAt(s);
      if (n == 62)
        return Se(H.URL, e + t, s + 1 + t);
      if (n == 60 || n == 10)
        return !1;
    }
    return null;
  } else {
    let s = 0, n = e;
    for (let o = !1; n < i.length; n++) {
      let a = i.charCodeAt(n);
      if (Wt(a))
        break;
      if (o)
        o = !1;
      else if (a == 40)
        s++;
      else if (a == 41) {
        if (!s)
          break;
        s--;
      } else a == 92 && (o = !0);
    }
    return n > e ? Se(H.URL, e + t, n + t) : n == i.length ? null : !1;
  }
}
function wb(i, e, t) {
  let r = i.charCodeAt(e);
  if (r != 39 && r != 34 && r != 40)
    return !1;
  let s = r == 40 ? 41 : r;
  for (let n = e + 1, o = !1; n < i.length; n++) {
    let a = i.charCodeAt(n);
    if (o)
      o = !1;
    else {
      if (a == s)
        return Se(H.LinkTitle, e + t, n + 1 + t);
      a == 92 && (o = !0);
    }
  }
  return null;
}
function xb(i, e, t, r) {
  for (let s = !1, n = e + 1, o = Math.min(i.length, n + 999); n < o; n++) {
    let a = i.charCodeAt(n);
    if (s)
      s = !1;
    else {
      if (a == 93)
        return r ? !1 : Se(H.LinkLabel, e + t, n + 1 + t);
      if (r && !Wt(a) && (r = !1), a == 91)
        return !1;
      a == 92 && (s = !0);
    }
  }
  return null;
}
class C5 {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.parser = e, this.text = t, this.offset = r, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(e, t) {
    return this.text.slice(e - this.offset, t - this.offset);
  }
  /**
  @internal
  */
  append(e) {
    return this.parts.push(e), e.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(e, t, r, s, n) {
    return this.append(new At(e, t, r, (s ? 1 : 0) | (n ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let t = this.parts[e];
      if (t instanceof At && (t.type == Fr || t.type == Mf))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(e) {
    return this.append(e);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(e) {
    for (let r = e; r < this.parts.length; r++) {
      let s = this.parts[r];
      if (!(s instanceof At && s.type.resolve && s.side & 2))
        continue;
      let n = s.type == _b || s.type == bb, o = s.to - s.from, a, l = r - 1;
      for (; l >= e; l--) {
        let v = this.parts[l];
        if (v instanceof At && v.side & 1 && v.type == s.type && // Ignore emphasis delimiters where the character count doesn't match
        !(n && (s.side & 1 || v.side & 2) && (v.to - v.from + o) % 3 == 0 && ((v.to - v.from) % 3 || o % 3))) {
          a = v;
          break;
        }
      }
      if (!a)
        continue;
      let c = s.type.resolve, h = [], f = a.from, u = s.to;
      if (n) {
        let v = Math.min(2, a.to - a.from, o);
        f = a.to - v, u = s.from + v, c = v == 1 ? "Emphasis" : "StrongEmphasis";
      }
      a.type.mark && h.push(this.elt(a.type.mark, f, a.to));
      for (let v = l + 1; v < r; v++)
        this.parts[v] instanceof Nn && h.push(this.parts[v]), this.parts[v] = null;
      s.type.mark && h.push(this.elt(s.type.mark, s.from, u));
      let g = this.elt(c, f, u, h);
      this.parts[l] = n && a.from != f ? new At(a.type, a.from, f, a.side) : null, (this.parts[r] = n && s.to != u ? new At(s.type, u, s.to, s.side) : null) ? this.parts.splice(r, 0, g) : this.parts[r] = g;
    }
    let t = [];
    for (let r = e; r < this.parts.length; r++) {
      let s = this.parts[r];
      s instanceof Nn && t.push(s);
    }
    return t;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(e) {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let r = this.parts[t];
      if (r instanceof At && r.type == e)
        return t;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(e) {
    let t = this.resolveMarkers(e);
    return this.parts.length = e, t;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(e) {
    return fn(this.text, e - this.offset) + this.offset;
  }
  elt(e, t, r, s) {
    return typeof e == "string" ? Se(this.parser.getNodeType(e), t, r, s) : new Sb(e, t);
  }
}
function Df(i, e) {
  if (!e.length)
    return i;
  if (!i.length)
    return e;
  let t = i.slice(), r = 0;
  for (let s of e) {
    for (; r < t.length && t[r].to < s.to; )
      r++;
    if (r < t.length && t[r].from < s.from) {
      let n = t[r];
      n instanceof Nn && (t[r] = new Nn(n.type, n.from, n.to, Df(n.children, [s])));
    } else
      t.splice(r++, 0, s);
  }
  return t;
}
const Q5 = [H.CodeBlock, H.ListItem, H.OrderedList, H.BulletList];
class P5 {
  constructor(e, t) {
    this.fragments = e, this.input = t, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, t) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let n = this.fragment.to;
      for (; n > 0 && this.input.read(n - 1, n) != `
`; )
        n--;
      this.fragmentEnd = n ? n - 1 : 0;
    }
    let r = this.cursor;
    r || (r = this.cursor = this.fragment.tree.cursor(), r.firstChild());
    let s = e + this.fragment.offset;
    for (; r.to <= s; )
      if (!r.parent())
        return !1;
    for (; ; ) {
      if (r.from >= s)
        return this.fragment.from <= t;
      if (!r.childAfter(s))
        return !1;
    }
  }
  matches(e) {
    let t = this.cursor.tree;
    return t && t.prop(le.contextHash) == e;
  }
  takeNodes(e) {
    let t = this.cursor, r = this.fragment.offset, s = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), n = e.absoluteLineStart, o = n, a = e.block.children.length, l = o, c = a;
    for (; ; ) {
      if (t.to - r > s) {
        if (t.type.isAnonymous && t.firstChild())
          continue;
        break;
      }
      let h = kb(t.from - r, e.ranges);
      if (t.to - r <= e.ranges[e.rangeI].to)
        e.addNode(t.tree, h);
      else {
        let f = new xe(e.parser.nodeSet.types[H.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(f, t.tree), e.addNode(f, h);
      }
      if (t.type.is("Block") && (Q5.indexOf(t.type.id) < 0 ? (o = t.to - r, a = e.block.children.length) : (o = l, a = c, l = t.to - r, c = e.block.children.length)), !t.nextSibling())
        break;
    }
    for (; e.block.children.length > a; )
      e.block.children.pop(), e.block.positions.pop();
    return o - n;
  }
}
function kb(i, e) {
  let t = i;
  for (let r = 1; r < e.length; r++) {
    let s = e[r - 1].to, n = e[r].from;
    s < i && (t -= n - s);
  }
  return t;
}
const $5 = Jt({
  "Blockquote/...": C.quote,
  HorizontalRule: C.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": C.heading1,
  "ATXHeading2/... SetextHeading2/...": C.heading2,
  "ATXHeading3/...": C.heading3,
  "ATXHeading4/...": C.heading4,
  "ATXHeading5/...": C.heading5,
  "ATXHeading6/...": C.heading6,
  "Comment CommentBlock": C.comment,
  Escape: C.escape,
  Entity: C.character,
  "Emphasis/...": C.emphasis,
  "StrongEmphasis/...": C.strong,
  "Link/... Image/...": C.link,
  "OrderedList/... BulletList/...": C.list,
  "BlockQuote/...": C.quote,
  "InlineCode CodeText": C.monospace,
  "URL Autolink": C.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": C.processingInstruction,
  "CodeInfo LinkLabel": C.labelName,
  LinkTitle: C.string,
  Paragraph: C.content
}), T5 = new Vl(new Oo(mb).extend($5), Object.keys(Ho).map((i) => Ho[i]), Object.keys(Ho).map((i) => pb[i]), Object.keys(Ho), y5, ob, Object.keys(Xc).map((i) => Xc[i]), Object.keys(Xc), []);
function R5(i, e, t) {
  let r = [];
  for (let s = i.firstChild, n = e; ; s = s.nextSibling) {
    let o = s ? s.from : t;
    if (o > n && r.push({ from: n, to: o }), !s)
      break;
    n = s.to;
  }
  return r;
}
function E5(i) {
  let { codeParser: e, htmlParser: t } = i;
  return { wrap: $S((s, n) => {
    let o = s.type.id;
    if (e && (o == H.CodeBlock || o == H.FencedCode)) {
      let a = "";
      if (o == H.FencedCode) {
        let c = s.node.getChild(H.CodeInfo);
        c && (a = n.read(c.from, c.to));
      }
      let l = e(a);
      if (l)
        return { parser: l, overlay: (c) => c.type.id == H.CodeText };
    } else if (t && (o == H.HTMLBlock || o == H.HTMLTag || o == H.CommentBlock))
      return { parser: t, overlay: R5(s.node, s.from, s.to) };
    return null;
  }) };
}
const A5 = { resolve: "Strikethrough", mark: "StrikethroughMark" }, L5 = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": C.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: C.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(i, e, t) {
      if (e != 126 || i.char(t + 1) != 126 || i.char(t + 2) == 126)
        return -1;
      let r = i.slice(t - 1, t), s = i.slice(t + 2, t + 3), n = /\s|^$/.test(r), o = /\s|^$/.test(s), a = Yn.test(r), l = Yn.test(s);
      return i.addDelimiter(A5, t, t + 2, !o && (!l || n || a), !n && (!a || o || l));
    },
    after: "Emphasis"
  }]
};
function un(i, e, t = 0, r, s = 0) {
  let n = 0, o = !0, a = -1, l = -1, c = !1, h = () => {
    r.push(i.elt("TableCell", s + a, s + l, i.parser.parseInline(e.slice(a, l), s + a)));
  };
  for (let f = t; f < e.length; f++) {
    let u = e.charCodeAt(f);
    u == 124 && !c ? ((!o || a > -1) && n++, o = !1, r && (a > -1 && h(), r.push(i.elt("TableDelimiter", f + s, f + s + 1))), a = l = -1) : (c || u != 32 && u != 9) && (a < 0 && (a = f), l = f + 1), c = !c && u == 92;
  }
  return a > -1 && (n++, r && h()), n;
}
function yg(i, e) {
  for (let t = e; t < i.length; t++) {
    let r = i.charCodeAt(t);
    if (r == 124)
      return !0;
    r == 92 && t++;
  }
  return !1;
}
const Cb = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class wg {
  constructor() {
    this.rows = null;
  }
  nextLine(e, t, r) {
    if (this.rows == null) {
      this.rows = !1;
      let s;
      if ((t.next == 45 || t.next == 58 || t.next == 124) && Cb.test(s = t.text.slice(t.pos))) {
        let n = [];
        un(e, r.content, 0, n, r.start) == un(e, s, t.pos) && (this.rows = [
          e.elt("TableHeader", r.start, r.start + r.content.length, n),
          e.elt("TableDelimiter", e.lineStart + t.pos, e.lineStart + t.text.length)
        ]);
      }
    } else if (this.rows) {
      let s = [];
      un(e, t.text, t.pos, s, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + t.pos, e.lineStart + t.text.length, s));
    }
    return !1;
  }
  finish(e, t) {
    return this.rows ? (e.addLeafElement(t, e.elt("Table", t.start, t.start + t.content.length, this.rows)), !0) : !1;
  }
}
const M5 = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": C.heading } },
    "TableRow",
    { name: "TableCell", style: C.content },
    { name: "TableDelimiter", style: C.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(i, e) {
      return yg(e.content, 0) ? new wg() : null;
    },
    endLeaf(i, e, t) {
      if (t.parsers.some((s) => s instanceof wg) || !yg(e.text, e.basePos))
        return !1;
      let r = i.peekLine();
      return Cb.test(r) && un(i, e.text, e.basePos) == un(i, r, e.basePos);
    },
    before: "SetextHeading"
  }]
};
class D5 {
  nextLine() {
    return !1;
  }
  finish(e, t) {
    return e.addLeafElement(t, e.elt("Task", t.start, t.start + t.content.length, [
      e.elt("TaskMarker", t.start, t.start + 3),
      ...e.parser.parseInline(t.content.slice(3), t.start + 3)
    ])), !0;
  }
}
const q5 = {
  defineNodes: [
    { name: "Task", block: !0, style: C.list },
    { name: "TaskMarker", style: C.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(i, e) {
      return /^\[[ xX]\][ \t]/.test(e.content) && i.parentType().name == "ListItem" ? new D5() : null;
    },
    after: "SetextHeading"
  }]
}, xg = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, kg = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, B5 = /[\w-]+\.[\w-]+($|\/)/, Cg = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, Qg = /\/[a-zA-Z\d@.]+/gy;
function Pg(i, e, t, r) {
  let s = 0;
  for (let n = e; n < t; n++)
    i[n] == r && s++;
  return s;
}
function X5(i, e) {
  kg.lastIndex = e;
  let t = kg.exec(i);
  if (!t || B5.exec(t[0])[0].indexOf("_") > -1)
    return -1;
  let r = e + t[0].length;
  for (; ; ) {
    let s = i[r - 1], n;
    if (/[?!.,:*_~]/.test(s) || s == ")" && Pg(i, e, r, ")") > Pg(i, e, r, "("))
      r--;
    else if (s == ";" && (n = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(i.slice(e, r))))
      r = e + n.index;
    else
      break;
  }
  return r;
}
function $g(i, e) {
  Cg.lastIndex = e;
  let t = Cg.exec(i);
  if (!t)
    return -1;
  let r = t[0][t[0].length - 1];
  return r == "_" || r == "-" ? -1 : e + t[0].length - (r == "." ? 1 : 0);
}
const I5 = {
  parseInline: [{
    name: "Autolink",
    parse(i, e, t) {
      let r = t - i.offset;
      if (r && /\w/.test(i.text[r - 1]))
        return -1;
      xg.lastIndex = r;
      let s = xg.exec(i.text), n = -1;
      if (!s)
        return -1;
      if (s[1] || s[2]) {
        if (n = X5(i.text, r + s[0].length), n > -1 && i.hasOpenLink) {
          let o = /([^\[\]]|\[[^\]]*\])*/.exec(i.text.slice(r, n));
          n = r + o[0].length;
        }
      } else s[3] ? n = $g(i.text, r) : (n = $g(i.text, r + s[0].length), n > -1 && s[0] == "xmpp:" && (Qg.lastIndex = n, s = Qg.exec(i.text), s && (n = s.index + s[0].length)));
      return n < 0 ? -1 : (i.addElement(i.elt("URL", t, n + i.offset)), n + i.offset);
    }
  }]
}, Z5 = [M5, q5, L5, I5];
function Qb(i, e, t) {
  return (r, s, n) => {
    if (s != i || r.char(n + 1) == i)
      return -1;
    let o = [r.elt(t, n, n + 1)];
    for (let a = n + 1; a < r.end; a++) {
      let l = r.char(a);
      if (l == i)
        return r.addElement(r.elt(e, n, a + 1, o.concat(r.elt(t, a, a + 1))));
      if (l == 92 && o.push(r.elt("Escape", a, a++ + 2)), Wt(l))
        break;
    }
    return -1;
  };
}
const W5 = {
  defineNodes: [
    { name: "Superscript", style: C.special(C.content) },
    { name: "SuperscriptMark", style: C.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: Qb(94, "Superscript", "SuperscriptMark")
  }]
}, z5 = {
  defineNodes: [
    { name: "Subscript", style: C.special(C.content) },
    { name: "SubscriptMark", style: C.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: Qb(126, "Subscript", "SubscriptMark")
  }]
}, V5 = {
  defineNodes: [{ name: "Emoji", style: C.character }],
  parseInline: [{
    name: "Emoji",
    parse(i, e, t) {
      let r;
      return e != 58 || !(r = /^[a-zA-Z_0-9]+:/.exec(i.slice(t + 1, i.end))) ? -1 : i.addElement(i.elt("Emoji", t, t + 1 + r[0].length));
    }
  }]
}, U5 = 54, j5 = 1, N5 = 55, Y5 = 2, F5 = 56, H5 = 3, Tg = 4, G5 = 5, dl = 6, Pb = 7, $b = 8, Tb = 9, Rb = 10, K5 = 11, J5 = 12, eL = 13, Ic = 57, tL = 14, Rg = 58, Eb = 20, iL = 22, Ab = 23, rL = 24, qf = 26, Lb = 27, sL = 28, nL = 31, oL = 34, aL = 36, lL = 37, cL = 0, hL = 1, fL = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, uL = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, Eg = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function dL(i) {
  return i == 45 || i == 46 || i == 58 || i >= 65 && i <= 90 || i == 95 || i >= 97 && i <= 122 || i >= 161;
}
function Mb(i) {
  return i == 9 || i == 10 || i == 13 || i == 32;
}
let Ag = null, Lg = null, Mg = 0;
function Bf(i, e) {
  let t = i.pos + e;
  if (Mg == t && Lg == i) return Ag;
  let r = i.peek(e);
  for (; Mb(r); ) r = i.peek(++e);
  let s = "";
  for (; dL(r); )
    s += String.fromCharCode(r), r = i.peek(++e);
  return Lg = i, Mg = t, Ag = s ? s.toLowerCase() : r == OL || r == pL ? void 0 : null;
}
const Db = 60, Ol = 62, ud = 47, OL = 63, pL = 33, gL = 45;
function Dg(i, e) {
  this.name = i, this.parent = e;
}
const mL = [dl, Rb, Pb, $b, Tb], vL = new bo({
  start: null,
  shift(i, e, t, r) {
    return mL.indexOf(e) > -1 ? new Dg(Bf(r, 1) || "", i) : i;
  },
  reduce(i, e) {
    return e == Eb && i ? i.parent : i;
  },
  reuse(i, e, t, r) {
    let s = e.type.id;
    return s == dl || s == aL ? new Dg(Bf(r, 1) || "", i) : i;
  },
  strict: !1
}), SL = new Xe((i, e) => {
  if (i.next != Db) {
    i.next < 0 && e.context && i.acceptToken(Ic);
    return;
  }
  i.advance();
  let t = i.next == ud;
  t && i.advance();
  let r = Bf(i, 0);
  if (r === void 0) return;
  if (!r) return i.acceptToken(t ? tL : dl);
  let s = e.context ? e.context.name : null;
  if (t) {
    if (r == s) return i.acceptToken(K5);
    if (s && uL[s]) return i.acceptToken(Ic, -2);
    if (e.dialectEnabled(cL)) return i.acceptToken(J5);
    for (let n = e.context; n; n = n.parent) if (n.name == r) return;
    i.acceptToken(eL);
  } else {
    if (r == "script") return i.acceptToken(Pb);
    if (r == "style") return i.acceptToken($b);
    if (r == "textarea") return i.acceptToken(Tb);
    if (fL.hasOwnProperty(r)) return i.acceptToken(Rb);
    s && Eg[s] && Eg[s][r] ? i.acceptToken(Ic, -1) : i.acceptToken(dl);
  }
}, { contextual: !0 }), _L = new Xe((i) => {
  for (let e = 0, t = 0; ; t++) {
    if (i.next < 0) {
      t && i.acceptToken(Rg);
      break;
    }
    if (i.next == gL)
      e++;
    else if (i.next == Ol && e >= 2) {
      t >= 3 && i.acceptToken(Rg, -2);
      break;
    } else
      e = 0;
    i.advance();
  }
});
function bL(i) {
  for (; i; i = i.parent)
    if (i.name == "svg" || i.name == "math") return !0;
  return !1;
}
const yL = new Xe((i, e) => {
  if (i.next == ud && i.peek(1) == Ol) {
    let t = e.dialectEnabled(hL) || bL(e.context);
    i.acceptToken(t ? G5 : Tg, 2);
  } else i.next == Ol && i.acceptToken(Tg, 1);
});
function dd(i, e, t) {
  let r = 2 + i.length;
  return new Xe((s) => {
    for (let n = 0, o = 0, a = 0; ; a++) {
      if (s.next < 0) {
        a && s.acceptToken(e);
        break;
      }
      if (n == 0 && s.next == Db || n == 1 && s.next == ud || n >= 2 && n < r && s.next == i.charCodeAt(n - 2))
        n++, o++;
      else if ((n == 2 || n == r) && Mb(s.next))
        o++;
      else if (n == r && s.next == Ol) {
        a > o ? s.acceptToken(e, -o) : s.acceptToken(t, -(o - 2));
        break;
      } else if ((s.next == 10 || s.next == 13) && a) {
        s.acceptToken(e, 1);
        break;
      } else
        n = o = 0;
      s.advance();
    }
  });
}
const wL = dd("script", U5, j5), xL = dd("style", N5, Y5), kL = dd("textarea", F5, H5), CL = Jt({
  "Text RawText": C.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": C.angleBracket,
  TagName: C.tagName,
  "MismatchedCloseTag/TagName": [C.tagName, C.invalid],
  AttributeName: C.attributeName,
  "AttributeValue UnquotedAttributeValue": C.attributeValue,
  Is: C.definitionOperator,
  "EntityReference CharacterReference": C.character,
  Comment: C.blockComment,
  ProcessingInst: C.processingInstruction,
  DoctypeDecl: C.documentMeta
}), QL = Gt.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: vL,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [CL],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [wL, xL, kL, yL, SL, _L, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function qb(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r of i.getChildren(Ab)) {
    let s = r.getChild(rL), n = r.getChild(qf) || r.getChild(Lb);
    s && (t[e.read(s.from, s.to)] = n ? n.type.id == qf ? e.read(n.from + 1, n.to - 1) : e.read(n.from, n.to) : "");
  }
  return t;
}
function qg(i, e) {
  let t = i.getChild(iL);
  return t ? e.read(t.from, t.to) : " ";
}
function Zc(i, e, t) {
  let r;
  for (let s of t)
    if (!s.attrs || s.attrs(r || (r = qb(i.node.parent.firstChild, e))))
      return { parser: s.parser };
  return null;
}
function Bb(i = [], e = []) {
  let t = [], r = [], s = [], n = [];
  for (let a of i)
    (a.tag == "script" ? t : a.tag == "style" ? r : a.tag == "textarea" ? s : n).push(a);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e) (o[a.name] || (o[a.name] = [])).push(a);
  return $S((a, l) => {
    let c = a.type.id;
    if (c == sL) return Zc(a, l, t);
    if (c == nL) return Zc(a, l, r);
    if (c == oL) return Zc(a, l, s);
    if (c == Eb && n.length) {
      let h = a.node, f = h.firstChild, u = f && qg(f, l), g;
      if (u) {
        for (let S of n)
          if (S.tag == u && (!S.attrs || S.attrs(g || (g = qb(f, l))))) {
            let v = h.lastChild, d = v.type.id == lL ? v.from : h.to;
            if (d > f.to)
              return { parser: S.parser, overlay: [{ from: f.to, to: d }] };
          }
      }
    }
    if (o && c == Ab) {
      let h = a.node, f;
      if (f = h.firstChild) {
        let u = o[l.read(f.from, f.to)];
        if (u) for (let g of u) {
          if (g.tagName && g.tagName != qg(h.parent, l)) continue;
          let S = h.lastChild;
          if (S.type.id == qf) {
            let v = S.from + 1, d = S.lastChild, O = S.to - (d && d.isError ? 0 : 1);
            if (O > v) return { parser: g.parser, overlay: [{ from: v, to: O }] };
          } else if (S.type.id == Lb)
            return { parser: g.parser, overlay: [{ from: S.from, to: S.to }] };
        }
      }
    }
    return null;
  });
}
const PL = 107, Bg = 1, $L = 108, TL = 109, Xg = 2, Ig = 110, Xb = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], RL = 58, EL = 40, Ib = 95, AL = 91, Sa = 45, LL = 46, ML = 35, DL = 37, qL = 38, BL = 92, XL = 10, IL = 42;
function Fn(i) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 161;
}
function Zb(i) {
  return i >= 48 && i <= 57;
}
const ZL = new Xe((i, e) => {
  for (let t = !1, r = 0, s = 0; ; s++) {
    let { next: n } = i;
    if (Fn(n) || n == Sa || n == Ib || t && Zb(n))
      !t && (n != Sa || s > 0) && (t = !0), r === s && n == Sa && r++, i.advance();
    else if (n == BL && i.peek(1) != XL)
      i.advance(), i.next > -1 && i.advance(), t = !0;
    else {
      t && i.acceptToken(
        r == 2 && e.canShift(Xg) ? Xg : e.canShift(Ig) ? Ig : n == EL ? $L : TL
      );
      break;
    }
  }
}), WL = new Xe((i) => {
  if (Xb.includes(i.peek(-1))) {
    let { next: e } = i;
    (Fn(e) || e == Ib || e == ML || e == LL || e == IL || e == AL || e == RL && Fn(i.peek(1)) || e == Sa || e == qL) && i.acceptToken(PL);
  }
}), zL = new Xe((i) => {
  if (!Xb.includes(i.peek(-1))) {
    let { next: e } = i;
    if (e == DL && (i.advance(), i.acceptToken(Bg)), Fn(e)) {
      do
        i.advance();
      while (Fn(i.next) || Zb(i.next));
      i.acceptToken(Bg);
    }
  }
}), VL = Jt({
  "AtKeyword import charset namespace keyframes media supports": C.definitionKeyword,
  "from to selector": C.keyword,
  NamespaceName: C.namespace,
  KeyframeName: C.labelName,
  KeyframeRangeName: C.operatorKeyword,
  TagName: C.tagName,
  ClassName: C.className,
  PseudoClassName: C.constant(C.className),
  IdName: C.labelName,
  "FeatureName PropertyName": C.propertyName,
  AttributeName: C.attributeName,
  NumberLiteral: C.number,
  KeywordQuery: C.keyword,
  UnaryQueryOp: C.operatorKeyword,
  "CallTag ValueName": C.atom,
  VariableName: C.variableName,
  Callee: C.operatorKeyword,
  Unit: C.unit,
  "UniversalSelector NestingSelector": C.definitionOperator,
  "MatchOp CompareOp": C.compareOperator,
  "ChildOp SiblingOp, LogicOp": C.logicOperator,
  BinOp: C.arithmeticOperator,
  Important: C.modifier,
  Comment: C.blockComment,
  ColorLiteral: C.color,
  "ParenthesizedContent StringLiteral": C.string,
  ":": C.punctuation,
  "PseudoOp #": C.derefOperator,
  "; ,": C.separator,
  "( )": C.paren,
  "[ ]": C.squareBracket,
  "{ }": C.brace
}), UL = { __proto__: null, lang: 34, "nth-child": 34, "nth-last-child": 34, "nth-of-type": 34, "nth-last-of-type": 34, dir: 34, "host-context": 34, url: 62, "url-prefix": 62, domain: 62, regexp: 62 }, jL = { __proto__: null, "@import": 120, "@media": 154, "@charset": 158, "@namespace": 162, "@keyframes": 168, "@supports": 180 }, NL = { __proto__: null, layer: 124, not: 144, only: 144, selector: 150 }, YL = Gt.deserialize({
  version: 14,
  states: ">`QYQ[OOO#kQ[OOP#rOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#wQ[O'#CfO$hQXO'#CaO$rQ[O'#CiO$}Q[O'#DUO%SQ[O'#DXO%XQ[O'#D[O%XQ[O'#D_OOQP'#Ev'#EvO%yQdO'#DhO&hQ[O'#DzO%yQdO'#D|O&yQ[O'#EOO'UQ[O'#ERO'^Q[O'#EXO'lQ[O'#EZOOQS'#Eu'#EuOOQS'#E^'#E^QYQ[OOO'sQXO'#CdO(hQWO'#DdO(mQWO'#E{O(xQ[O'#E{QOQWOOP)SO#tO'#C_POOO)C@e)C@eOOQP'#Ch'#ChOOQP,59Q,59QO#wQ[O,59QO)_Q[O,59TO$}Q[O,59pO%SQ[O,59sO%XQ[O,59vO%XQ[O,59xO%XQ[O,59yO%XQ[O'#EcO)jQWO,58{O)rQ[O'#DcOOQS,58{,58{OOQP'#Cl'#ClOOQO'#DS'#DSOOQP,59T,59TO)yQWO,59TO*OQWO,59TOOQP'#DW'#DWOOQP,59p,59pOOQO'#DY'#DYO*TQ`O,59sO*nQXO,59vO+UQXO,59yOOQS'#Cq'#CqO%yQdO'#CrO+lQvO'#CtO-hQtO,5:SOOQO'#Cy'#CyO*OQWO'#CxO-rQWO'#CzO-wQ[O'#DPOOQS'#Ex'#ExOOQO'#Dn'#DnO.eQdO'#DwO.uQWO'#E|O'^Q[O'#DuO/TQWO'#DxOOQO'#E}'#E}O)mQWO,5:fO/YQpO,5:hOOQS'#EQ'#EQO/bQWO,5:jO/gQ[O,5:jOOQO'#ET'#ETO/oQWO,5:mO/tQWO,5:sO/|QWO,5:uOOQS-E8[-E8[O0UQdO,5:OO0fQ[O'#EeO0sQWO,5;gO0sQWO,5;gPOOO'#E]'#E]P1OO#tO,58yPOOO,58y,58yOOQP1G.l1G.lOOQP1G.o1G.oO)yQWO1G.oO*OQWO1G.oOOQP1G/[1G/[O1ZQ`O1G/_O1cQXO1G/bO1yQXO1G/dO2aQXO1G/eO2wQXO,5:}OOQO-E8a-E8aOOQS1G.g1G.gO3RQWO,59}O3WQ[O'#DTO3_QdO'#CpOOQP1G/_1G/_O%yQdO1G/_O3fQpO,59^OOQS,59`,59`O%yQdO,59bO3nQ[O'#DkO4PQWO1G/nO-VQ[O1G/nOOQS,59d,59dO4UQ!bO,59fOOQS'#DQ'#DQOOQS'#E`'#E`O4aQ[O,59kOOQS,59k,59kO4iQpO'#DnO4wQpO,5:ZO5PQWO,5:cOOQO'#FO'#FOO4zQpO,5:_O'^Q[O,5:]O5XQ[O'#EgO5pQWO,5;hO5{QWO,5:aO%XQ[O,5:dOOQS1G0Q1G0QOOQS1G0S1G0SOOQS1G0U1G0UO6^QWO1G0UO6cQdO'#EUOOQS1G0X1G0XOOQS1G0_1G0_OOQS1G0a1G0aO6nQtO1G/jOOQO1G/j1G/jOOQO,5;P,5;PO7UQ[O,5;POOQO-E8c-E8cO7cQWO1G1RPOOO-E8Z-E8ZPOOO1G.e1G.eOOQP7+$Z7+$ZOOQP7+$y7+$yO%yQdO7+$yOOQS1G/i1G/iO7nQXO'#EzO7xQWO,59oO7}QtO'#E_O8uQdO'#EwO9PQWO,59[O9UQpO7+$yOOQS1G.x1G.xOOQS1G.|1G.|O9^Q[O,5:VOOQS7+%Y7+%YO9cQWO7+%YOOQS1G/Q1G/QO9hQWO1G/QOOQS-E8^-E8^OOQS1G/V1G/VO%yQdO1G/uO9mQdO1G/yOOQO1G/}1G/}OOQO1G/w1G/wO9tQWO,5;ROOQO-E8e-E8eO:SQXO1G0OOOQS7+%p7+%pO:ZQYO'#CtOOQO'#EW'#EWO:iQ`O'#EVOOQO'#EV'#EVO:tQWO'#EhO:|QdO,5:pOOQS,5:p,5:pO;XQtO'#EdO%yQdO'#EdO<YQdO7+%UOOQO7+%U7+%UOOQO1G0k1G0kO<mQpO<<HeO<uQ[O'#EbO=PQWO,5;fOOQP1G/Z1G/ZOOQS-E8]-E8]O=XQdO'#EaO=cQWO,5;cOOQT1G.v1G.vOOQP<<He<<HeOOQO'#Dm'#DmO=kQWO1G/qOOQS<<Ht<<HtOOQS7+$l7+$lO=sQdO7+%aOOQO'#Dp'#DpO=zQpO7+%eOOQO7+%j7+%jOOQO,5:q,5:qO6fQdO'#EiO:tQWO,5;SOOQS,5;S,5;SOOQS-E8f-E8fOOQS1G0[1G0[O>SQtO,5;OOOQS-E8b-E8bOOQO<<Hp<<HpOOQPAN>PAN>PO?TQXO,5:|OOQO-E8`-E8`O?_QdO,5:{OOQO-E8_-E8_O9^Q[O'#EfO?iQWO7+%]OOQS7+%]7+%]OOQO<<H{<<H{OOQO<<IP<<IPO?qQdO<<IPOOQO,5;T,5;TOOQO-E8g-E8gOOQS1G0n1G0nOOQO,5;Q,5;QOOQO-E8d-E8dOOQS<<Hw<<HwO@YQWOAN>kOOQOG24VG24V",
  stateData: "@g~O#dOS#eQQ~OU[OX[OZTO^VO_VOrXOyWO!PYO!SZO!]cO!^]O!o^O!q_O!s`O!vaO!|bO#aRO~OQhOU[OX[OZTO^VO_VOrXOyWO!PYO!SZO!]cO!^]O!o^O!q_O!s`O!vaO!|bO#agO~O#^#oP~P!aO#elO~O#anO~OZpO^qO_qOrsOyrO!PtO!SvO#_uO~OuwO!UyO~P#|Oa!PO#`|O#a{O~O#a!QO~O#a!SO~OU[OX[OZTO^VO_VOrXOyWO!PYO!SZO#aRO~OQ!`Oc!XOg!`Oi!`Oo!^Or!_O#`![O#a!WO#m!YO~Oc!bO!j!dO!m!eO#b!aO!U#pP~Oi!jOo!^O#a!iO~Oi!lO#a!lO~Oc!bO!j!dO!m!eO#b!aO~O!Z#pP~P&hOZWX^WX^!XX_WXrWXuWXyWX!PWX!SWX!UWX#_WX~O^!qO~O!Z!rO#^#oX!T#oX~O#^#oX!T#oX~P!aO#f!uO#g!uO#h!wO~Oa!{O#`|O#a{O~OuwO!UyO~O!T#oP~P!aOc#VO~Oc#WO~Oq#XO}#YO~OZpO^qO_qOrsOyrO~Ou!Oa!P!Oa!S!Oa!U!Oa#_!Oab!Oa~P*]Ou!Ra!P!Ra!S!Ra!U!Ra#_!Rab!Ra~P*]OP#[OchXkhX!ZhX!`hX!jhX!mhX#bhXbhX!hhXQhXghXihXohXrhXuhX!YhX#^hX#`hX#ahX#mhXqhX!ThX~Oc!bO!j!dO!m!eO#b!aO!Z#pP~Ok#]O!`#^O~P-VOc#bO~Oq#fO#a#cO~OQ#jOg#jOi#jOo!^O#`![O#m!YO~Oc!bO!j!dO!m!eO#b#gO~P.POu#mO!f#lO!U#pX!Z#pX~Oc#pO~Ok#]O!Z#rO~O!Z#sO~Oi#tOo!^O~O!U#uO~O!UyO!f#lO~O!UyO!Z#xO~O!Y#zO!Z!Wa#^!Wa!T!Wa~P%yO!Z#XX#^#XX!T#XX~P!aO!Z!rO#^#oa!T#oa~O#f!uO#g!uO#h$QO~Oq$SO}$TO~Ou!Oi!P!Oi!S!Oi!U!Oi#_!Oib!Oi~P*]Ou!Qi!P!Qi!S!Qi!U!Qi#_!Qib!Qi~P*]Ou!Ri!P!Ri!S!Ri!U!Ri#_!Rib!Ri~P*]Ou#Va!U#Va~P#|O!T$UO~Ob#nP~P%XOb#kP~P%yOb$]Ok#]O~Oc$_O!Z!_X!j!_X!m!_X#b!_X~O!Z$`O~Ob$bOi$cOp$cO~Oq$eO#a#cO~O^!dXb!bX!f!bX!h!dX~O^$fO!h$gO~Ob$hO!f#lO~Oc!bO!j!dO!m!eO#b!aOu#ZX!U#ZX!Z#ZX~Ou#mO!U#pa!Z#pa~O!f#lOu!ia!U!ia!Z!iab!ia~O!Z$mO~O!T$tO#a$oO#m$nO~Ok#]Ou$vO!Y$xO!Z!Wi#^!Wi!T!Wi~P%yO!Z#Xa#^#Xa!T#Xa~P!aO!Z!rO#^#oi!T#oi~Ou${Ob#nX~P#|Ob$}O~Ok#]OQ#RXb#RXc#RXg#RXi#RXo#RXr#RXu#RX#`#RX#a#RX#m#RX~Ou%POb#kX~P%yOb%RO~Ok#]Oq%SO~O#a%TO~O!Z%VO~Ob%WO~O#b%YO~P.PO!f#lOu#Za!U#Za!Z#Za~Ob%[O~P#|OP#[OuhX!UhXbhX~O#m$nOu!yX!U!yX~Ou%^O!UyO~O!T%bO#a$oO#m$nO~Ok#]OQ#WXc#WXg#WXi#WXo#WXr#WXu#WX!Y#WX!Z#WX#^#WX#`#WX#a#WX#m#WX!T#WX~Ou$vO!Y%eO!Z!Wq#^!Wq!T!Wq~P%yOk#]Oq%fO~Ob#UXu#UX~P%XOu${Ob#na~Ob#TXu#TX~P%yOu%POb#ka~OZ%kOb%mO~Ob%nO~P%yOb%oO!h%pO~Ok#]OQ#Wac#Wag#Wai#Wao#War#Wau#Wa!Y#Wa!Z#Wa#^#Wa#`#Wa#a#Wa#m#Wa!T#Wa~Ob#Uau#Ua~P#|Ob#Tau#Ta~P%yOZ%kOb%vO~OQ#jOg#jOi#jOo!^O#`![O#b%YO#m$nO~Ob%xO~O#dp#e#mk!S#m~",
  goto: "/l#sPPP#tP#wP$Q$dP$QP$v$QPP$|PPP%S%]%]P%oP%]P&`&w'^PPPP%]'{P(P(V$QP(]$Q(cP$QP$Q$QPPP(i)O)]PP#wPP)dP)g)m)m)x)mP)mP)mP)m)mP#wP#wP#wP*R#wP*U*X*[*c#wP#wP*h*n*}+]+c+i+o+u+{,V,],c,iPPPPPPPPPPP,o,x-n-qP.g.j.p.|/cRmQ_dOPfjy!r#|q[OPYZfjtuvwy!r#V#p#|${qSOPYZfjtuvwy!r#V#p#|${QoTR!xpQ}VR!yqQ!y!PQ#a!]R$R!{q!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%ip!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iU#j!b$g%pU$q#u$s%^R%]$pp!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iV#j!b$g%pw!]]_!X!b!q#W#Y#]#y$T$Y$f$g$v$w%P%X%i%pp!`]_!X!q#W#Y#]#y$T$Y$f$v$w%P%X%iQ!j`U#j!b$g%pR#t!kT#d!_#eQ!OVR!zqQ!y!OR$R!zQ!RWR!|rQ!TXR!}sQzUQ#TxQ#q!gQ#w!nQ#x!oQ%`$rR%s%_SiPyQ!tjQ#{!rR$y#|ZhPjy!r#|R#`!ZQ%U$_R%t%kc!f^bc!Z!b!d#`#l#mQ#h!bQ%Z$gR%w%pR!k`R!maR#v!mS$r#u$sR%q%^V$p#u$s%^Q!vlR$P!vQfOSjPyU!pfj#|R#|!rQ$Y#WU%O$Y%X%iQ%X$fR%i%PQ#e!_R$d#eQ%Q$YR%j%QQ$|$VR%h$|QxUR#SxQ$w#yR%d$wQ!siS#}!s$OR$O!tQ%l%UR%u%lQ#n!cR$k#nQ$s#uR%a$sQ%_$rR%r%__eOPfjy!r#|^UOPfjy!r#|Q!UYQ!VZQ#OtQ#PuQ#QvQ#RwQ$V#VQ$l#pR%g${R$Z#WQ!Z]Q!h_Q#Z!XQ#y!q[$X#W$Y$f%P%X%iQ$[#YQ$^#]S$u#y$wQ$z$TR%c$vR$W#VQkPR#UyQ!g^Q!ocQ#_!ZR$a#`W!c^c!Z#`Q!nbQ#i!bQ#o!dQ$i#lR$j#mQ#k!bQ%Z$gR%w%p",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import Layer layer LayerName KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 126,
  nodeProps: [
    ["isolate", -2, 3, 25, ""],
    ["openedBy", 18, "(", 33, "[", 51, "{"],
    ["closedBy", 19, ")", 34, "]", 52, "}"]
  ],
  propSources: [VL],
  skippedNodes: [0, 3, 93],
  repeatNodeCount: 13,
  tokenData: "LU~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_Cj!_!`Df!`!aDy!a!b$}!b!cEz!c!}$}!}#OHX#O#P$}#P#QHj#Q#R6d#R#T$}#T#UH{#U#c$}#c#dJ^#d#o$}#o#pJs#p#q6d#q#rKU#r#sKg#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`LO<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSp`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#d~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#d~p`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUp`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Up`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUp`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Up`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUp`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Up`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUp`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Up`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!Y[p`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOi~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYyQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYp`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYp`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYg[p`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYg[p`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYp`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYg[p`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYp`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSg[p`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS}Sp`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSc^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOb~n9{UUQkWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWkW!SQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUp`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYp`#m[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYp`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUp`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUp`#m[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[p`#m[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSu^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWkWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VUZQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTkWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSp`#e~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#m[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^jBbU^YOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S_Qp`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Z^Oy%^z;'S%^;'S;=`%o<%lO%^hCoU!hWOy%^z!_%^!_!`DR!`;'S%^;'S;=`%o<%lO%^hDYS!hWp`Oy%^z;'S%^;'S;=`%o<%lO%^lDmS!hW}SOy%^z;'S%^;'S;=`%o<%lO%^jEQV!PQ!hWOy%^z!_%^!_!`DR!`!aEg!a;'S%^;'S;=`%o<%lO%^bEnS!PQp`Oy%^z;'S%^;'S;=`%o<%lO%^bE}YOy%^z}%^}!OFm!O!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^bFrWp`Oy%^z!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^bGc[!]Qp`Oy%^z}%^}!OG[!O!Q%^!Q![G[![!c%^!c!}G[!}#T%^#T#oG[#o;'S%^;'S;=`%o<%lO%^nH^Sr^Oy%^z;'S%^;'S;=`%o<%lO%^nHoSq^Oy%^z;'S%^;'S;=`%o<%lO%^jIOUOy%^z#b%^#b#cIb#c;'S%^;'S;=`%o<%lO%^jIgUp`Oy%^z#W%^#W#XIy#X;'S%^;'S;=`%o<%lO%^jJQS!fYp`Oy%^z;'S%^;'S;=`%o<%lO%^jJaUOy%^z#f%^#f#gIy#g;'S%^;'S;=`%o<%lO%^fJxS!UUOy%^z;'S%^;'S;=`%o<%lO%^nKZS!T^Oy%^z;'S%^;'S;=`%o<%lO%^fKlU!SQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`LRP;=`<%l$}",
  tokenizers: [WL, zL, ZL, 1, 2, 3, 4, new fl("m~RRYZ[z{a~~g~aO#g~~dP!P!Qg~lO#h~~", 28, 114)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 92] },
  specialized: [{ term: 108, get: (i) => UL[i] || -1 }, { term: 59, get: (i) => jL[i] || -1 }, { term: 110, get: (i) => NL[i] || -1 }],
  tokenPrec: 1441
});
let Wc = null;
function zc() {
  if (!Wc && typeof document == "object" && document.body) {
    let { style: i } = document.body, e = [], t = /* @__PURE__ */ new Set();
    for (let r in i)
      r != "cssText" && r != "cssFloat" && typeof i[r] == "string" && (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (s) => "-" + s.toLowerCase())), t.has(r) || (e.push(r), t.add(r)));
    Wc = e.sort().map((r) => ({ type: "property", label: r, apply: r + ": " }));
  }
  return Wc || [];
}
const Zg = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((i) => ({ type: "class", label: i })), Wg = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((i) => ({ type: "keyword", label: i })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((i) => ({ type: "constant", label: i }))), FL = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((i) => ({ type: "type", label: i })), HL = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((i) => ({ type: "keyword", label: i })), Pi = /^(\w[\w-]*|-\w[\w-]*|)$/, GL = /^-(-[\w-]*)?$/;
function KL(i, e) {
  var t;
  if ((i.name == "(" || i.type.isError) && (i = i.parent || i), i.name != "ArgList")
    return !1;
  let r = (t = i.parent) === null || t === void 0 ? void 0 : t.firstChild;
  return r?.name != "Callee" ? !1 : e.sliceString(r.from, r.to) == "var";
}
const zg = /* @__PURE__ */ new Xu(), JL = ["Declaration"];
function eM(i) {
  for (let e = i; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return i;
  }
}
function Wb(i, e, t) {
  if (e.to - e.from > 4096) {
    let r = zg.get(e);
    if (r)
      return r;
    let s = [], n = /* @__PURE__ */ new Set(), o = e.cursor(Te.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let a of Wb(i, o.node, t))
          n.has(a.label) || (n.add(a.label), s.push(a));
      while (o.nextSibling());
    return zg.set(e, s), s;
  } else {
    let r = [], s = /* @__PURE__ */ new Set();
    return e.cursor().iterate((n) => {
      var o;
      if (t(n) && n.matchContext(JL) && ((o = n.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let a = i.sliceString(n.from, n.to);
        s.has(a) || (s.add(a), r.push({ label: a, type: "variable" }));
      }
    }), r;
  }
}
const tM = (i) => (e) => {
  let { state: t, pos: r } = e, s = ke(t).resolveInner(r, -1), n = s.type.isError && s.from == s.to - 1 && t.doc.sliceString(s.from, s.to) == "-";
  if (s.name == "PropertyName" || (n || s.name == "TagName") && /^(Block|Styles)$/.test(s.resolve(s.to).name))
    return { from: s.from, options: zc(), validFor: Pi };
  if (s.name == "ValueName")
    return { from: s.from, options: Wg, validFor: Pi };
  if (s.name == "PseudoClassName")
    return { from: s.from, options: Zg, validFor: Pi };
  if (i(s) || (e.explicit || n) && KL(s, t.doc))
    return {
      from: i(s) || n ? s.from : r,
      options: Wb(t.doc, eM(s), i),
      validFor: GL
    };
  if (s.name == "TagName") {
    for (let { parent: l } = s; l; l = l.parent)
      if (l.name == "Block")
        return { from: s.from, options: zc(), validFor: Pi };
    return { from: s.from, options: FL, validFor: Pi };
  }
  if (s.name == "AtKeyword")
    return { from: s.from, options: HL, validFor: Pi };
  if (!e.explicit)
    return null;
  let o = s.resolve(r), a = o.childBefore(r);
  return a && a.name == ":" && o.name == "PseudoClassSelector" ? { from: r, options: Zg, validFor: Pi } : a && a.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: r, options: Wg, validFor: Pi } : o.name == "Block" || o.name == "Styles" ? { from: r, options: zc(), validFor: Pi } : null;
}, iM = /* @__PURE__ */ tM((i) => i.name == "VariableName"), pl = /* @__PURE__ */ Ht.define({
  name: "css",
  parser: /* @__PURE__ */ YL.configure({
    props: [
      /* @__PURE__ */ ki.add({
        Declaration: /* @__PURE__ */ Pr()
      }),
      /* @__PURE__ */ ei.add({
        "Block KeyframeList": go
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function zb() {
  return new bi(pl, pl.data.of({ autocomplete: iM }));
}
const js = ["_blank", "_self", "_top", "_parent"], Vc = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Uc = ["get", "post", "put", "delete"], jc = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Pt = ["true", "false"], oe = {}, rM = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: js,
      hreflang: null
    }
  },
  abbr: oe,
  address: oe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: oe,
  aside: oe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: oe,
  base: { attrs: { href: null, target: js } },
  bdi: oe,
  bdo: oe,
  blockquote: { attrs: { cite: null } },
  body: oe,
  br: oe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: jc,
      formmethod: Uc,
      formnovalidate: ["novalidate"],
      formtarget: js,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: oe,
  center: oe,
  cite: oe,
  code: oe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: oe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: oe,
  div: oe,
  dl: oe,
  dt: oe,
  em: oe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: oe,
  figure: oe,
  footer: oe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Vc,
      autocomplete: ["on", "off"],
      enctype: jc,
      method: Uc,
      novalidate: ["novalidate"],
      target: js
    }
  },
  h1: oe,
  h2: oe,
  h3: oe,
  h4: oe,
  h5: oe,
  h6: oe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: oe,
  hgroup: oe,
  hr: oe,
  html: {
    attrs: { manifest: null }
  },
  i: oe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: jc,
      formmethod: Uc,
      formnovalidate: ["novalidate"],
      formtarget: js,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: oe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: oe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: oe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Vc,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: oe,
  noscript: oe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: oe,
  param: { attrs: { name: null, value: null } },
  pre: oe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: oe,
  rt: oe,
  ruby: oe,
  samp: oe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Vc
    }
  },
  section: oe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: oe,
  source: { attrs: { src: null, type: null, media: null } },
  span: oe,
  strong: oe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: oe,
  summary: oe,
  sup: oe,
  table: oe,
  tbody: oe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: oe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: oe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: oe,
  time: { attrs: { datetime: null } },
  title: oe,
  tr: oe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: oe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: oe
}, Vb = {
  accesskey: null,
  class: null,
  contenteditable: Pt,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Pt,
  autocorrect: Pt,
  autocapitalize: Pt,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Pt,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Pt,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Pt,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Pt,
  "aria-hidden": Pt,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Pt,
  "aria-multiselectable": Pt,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Pt,
  "aria-relevant": null,
  "aria-required": Pt,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, Ub = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((i) => "on" + i);
for (let i of Ub)
  Vb[i] = null;
class Hn {
  constructor(e, t) {
    this.tags = Object.assign(Object.assign({}, rM), e), this.globalAttrs = Object.assign(Object.assign({}, Vb), t), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
Hn.default = /* @__PURE__ */ new Hn();
function Ss(i, e, t = i.length) {
  if (!e)
    return "";
  let r = e.firstChild, s = r && r.getChild("TagName");
  return s ? i.sliceString(s.from, Math.min(s.to, t)) : "";
}
function _s(i, e = !1) {
  for (; i; i = i.parent)
    if (i.name == "Element")
      if (e)
        e = !1;
      else
        return i;
  return null;
}
function jb(i, e, t) {
  let r = t.tags[Ss(i, _s(e))];
  return r?.children || t.allTags;
}
function Od(i, e) {
  let t = [];
  for (let r = _s(e); r && !r.type.isTop; r = _s(r.parent)) {
    let s = Ss(i, r);
    if (s && r.lastChild.name == "CloseTag")
      break;
    s && t.indexOf(s) < 0 && (e.name == "EndTag" || e.from >= r.firstChild.to) && t.push(s);
  }
  return t;
}
const Nb = /^[:\-\.\w\u00b7-\uffff]*$/;
function Vg(i, e, t, r, s) {
  let n = /\s*>/.test(i.sliceDoc(s, s + 5)) ? "" : ">", o = _s(t, !0);
  return {
    from: r,
    to: s,
    options: jb(i.doc, o, e).map((a) => ({ label: a, type: "type" })).concat(Od(i.doc, t).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + n,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Ug(i, e, t, r) {
  let s = /\s*>/.test(i.sliceDoc(r, r + 5)) ? "" : ">";
  return {
    from: t,
    to: r,
    options: Od(i.doc, e).map((n, o) => ({ label: n, apply: n + s, type: "type", boost: 99 - o })),
    validFor: Nb
  };
}
function sM(i, e, t, r) {
  let s = [], n = 0;
  for (let o of jb(i.doc, t, e))
    s.push({ label: "<" + o, type: "type" });
  for (let o of Od(i.doc, t))
    s.push({ label: "</" + o + ">", type: "type", boost: 99 - n++ });
  return { from: r, to: r, options: s, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function nM(i, e, t, r, s) {
  let n = _s(t), o = n ? e.tags[Ss(i.doc, n)] : null, a = o && o.attrs ? Object.keys(o.attrs) : [], l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: r,
    to: s,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: Nb
  };
}
function oM(i, e, t, r, s) {
  var n;
  let o = (n = t.parent) === null || n === void 0 ? void 0 : n.getChild("AttributeName"), a = [], l;
  if (o) {
    let c = i.sliceDoc(o.from, o.to), h = e.globalAttrs[c];
    if (!h) {
      let f = _s(t), u = f ? e.tags[Ss(i.doc, f)] : null;
      h = u?.attrs && u.attrs[c];
    }
    if (h) {
      let f = i.sliceDoc(r, s).toLowerCase(), u = '"', g = '"';
      /^['"]/.test(f) ? (l = f[0] == '"' ? /^[^"]*$/ : /^[^']*$/, u = "", g = i.sliceDoc(s, s + 1) == f[0] ? "" : f[0], f = f.slice(1), r++) : l = /^[^\s<>='"]*$/;
      for (let S of h)
        a.push({ label: S, apply: u + S + g, type: "constant" });
    }
  }
  return { from: r, to: s, options: a, validFor: l };
}
function Yb(i, e) {
  let { state: t, pos: r } = e, s = ke(t).resolveInner(r, -1), n = s.resolve(r);
  for (let o = r, a; n == s && (a = s.childBefore(o)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    n = s = a, o = l.from;
  }
  return s.name == "TagName" ? s.parent && /CloseTag$/.test(s.parent.name) ? Ug(t, s, s.from, r) : Vg(t, i, s, s.from, r) : s.name == "StartTag" ? Vg(t, i, s, r, r) : s.name == "StartCloseTag" || s.name == "IncompleteCloseTag" ? Ug(t, s, r, r) : s.name == "OpenTag" || s.name == "SelfClosingTag" || s.name == "AttributeName" ? nM(t, i, s, s.name == "AttributeName" ? s.from : r, r) : s.name == "Is" || s.name == "AttributeValue" || s.name == "UnquotedAttributeValue" ? oM(t, i, s, s.name == "Is" ? r : s.from, r) : e.explicit && (n.name == "Element" || n.name == "Text" || n.name == "Document") ? sM(t, i, s, r) : null;
}
function aM(i) {
  return Yb(Hn.default, i);
}
function lM(i) {
  let { extraTags: e, extraGlobalAttributes: t } = i, r = t || e ? new Hn(e, t) : Hn.default;
  return (s) => Yb(r, s);
}
const cM = /* @__PURE__ */ gi.parser.configure({ top: "SingleExpression" }), Fb = [
  {
    tag: "script",
    attrs: (i) => i.type == "text/typescript" || i.lang == "ts",
    parser: eb.parser
  },
  {
    tag: "script",
    attrs: (i) => i.type == "text/babel" || i.type == "text/jsx",
    parser: tb.parser
  },
  {
    tag: "script",
    attrs: (i) => i.type == "text/typescript-jsx",
    parser: ib.parser
  },
  {
    tag: "script",
    attrs(i) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(i.type);
    },
    parser: cM
  },
  {
    tag: "script",
    attrs(i) {
      return !i.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(i.type);
    },
    parser: gi.parser
  },
  {
    tag: "style",
    attrs(i) {
      return (!i.lang || i.lang == "css") && (!i.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(i.type));
    },
    parser: pl.parser
  }
], Hb = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ pl.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ Ub.map((i) => ({ name: i, parser: gi.parser }))), Gb = /* @__PURE__ */ Ht.define({
  name: "html",
  parser: /* @__PURE__ */ QL.configure({
    props: [
      /* @__PURE__ */ ki.add({
        Element(i) {
          let e = /^(\s*)(<\/)?/.exec(i.textAfter);
          return i.node.to <= i.pos + e[0].length ? i.continue() : i.lineIndent(i.node.from) + (e[2] ? 0 : i.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        },
        Document(i) {
          if (i.pos + /\s*/.exec(i.textAfter)[0].length < i.node.to)
            return i.continue();
          let e = null, t;
          for (let r = i.node; ; ) {
            let s = r.lastChild;
            if (!s || s.name != "Element" || s.to != r.to)
              break;
            e = r = s;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? i.lineIndent(e.from) + i.unit : null;
        }
      }),
      /* @__PURE__ */ ei.add({
        Element(i) {
          let e = i.firstChild, t = i.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : i.to };
        }
      }),
      /* @__PURE__ */ Uu.add({
        "OpenTag CloseTag": (i) => i.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), _a = /* @__PURE__ */ Gb.configure({
  wrap: /* @__PURE__ */ Bb(Fb, Hb)
});
function Kb(i = {}) {
  let e = "", t;
  i.matchClosingTags === !1 && (e = "noMatch"), i.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (i.nestedLanguages && i.nestedLanguages.length || i.nestedAttributes && i.nestedAttributes.length) && (t = Bb((i.nestedLanguages || []).concat(Fb), (i.nestedAttributes || []).concat(Hb)));
  let r = t ? Gb.configure({ wrap: t, dialect: e }) : e ? _a.configure({ dialect: e }) : _a;
  return new bi(r, [
    _a.data.of({ autocomplete: lM(i) }),
    i.autoCloseTags !== !1 ? hM : [],
    nb().support,
    zb().support
  ]);
}
const jg = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), hM = /* @__PURE__ */ K.inputHandler.of((i, e, t, r, s) => {
  if (i.composing || i.state.readOnly || e != t || r != ">" && r != "/" || !_a.isActiveAt(i.state, e, -1))
    return !1;
  let n = s(), { state: o } = n, a = o.changeByRange((l) => {
    var c, h, f;
    let u = o.doc.sliceString(l.from - 1, l.to) == r, { head: g } = l, S = ke(o).resolveInner(g, -1), v;
    if (u && r == ">" && S.name == "EndTag") {
      let d = S.parent;
      if (((h = (c = d.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (v = Ss(o.doc, d.parent, g)) && !jg.has(v)) {
        let O = g + (o.doc.sliceString(g, g + 1) === ">" ? 1 : 0), p = `</${v}>`;
        return { range: l, changes: { from: g, to: O, insert: p } };
      }
    } else if (u && r == "/" && S.name == "IncompleteCloseTag") {
      let d = S.parent;
      if (S.from == g - 2 && ((f = d.lastChild) === null || f === void 0 ? void 0 : f.name) != "CloseTag" && (v = Ss(o.doc, d, g)) && !jg.has(v)) {
        let O = g + (o.doc.sliceString(g, g + 1) === ">" ? 1 : 0), p = `${v}>`;
        return {
          range: V.cursor(g + p.length, -1),
          changes: { from: g, to: O, insert: p }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    n,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), Jb = /* @__PURE__ */ Zu({ commentTokens: { block: { open: "<!--", close: "-->" } } }), ey = /* @__PURE__ */ new le(), ty = /* @__PURE__ */ T5.configure({
  props: [
    /* @__PURE__ */ ei.add((i) => !i.is("Block") || i.is("Document") || Xf(i) != null || fM(i) ? void 0 : (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to })),
    /* @__PURE__ */ ey.add(Xf),
    /* @__PURE__ */ ki.add({
      Document: () => null
    }),
    /* @__PURE__ */ wr.add({
      Document: Jb
    })
  ]
});
function Xf(i) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(i.name);
  return e ? +e[1] : void 0;
}
function fM(i) {
  return i.name == "OrderedList" || i.name == "BulletList";
}
function uM(i, e) {
  let t = i;
  for (; ; ) {
    let r = t.nextSibling, s;
    if (!r || (s = Xf(r.type)) != null && s <= e)
      break;
    t = r;
  }
  return t.to;
}
const dM = /* @__PURE__ */ MS.of((i, e, t) => {
  for (let r = ke(i).resolveInner(t, -1); r && !(r.from < e); r = r.parent) {
    let s = r.type.prop(ey);
    if (s == null)
      continue;
    let n = uM(r, s);
    if (n > t)
      return { from: t, to: n };
  }
  return null;
});
function pd(i) {
  return new Dt(Jb, i, [dM], "markdown");
}
const OM = /* @__PURE__ */ pd(ty), pM = /* @__PURE__ */ ty.configure([Z5, z5, W5, V5, {
  props: [
    /* @__PURE__ */ ei.add({
      Table: (i, e) => ({ from: e.doc.lineAt(i.from).to, to: i.to })
    })
  ]
}]), iy = /* @__PURE__ */ pd(pM);
function gM(i, e) {
  return (t) => {
    if (t && i) {
      let r = null;
      if (t = /\S*/.exec(t)[0], typeof i == "function" ? r = i(t) : r = Ga.matchLanguageName(i, t, !0), r instanceof Ga)
        return r.support ? r.support.language.parser : Xn.getSkippingParser(r.load());
      if (r)
        return r.parser;
    }
    return e ? e.parser : null;
  };
}
let Nc = class {
  constructor(e, t, r, s, n, o, a) {
    this.node = e, this.from = t, this.to = r, this.spaceBefore = s, this.spaceAfter = n, this.type = o, this.item = a;
  }
  blank(e, t = !0) {
    let r = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; r.length < e; )
        r += " ";
      return r;
    } else {
      for (let s = this.to - this.from - r.length - this.spaceAfter.length; s > 0; s--)
        r += " ";
      return r + (t ? this.spaceAfter : "");
    }
  }
  marker(e, t) {
    let r = this.node.name == "OrderedList" ? String(+sy(this.item, e)[2] + t) : "";
    return this.spaceBefore + r + this.type + this.spaceAfter;
  }
};
function ry(i, e) {
  let t = [], r = [];
  for (let s = i; s; s = s.parent) {
    if (s.name == "FencedCode")
      return r;
    (s.name == "ListItem" || s.name == "Blockquote") && t.push(s);
  }
  for (let s = t.length - 1; s >= 0; s--) {
    let n = t[s], o, a = e.lineAt(n.from), l = n.from - a.from;
    if (n.name == "Blockquote" && (o = /^ *>( ?)/.exec(a.text.slice(l))))
      r.push(new Nc(n, l, l + o[0].length, "", o[1], ">", null));
    else if (n.name == "ListItem" && n.parent.name == "OrderedList" && (o = /^( *)\d+([.)])( *)/.exec(a.text.slice(l)))) {
      let c = o[3], h = o[0].length;
      c.length >= 4 && (c = c.slice(0, c.length - 4), h -= 4), r.push(new Nc(n.parent, l, l + h, o[1], c, o[2], n));
    } else if (n.name == "ListItem" && n.parent.name == "BulletList" && (o = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(a.text.slice(l)))) {
      let c = o[4], h = o[0].length;
      c.length > 4 && (c = c.slice(0, c.length - 4), h -= 4);
      let f = o[2];
      o[3] && (f += o[3].replace(/[xX]/, " ")), r.push(new Nc(n.parent, l, l + h, o[1], c, f, n));
    }
  }
  return r;
}
function sy(i, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(i.from, i.from + 10));
}
function Yc(i, e, t, r = 0) {
  for (let s = -1, n = i; ; ) {
    if (n.name == "ListItem") {
      let a = sy(n, e), l = +a[2];
      if (s >= 0) {
        if (l != s + 1)
          return;
        t.push({ from: n.from + a[1].length, to: n.from + a[0].length, insert: String(s + 2 + r) });
      }
      s = l;
    }
    let o = n.nextSibling;
    if (!o)
      break;
    n = o;
  }
}
function gd(i, e) {
  let t = /^[ \t]*/.exec(i)[0].length;
  if (!t || e.facet(po) != "	")
    return i;
  let r = Nt(i, 4, t), s = "";
  for (let n = r; n > 0; )
    n >= 4 ? (s += "	", n -= 4) : (s += " ", n--);
  return s + i.slice(t);
}
const mM = ({ state: i, dispatch: e }) => {
  let t = ke(i), { doc: r } = i, s = null, n = i.changeByRange((o) => {
    if (!o.empty || !iy.isActiveAt(i, o.from, 0))
      return s = { range: o };
    let a = o.from, l = r.lineAt(a), c = ry(t.resolveInner(a, -1), r);
    for (; c.length && c[c.length - 1].from > a - l.from; )
      c.pop();
    if (!c.length)
      return s = { range: o };
    let h = c[c.length - 1];
    if (h.to - h.spaceAfter.length > a - l.from)
      return s = { range: o };
    let f = a >= h.to - h.spaceAfter.length && !/\S/.test(l.text.slice(h.to));
    if (h.item && f) {
      let d = h.node.firstChild, O = h.node.getChild("ListItem", "ListItem");
      if (d.to >= a || O && O.to < a || l.from > 0 && !/[^\s>]/.test(r.lineAt(l.from - 1).text)) {
        let p = c.length > 1 ? c[c.length - 2] : null, m, _ = "";
        p && p.item ? (m = l.from + p.from, _ = p.marker(r, 1)) : m = l.from + (p ? p.to : 0);
        let b = [{ from: m, to: a, insert: _ }];
        return h.node.name == "OrderedList" && Yc(h.item, r, b, -2), p && p.node.name == "OrderedList" && Yc(p.item, r, b), { range: V.cursor(m + _.length), changes: b };
      } else {
        let p = Yg(c, i, l);
        return {
          range: V.cursor(a + p.length + 1),
          changes: { from: l.from, insert: p + i.lineBreak }
        };
      }
    }
    if (h.node.name == "Blockquote" && f && l.from) {
      let d = r.lineAt(l.from - 1), O = />\s*$/.exec(d.text);
      if (O && O.index == h.from) {
        let p = i.changes([
          { from: d.from + O.index, to: d.to },
          { from: l.from + h.from, to: l.to }
        ]);
        return { range: o.map(p), changes: p };
      }
    }
    let u = [];
    h.node.name == "OrderedList" && Yc(h.item, r, u);
    let g = h.item && h.item.from < l.from, S = "";
    if (!g || /^[\s\d.)\-+*>]*/.exec(l.text)[0].length >= h.to)
      for (let d = 0, O = c.length - 1; d <= O; d++)
        S += d == O && !g ? c[d].marker(r, 1) : c[d].blank(d < O ? Nt(l.text, 4, c[d + 1].from) - S.length : null);
    let v = a;
    for (; v > l.from && /\s/.test(l.text.charAt(v - l.from - 1)); )
      v--;
    return S = gd(S, i), vM(h.node, i.doc) && (S = Yg(c, i, l) + i.lineBreak + S), u.push({ from: v, to: a, insert: i.lineBreak + S }), { range: V.cursor(v + S.length + 1), changes: u };
  });
  return s ? !1 : (e(i.update(n, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function Ng(i) {
  return i.name == "QuoteMark" || i.name == "ListMark";
}
function vM(i, e) {
  if (i.name != "OrderedList" && i.name != "BulletList")
    return !1;
  let t = i.firstChild, r = i.getChild("ListItem", "ListItem");
  if (!r)
    return !1;
  let s = e.lineAt(t.to), n = e.lineAt(r.from), o = /^[\s>]*$/.test(s.text);
  return s.number + (o ? 0 : 1) < n.number;
}
function Yg(i, e, t) {
  let r = "";
  for (let s = 0, n = i.length - 2; s <= n; s++)
    r += i[s].blank(s < n ? Nt(t.text, 4, Math.min(t.text.length, i[s + 1].from)) - r.length : null, s < n);
  return gd(r, e);
}
function SM(i, e) {
  let t = i.resolveInner(e, -1), r = e;
  Ng(t) && (r = t.from, t = t.parent);
  for (let s; s = t.childBefore(r); )
    if (Ng(s))
      r = s.from;
    else if (s.name == "OrderedList" || s.name == "BulletList")
      t = s.lastChild, r = t.to;
    else
      break;
  return t;
}
const _M = ({ state: i, dispatch: e }) => {
  let t = ke(i), r = null, s = i.changeByRange((n) => {
    let o = n.from, { doc: a } = i;
    if (n.empty && iy.isActiveAt(i, n.from)) {
      let l = a.lineAt(o), c = ry(SM(t, o), a);
      if (c.length) {
        let h = c[c.length - 1], f = h.to - h.spaceAfter.length + (h.spaceAfter ? 1 : 0);
        if (o - l.from > f && !/\S/.test(l.text.slice(f, o - l.from)))
          return {
            range: V.cursor(l.from + f),
            changes: { from: l.from + f, to: o }
          };
        if (o - l.from == f && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!h.item || l.from <= h.item.from || !/\S/.test(l.text.slice(0, h.to)))) {
          let u = l.from + h.from;
          if (h.item && h.node.from < h.item.from && /\S/.test(l.text.slice(h.from, h.to))) {
            let g = h.blank(Nt(l.text, 4, h.to) - Nt(l.text, 4, h.from));
            return u == l.from && (g = gd(g, i)), {
              range: V.cursor(u + g.length),
              changes: { from: u, to: l.from + h.to, insert: g }
            };
          }
          if (u < o)
            return { range: V.cursor(u), changes: { from: u, to: o } };
        }
      }
    }
    return r = { range: n };
  });
  return r ? !1 : (e(i.update(s, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, bM = [
  { key: "Enter", run: mM },
  { key: "Backspace", run: _M }
], ny = /* @__PURE__ */ Kb({ matchClosingTags: !1 });
function yM(i = {}) {
  let { codeLanguages: e, defaultCodeLanguage: t, addKeymap: r = !0, base: { parser: s } = OM, completeHTMLTags: n = !0, htmlTagLanguage: o = ny } = i;
  if (!(s instanceof Vl))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let a = i.extensions ? [i.extensions] : [], l = [o.support], c;
  t instanceof bi ? (l.push(t.support), c = t.language) : t && (c = t);
  let h = e || c ? gM(e, c) : void 0;
  a.push(E5({ codeParser: h, htmlParser: o.language.parser })), r && l.push(Vi.high(fo.of(bM)));
  let f = pd(s.configure(a));
  return n && l.push(f.data.of({ autocomplete: wM })), new bi(f, l);
}
function wM(i) {
  let { state: e, pos: t } = i, r = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(t - 25, t));
  if (!r)
    return null;
  let s = ke(e).resolveInner(t, -1);
  for (; s && !s.type.isTop; ) {
    if (s.name == "CodeBlock" || s.name == "FencedCode" || s.name == "ProcessingInstructionBlock" || s.name == "CommentBlock" || s.name == "Link" || s.name == "Image")
      return null;
    s = s.parent;
  }
  return {
    from: t - r[0].length,
    to: t,
    options: xM(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
let Fc = null;
function xM() {
  if (Fc)
    return Fc;
  let i = aM(new Ju(_e.create({ extensions: ny }), 0, !0));
  return Fc = i ? i.options : [];
}
const kM = 36, Fg = 1, CM = 2, Vr = 3, Hc = 4, QM = 5, PM = 6, $M = 7, TM = 8, RM = 9, EM = 10, AM = 11, LM = 12, MM = 13, DM = 14, qM = 15, BM = 16, XM = 17, Hg = 18, IM = 19, oy = 20, ay = 21, Gg = 22, ZM = 23, WM = 24;
function If(i) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 48 && i <= 57;
}
function zM(i) {
  return i >= 48 && i <= 57 || i >= 97 && i <= 102 || i >= 65 && i <= 70;
}
function gr(i, e, t) {
  for (let r = !1; ; ) {
    if (i.next < 0)
      return;
    if (i.next == e && !r) {
      i.advance();
      return;
    }
    r = t && !r && i.next == 92, i.advance();
  }
}
function VM(i, e) {
  e: for (; ; ) {
    if (i.next < 0)
      return;
    if (i.next == 36) {
      i.advance();
      for (let t = 0; t < e.length; t++) {
        if (i.next != e.charCodeAt(t))
          continue e;
        i.advance();
      }
      if (i.next == 36) {
        i.advance();
        return;
      }
    } else
      i.advance();
  }
}
function UM(i, e) {
  let t = "[{<(".indexOf(String.fromCharCode(e)), r = t < 0 ? e : "]}>)".charCodeAt(t);
  for (; ; ) {
    if (i.next < 0)
      return;
    if (i.next == r && i.peek(1) == 39) {
      i.advance(2);
      return;
    }
    i.advance();
  }
}
function Zf(i, e) {
  for (; !(i.next != 95 && !If(i.next)); )
    e != null && (e += String.fromCharCode(i.next)), i.advance();
  return e;
}
function jM(i) {
  if (i.next == 39 || i.next == 34 || i.next == 96) {
    let e = i.next;
    i.advance(), gr(i, e, !1);
  } else
    Zf(i);
}
function Kg(i, e) {
  for (; i.next == 48 || i.next == 49; )
    i.advance();
  e && i.next == e && i.advance();
}
function Jg(i, e) {
  for (; ; ) {
    if (i.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (i.next < 48 || i.next > 57)
      break;
    i.advance();
  }
  if (i.next == 69 || i.next == 101)
    for (i.advance(), (i.next == 43 || i.next == 45) && i.advance(); i.next >= 48 && i.next <= 57; )
      i.advance();
}
function em(i) {
  for (; !(i.next < 0 || i.next == 10); )
    i.advance();
}
function Or(i, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == i)
      return !0;
  return !1;
}
const Gc = ` 	\r
`;
function ly(i, e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  r.true = r.false = QM, r.null = r.unknown = PM;
  for (let s of i.split(" "))
    s && (r[s] = oy);
  for (let s of e.split(" "))
    s && (r[s] = ay);
  for (let s of (t || "").split(" "))
    s && (r[s] = WM);
  return r;
}
const NM = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", YM = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", Wf = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: !1,
  words: /* @__PURE__ */ ly(YM, NM)
};
function FM(i, e, t, r) {
  let s = {};
  for (let n in Wf)
    s[n] = (i.hasOwnProperty(n) ? i : Wf)[n];
  return e && (s.words = ly(e, t || "", r)), s;
}
function cy(i) {
  return new Xe((e) => {
    var t;
    let { next: r } = e;
    if (e.advance(), Or(r, Gc)) {
      for (; Or(e.next, Gc); )
        e.advance();
      e.acceptToken(kM);
    } else if (r == 36 && i.doubleDollarQuotedStrings) {
      let s = Zf(e, "");
      e.next == 36 && (e.advance(), VM(e, s), e.acceptToken(Vr));
    } else if (r == 39 || r == 34 && i.doubleQuotedStrings)
      gr(e, r, i.backslashEscapes), e.acceptToken(Vr);
    else if (r == 35 && i.hashComments || r == 47 && e.next == 47 && i.slashComments)
      em(e), e.acceptToken(Fg);
    else if (r == 45 && e.next == 45 && (!i.spaceAfterDashes || e.peek(1) == 32))
      em(e), e.acceptToken(Fg);
    else if (r == 47 && e.next == 42) {
      e.advance();
      for (let s = 1; ; ) {
        let n = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), n == 42 && e.next == 47) {
          if (s--, e.advance(), !s)
            break;
        } else n == 47 && e.next == 42 && (s++, e.advance());
      }
      e.acceptToken(CM);
    } else if ((r == 101 || r == 69) && e.next == 39)
      e.advance(), gr(e, 39, !0), e.acceptToken(Vr);
    else if ((r == 110 || r == 78) && e.next == 39 && i.charSetCasts)
      e.advance(), gr(e, 39, i.backslashEscapes), e.acceptToken(Vr);
    else if (r == 95 && i.charSetCasts)
      for (let s = 0; ; s++) {
        if (e.next == 39 && s > 1) {
          e.advance(), gr(e, 39, i.backslashEscapes), e.acceptToken(Vr);
          break;
        }
        if (!If(e.next))
          break;
        e.advance();
      }
    else if (i.plsqlQuotingMechanism && (r == 113 || r == 81) && e.next == 39 && e.peek(1) > 0 && !Or(e.peek(1), Gc)) {
      let s = e.peek(1);
      e.advance(2), UM(e, s), e.acceptToken(Vr);
    } else if (r == 40)
      e.acceptToken($M);
    else if (r == 41)
      e.acceptToken(TM);
    else if (r == 123)
      e.acceptToken(RM);
    else if (r == 125)
      e.acceptToken(EM);
    else if (r == 91)
      e.acceptToken(AM);
    else if (r == 93)
      e.acceptToken(LM);
    else if (r == 59)
      e.acceptToken(MM);
    else if (i.unquotedBitLiterals && r == 48 && e.next == 98)
      e.advance(), Kg(e), e.acceptToken(Gg);
    else if ((r == 98 || r == 66) && (e.next == 39 || e.next == 34)) {
      const s = e.next;
      e.advance(), i.treatBitsAsBytes ? (gr(e, s, i.backslashEscapes), e.acceptToken(ZM)) : (Kg(e, s), e.acceptToken(Gg));
    } else if (r == 48 && (e.next == 120 || e.next == 88) || (r == 120 || r == 88) && e.next == 39) {
      let s = e.next == 39;
      for (e.advance(); zM(e.next); )
        e.advance();
      s && e.next == 39 && e.advance(), e.acceptToken(Hc);
    } else if (r == 46 && e.next >= 48 && e.next <= 57)
      Jg(e, !0), e.acceptToken(Hc);
    else if (r == 46)
      e.acceptToken(DM);
    else if (r >= 48 && r <= 57)
      Jg(e, !1), e.acceptToken(Hc);
    else if (Or(r, i.operatorChars)) {
      for (; Or(e.next, i.operatorChars); )
        e.advance();
      e.acceptToken(qM);
    } else if (Or(r, i.specialVar))
      e.next == r && e.advance(), jM(e), e.acceptToken(XM);
    else if (Or(r, i.identifierQuotes))
      gr(e, r, !1), e.acceptToken(IM);
    else if (r == 58 || r == 44)
      e.acceptToken(BM);
    else if (If(r)) {
      let s = Zf(e, String.fromCharCode(r));
      e.acceptToken(e.next == 46 || e.peek(-s.length - 1) == 46 ? Hg : (t = i.words[s.toLowerCase()]) !== null && t !== void 0 ? t : Hg);
    }
  });
}
const hy = /* @__PURE__ */ cy(Wf), HM = /* @__PURE__ */ Gt.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, hy],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function zf(i) {
  let e = i.cursor().moveTo(i.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function Gn(i, e) {
  let t = i.sliceString(e.from, e.to), r = /^([`'"])(.*)\1$/.exec(t);
  return r ? r[2] : t;
}
function gl(i) {
  return i && (i.name == "Identifier" || i.name == "QuotedIdentifier");
}
function GM(i, e) {
  if (e.name == "CompositeIdentifier") {
    let t = [];
    for (let r = e.firstChild; r; r = r.nextSibling)
      gl(r) && t.push(Gn(i, r));
    return t;
  }
  return [Gn(i, e)];
}
function tm(i, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let r = zf(e);
    if (!gl(r))
      return t;
    t.unshift(Gn(i, r)), e = zf(r);
  }
}
function KM(i, e) {
  let t = ke(i).resolveInner(e, -1), r = eD(i.doc, t);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" || t.name == "Keyword" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? i.doc.sliceString(t.from, t.from + 1) : null,
    parents: tm(i.doc, zf(t)),
    aliases: r
  } : t.name == "." ? { from: e, quoted: null, parents: tm(i.doc, t), aliases: r } : { from: e, quoted: null, parents: [], empty: !0, aliases: r };
}
const JM = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function eD(i, e) {
  let t;
  for (let s = e; !t; s = s.parent) {
    if (!s)
      return null;
    s.name == "Statement" && (t = s);
  }
  let r = null;
  for (let s = t.firstChild, n = !1, o = null; s; s = s.nextSibling) {
    let a = s.name == "Keyword" ? i.sliceString(s.from, s.to).toLowerCase() : null, l = null;
    if (!n)
      n = a == "from";
    else if (a == "as" && o && gl(s.nextSibling))
      l = Gn(i, s.nextSibling);
    else {
      if (a && JM.has(a))
        break;
      o && gl(s) && (l = Gn(i, s));
    }
    l && (r || (r = /* @__PURE__ */ Object.create(null)), r[l] = GM(i, o)), o = /Identifier$/.test(s.name) ? s : null;
  }
  return r;
}
function tD(i, e) {
  return i ? e.map((t) => ({ ...t, label: t.label[0] == i ? t.label : i + t.label + i, apply: void 0 })) : e;
}
const iD = /^\w*$/, rD = /^[`'"]?\w*[`'"]?$/;
function im(i) {
  return i.self && typeof i.self.label == "string";
}
class md {
  constructor(e, t) {
    this.idQuote = e, this.idCaseInsensitive = t, this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null)), r = t[e];
    return r || (e && !this.list.some((s) => s.label == e) && this.list.push(rm(e, "type", this.idQuote, this.idCaseInsensitive)), t[e] = new md(this.idQuote, this.idCaseInsensitive));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let t = this.list.findIndex((r) => r.label == e.label);
    t > -1 ? this.list[t] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let t of e)
      this.addCompletion(typeof t == "string" ? rm(t, "property", this.idQuote, this.idCaseInsensitive) : t);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : im(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let t of Object.keys(e)) {
      let r = e[t], s = null, n = t.replace(/\\?\./g, (a) => a == "." ? "\0" : a).split("\0"), o = this;
      im(r) && (s = r.self, r = r.children);
      for (let a = 0; a < n.length; a++)
        s && a == n.length - 1 && o.addCompletion(s), o = o.child(n[a].replace(/\\\./g, "."));
      o.addNamespace(r);
    }
  }
}
function rm(i, e, t, r) {
  return new RegExp("^[a-z_][a-z_\\d]*$", r ? "i" : "").test(i) ? { label: i, type: e } : { label: i, type: e, apply: t + i + t };
}
function sD(i, e, t, r, s, n) {
  var o;
  let a = ((o = n?.spec.identifierQuotes) === null || o === void 0 ? void 0 : o[0]) || '"', l = new md(a, !!n?.spec.caseInsensitiveIdentifiers), c = s ? l.child(s) : null;
  return l.addNamespace(i), e && (c || l).addCompletions(e), t && l.addCompletions(t), c && l.addCompletions(c.list), r && l.addCompletions((c || l).child(r).list), (h) => {
    let { parents: f, from: u, quoted: g, empty: S, aliases: v } = KM(h.state, h.pos);
    if (S && !h.explicit)
      return null;
    v && f.length == 1 && (f = v[f[0]] || f);
    let d = l;
    for (let m of f) {
      for (; !d.children || !d.children[m]; )
        if (d == l && c)
          d = c;
        else if (d == c && r)
          d = d.child(r);
        else
          return null;
      let _ = d.maybeChild(m);
      if (!_)
        return null;
      d = _;
    }
    let O = g && h.state.sliceDoc(h.pos, h.pos + 1) == g, p = d.list;
    return d == l && v && (p = p.concat(Object.keys(v).map((m) => ({ label: m, type: "constant" })))), {
      from: u,
      to: O ? h.pos + 1 : void 0,
      options: tD(g, p),
      validFor: g ? rD : iD
    };
  };
}
function nD(i) {
  return i == ay ? "type" : i == oy ? "keyword" : "variable";
}
function oD(i, e, t) {
  let r = Object.keys(i).map((s) => t(e ? s.toUpperCase() : s, nD(i[s])));
  return ed(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], Wl(r));
}
let aD = /* @__PURE__ */ HM.configure({
  props: [
    /* @__PURE__ */ ki.add({
      Statement: /* @__PURE__ */ Pr()
    }),
    /* @__PURE__ */ ei.add({
      Statement(i, e) {
        return { from: Math.min(i.from + 100, e.doc.lineAt(i.from).to), to: i.to };
      },
      BlockComment(i) {
        return { from: i.from + 2, to: i.to - 2 };
      }
    }),
    /* @__PURE__ */ Jt({
      Keyword: C.keyword,
      Type: C.typeName,
      Builtin: /* @__PURE__ */ C.standard(C.name),
      Bits: C.number,
      Bytes: C.string,
      Bool: C.bool,
      Null: C.null,
      Number: C.number,
      String: C.string,
      Identifier: C.name,
      QuotedIdentifier: /* @__PURE__ */ C.special(C.string),
      SpecialVar: /* @__PURE__ */ C.special(C.name),
      LineComment: C.lineComment,
      BlockComment: C.blockComment,
      Operator: C.operator,
      "Semi Punctuation": C.punctuation,
      "( )": C.paren,
      "{ }": C.brace,
      "[ ]": C.squareBracket
    })
  ]
});
class ml {
  constructor(e, t, r) {
    this.dialect = e, this.language = t, this.spec = r;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Reconfigure the parser used by this dialect. Returns a new
  dialect object.
  */
  configureLanguage(e, t) {
    return new ml(this.dialect, this.language.configure(e, t), this.spec);
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = FM(e, e.keywords, e.types, e.builtin), r = Ht.define({
      name: "sql",
      parser: aD.configure({
        tokenizers: [{ from: hy, to: cy(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new ml(t, r, e);
  }
}
function lD(i, e) {
  return { label: i, type: e, boost: -1 };
}
function cD(i, e = !1, t) {
  return oD(i.dialect.words, e, t || lD);
}
function hD(i) {
  return i.schema ? sD(i.schema, i.tables, i.schemas, i.defaultTable, i.defaultSchema, i.dialect || vd) : () => null;
}
function fD(i) {
  return i.schema ? (i.dialect || vd).language.data.of({
    autocomplete: hD(i)
  }) : [];
}
function uD(i = {}) {
  let e = i.dialect || vd;
  return new bi(e.language, [
    fD(i),
    e.language.data.of({
      autocomplete: cD(e, i.upperCaseKeywords, i.keywordCompletion)
    })
  ]);
}
const vd = /* @__PURE__ */ ml.define({}), dD = 1, fy = 194, uy = 195, OD = 196, sm = 197, pD = 198, gD = 199, mD = 200, vD = 2, dy = 3, nm = 201, SD = 24, _D = 25, bD = 49, yD = 50, wD = 55, xD = 56, kD = 57, CD = 59, QD = 60, PD = 61, $D = 62, TD = 63, RD = 65, ED = 238, AD = 71, LD = 241, MD = 242, DD = 243, qD = 244, BD = 245, XD = 246, ID = 247, ZD = 248, Oy = 72, WD = 249, zD = 250, VD = 251, UD = 252, jD = 253, ND = 254, YD = 255, FD = 256, HD = 73, GD = 77, KD = 263, JD = 112, e4 = 130, t4 = 151, i4 = 152, r4 = 155, Xr = 10, Kn = 13, Sd = 32, Ul = 9, _d = 35, s4 = 40, n4 = 46, Vf = 123, om = 125, py = 39, gy = 34, am = 92, o4 = 111, a4 = 120, l4 = 78, c4 = 117, h4 = 85, f4 = /* @__PURE__ */ new Set([
  _D,
  bD,
  yD,
  KD,
  RD,
  e4,
  xD,
  kD,
  ED,
  $D,
  TD,
  Oy,
  HD,
  GD,
  QD,
  PD,
  t4,
  i4,
  r4,
  JD
]);
function Kc(i) {
  return i == Xr || i == Kn;
}
function Jc(i) {
  return i >= 48 && i <= 57 || i >= 65 && i <= 70 || i >= 97 && i <= 102;
}
const u4 = new Xe((i, e) => {
  let t;
  if (i.next < 0)
    i.acceptToken(gD);
  else if (e.context.flags & ba)
    Kc(i.next) && i.acceptToken(pD, 1);
  else if (((t = i.peek(-1)) < 0 || Kc(t)) && e.canShift(sm)) {
    let r = 0;
    for (; i.next == Sd || i.next == Ul; )
      i.advance(), r++;
    (i.next == Xr || i.next == Kn || i.next == _d) && i.acceptToken(sm, -r);
  } else Kc(i.next) && i.acceptToken(OD, 1);
}, { contextual: !0 }), d4 = new Xe((i, e) => {
  let t = e.context;
  if (t.flags) return;
  let r = i.peek(-1);
  if (r == Xr || r == Kn) {
    let s = 0, n = 0;
    for (; ; ) {
      if (i.next == Sd) s++;
      else if (i.next == Ul) s += 8 - s % 8;
      else break;
      i.advance(), n++;
    }
    s != t.indent && i.next != Xr && i.next != Kn && i.next != _d && (s < t.indent ? i.acceptToken(uy, -n) : i.acceptToken(fy));
  }
}), ba = 1, my = 2, $i = 4, Ti = 8, Ri = 16, Ei = 32;
function ya(i, e, t) {
  this.parent = i, this.indent = e, this.flags = t, this.hash = (i ? i.hash + i.hash << 8 : 0) + e + (e << 4) + t + (t << 6);
}
const O4 = new ya(null, 0, 0);
function p4(i) {
  let e = 0;
  for (let t = 0; t < i.length; t++)
    e += i.charCodeAt(t) == Ul ? 8 - e % 8 : 1;
  return e;
}
const lm = new Map([
  [LD, 0],
  [MD, $i],
  [DD, Ti],
  [qD, Ti | $i],
  [BD, Ri],
  [XD, Ri | $i],
  [ID, Ri | Ti],
  [ZD, Ri | Ti | $i],
  [WD, Ei],
  [zD, Ei | $i],
  [VD, Ei | Ti],
  [UD, Ei | Ti | $i],
  [jD, Ei | Ri],
  [ND, Ei | Ri | $i],
  [YD, Ei | Ri | Ti],
  [FD, Ei | Ri | Ti | $i]
].map(([i, e]) => [i, e | my])), g4 = new bo({
  start: O4,
  reduce(i, e, t, r) {
    return i.flags & ba && f4.has(e) || (e == AD || e == Oy) && i.flags & my ? i.parent : i;
  },
  shift(i, e, t, r) {
    return e == fy ? new ya(i, p4(r.read(r.pos, t.pos)), 0) : e == uy ? i.parent : e == SD || e == wD || e == CD || e == dy ? new ya(i, 0, ba) : lm.has(e) ? new ya(i, 0, lm.get(e) | i.flags & ba) : i;
  },
  hash(i) {
    return i.hash;
  }
}), m4 = new Xe((i) => {
  for (let e = 0; e < 5; e++) {
    if (i.next != "print".charCodeAt(e)) return;
    i.advance();
  }
  if (!/\w/.test(String.fromCharCode(i.next)))
    for (let e = 0; ; e++) {
      let t = i.peek(e);
      if (!(t == Sd || t == Ul)) {
        t != s4 && t != n4 && t != Xr && t != Kn && t != _d && i.acceptToken(dD);
        return;
      }
    }
}), v4 = new Xe((i, e) => {
  let { flags: t } = e.context, r = t & $i ? gy : py, s = (t & Ti) > 0, n = !(t & Ri), o = (t & Ei) > 0, a = i.pos;
  for (; !(i.next < 0); )
    if (o && i.next == Vf)
      if (i.peek(1) == Vf)
        i.advance(2);
      else {
        if (i.pos == a) {
          i.acceptToken(dy, 1);
          return;
        }
        break;
      }
    else if (n && i.next == am) {
      if (i.pos == a) {
        i.advance();
        let l = i.next;
        l >= 0 && (i.advance(), S4(i, l)), i.acceptToken(vD);
        return;
      }
      break;
    } else if (i.next == am && !n && i.peek(1) > -1)
      i.advance(2);
    else if (i.next == r && (!s || i.peek(1) == r && i.peek(2) == r)) {
      if (i.pos == a) {
        i.acceptToken(nm, s ? 3 : 1);
        return;
      }
      break;
    } else if (i.next == Xr) {
      if (s)
        i.advance();
      else if (i.pos == a) {
        i.acceptToken(nm);
        return;
      }
      break;
    } else
      i.advance();
  i.pos > a && i.acceptToken(mD);
});
function S4(i, e) {
  if (e == o4)
    for (let t = 0; t < 2 && i.next >= 48 && i.next <= 55; t++) i.advance();
  else if (e == a4)
    for (let t = 0; t < 2 && Jc(i.next); t++) i.advance();
  else if (e == c4)
    for (let t = 0; t < 4 && Jc(i.next); t++) i.advance();
  else if (e == h4)
    for (let t = 0; t < 8 && Jc(i.next); t++) i.advance();
  else if (e == l4 && i.next == Vf) {
    for (i.advance(); i.next >= 0 && i.next != om && i.next != py && i.next != gy && i.next != Xr; ) i.advance();
    i.next == om && i.advance();
  }
}
const _4 = Jt({
  'async "*" "**" FormatConversion FormatSpec': C.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": C.controlKeyword,
  "in not and or is del": C.operatorKeyword,
  "from def class global nonlocal lambda": C.definitionKeyword,
  import: C.moduleKeyword,
  "with as print": C.keyword,
  Boolean: C.bool,
  None: C.null,
  VariableName: C.variableName,
  "CallExpression/VariableName": C.function(C.variableName),
  "FunctionDefinition/VariableName": C.function(C.definition(C.variableName)),
  "ClassDefinition/VariableName": C.definition(C.className),
  PropertyName: C.propertyName,
  "CallExpression/MemberExpression/PropertyName": C.function(C.propertyName),
  Comment: C.lineComment,
  Number: C.number,
  String: C.string,
  FormatString: C.special(C.string),
  Escape: C.escape,
  UpdateOp: C.updateOperator,
  "ArithOp!": C.arithmeticOperator,
  BitOp: C.bitwiseOperator,
  CompareOp: C.compareOperator,
  AssignOp: C.definitionOperator,
  Ellipsis: C.punctuation,
  At: C.meta,
  "( )": C.paren,
  "[ ]": C.squareBracket,
  "{ }": C.brace,
  ".": C.derefOperator,
  ", ;": C.separator
}), b4 = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 }, y4 = Gt.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j",
  stateData: "$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: "⚠ print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: g4,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [_4],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [m4, d4, u4, v4, 0, 1, 2, 3, 4],
  topRules: { Script: [0, 5] },
  specialized: [{ term: 221, get: (i) => b4[i] || -1 }],
  tokenPrec: 7668
}), cm = /* @__PURE__ */ new Xu(), vy = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function Ko(i) {
  return (e, t, r) => {
    if (r)
      return !1;
    let s = e.node.getChild("VariableName");
    return s && t(s, i), !0;
  };
}
const w4 = {
  FunctionDefinition: /* @__PURE__ */ Ko("function"),
  ClassDefinition: /* @__PURE__ */ Ko("class"),
  ForStatement(i, e, t) {
    if (t) {
      for (let r = i.node.firstChild; r; r = r.nextSibling)
        if (r.name == "VariableName")
          e(r, "variable");
        else if (r.name == "in")
          break;
    }
  },
  ImportStatement(i, e) {
    var t, r;
    let { node: s } = i, n = ((t = s.firstChild) === null || t === void 0 ? void 0 : t.name) == "from";
    for (let o = s.getChild("import"); o; o = o.nextSibling)
      o.name == "VariableName" && ((r = o.nextSibling) === null || r === void 0 ? void 0 : r.name) != "as" && e(o, n ? "variable" : "namespace");
  },
  AssignStatement(i, e) {
    for (let t = i.node.firstChild; t; t = t.nextSibling)
      if (t.name == "VariableName")
        e(t, "variable");
      else if (t.name == ":" || t.name == "AssignOp")
        break;
  },
  ParamList(i, e) {
    for (let t = null, r = i.node.firstChild; r; r = r.nextSibling)
      r.name == "VariableName" && (!t || !/\*|AssignOp/.test(t.name)) && e(r, "variable"), t = r;
  },
  CapturePattern: /* @__PURE__ */ Ko("variable"),
  AsPattern: /* @__PURE__ */ Ko("variable"),
  __proto__: null
};
function Sy(i, e) {
  let t = cm.get(e);
  if (t)
    return t;
  let r = [], s = !0;
  function n(o, a) {
    let l = i.sliceString(o.from, o.to);
    r.push({ label: l, type: a });
  }
  return e.cursor(Te.IncludeAnonymous).iterate((o) => {
    if (o.name) {
      let a = w4[o.name];
      if (a && a(o, n, s) || !s && vy.has(o.name))
        return !1;
      s = !1;
    } else if (o.to - o.from > 8192) {
      for (let a of Sy(i, o.node))
        r.push(a);
      return !1;
    }
  }), cm.set(e, r), r;
}
const hm = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, _y = ["String", "FormatString", "Comment", "PropertyName"];
function x4(i) {
  let e = ke(i.state).resolveInner(i.pos, -1);
  if (_y.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && hm.test(i.state.sliceDoc(e.from, e.to));
  if (!t && !i.explicit)
    return null;
  let r = [];
  for (let s = e; s; s = s.parent)
    vy.has(s.name) && (r = r.concat(Sy(i.state.doc, s)));
  return {
    options: r,
    from: t ? e.from : i.pos,
    validFor: hm
  };
}
const k4 = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((i) => ({ label: i, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((i) => ({ label: i, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((i) => ({ label: i, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((i) => ({ label: i, type: "function" }))), C4 = [
  /* @__PURE__ */ Be("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ Be("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], Q4 = /* @__PURE__ */ ed(_y, /* @__PURE__ */ Wl(/* @__PURE__ */ k4.concat(C4)));
function eh(i) {
  let { node: e, pos: t } = i, r = i.lineIndent(t, -1), s = null;
  for (; ; ) {
    let n = e.childBefore(t);
    if (n)
      if (n.name == "Comment")
        t = n.from;
      else if (n.name == "Body" || n.name == "MatchBody")
        i.baseIndentFor(n) + i.unit <= r && (s = n), e = n;
      else if (n.name == "MatchClause")
        e = n;
      else if (n.type.is("Statement"))
        e = n;
      else
        break;
    else break;
  }
  return s;
}
function th(i, e) {
  let t = i.baseIndentFor(e), r = i.lineAt(i.pos, -1), s = r.from + r.text.length;
  return /^\s*($|#)/.test(r.text) && i.node.to < s + 100 && !/\S/.test(i.state.sliceDoc(s, i.node.to)) && i.lineIndent(i.pos, -1) <= t || /^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(i.textAfter) && i.lineIndent(i.pos, -1) > t ? null : t + i.unit;
}
const ih = /* @__PURE__ */ Ht.define({
  name: "python",
  parser: /* @__PURE__ */ y4.configure({
    props: [
      /* @__PURE__ */ ki.add({
        Body: (i) => {
          var e;
          let t = /^\s*(#|$)/.test(i.textAfter) && eh(i) || i.node;
          return (e = th(i, t)) !== null && e !== void 0 ? e : i.continue();
        },
        MatchBody: (i) => {
          var e;
          let t = eh(i);
          return (e = th(i, t || i.node)) !== null && e !== void 0 ? e : i.continue();
        },
        IfStatement: (i) => /^\s*(else:|elif )/.test(i.textAfter) ? i.baseIndent : i.continue(),
        "ForStatement WhileStatement": (i) => /^\s*else:/.test(i.textAfter) ? i.baseIndent : i.continue(),
        TryStatement: (i) => /^\s*(except[ :]|finally:|else:)/.test(i.textAfter) ? i.baseIndent : i.continue(),
        MatchStatement: (i) => /^\s*case /.test(i.textAfter) ? i.baseIndent + i.unit : i.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ ns({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ ns({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ ns({ closing: "]" }),
        MemberExpression: (i) => i.baseIndent + i.unit,
        "String FormatString": () => null,
        Script: (i) => {
          var e;
          let t = eh(i);
          return (e = t && th(i, t)) !== null && e !== void 0 ? e : i.continue();
        }
      }),
      /* @__PURE__ */ ei.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": go,
        Body: (i, e) => ({ from: i.from + 1, to: i.to - (i.to == e.doc.length ? 0 : 1) }),
        "String FormatString": (i, e) => ({ from: e.doc.lineAt(i.from).to, to: i.to })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    // Indent logic logic are triggered upon below input patterns
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
  }
});
function P4() {
  return new bi(ih, [
    ih.data.of({ autocomplete: x4 }),
    ih.data.of({ autocomplete: Q4 })
  ]);
}
const Hr = 63, fm = 64, $4 = 1, T4 = 2, by = 3, R4 = 4, yy = 5, E4 = 6, A4 = 7, wy = 65, L4 = 66, M4 = 8, D4 = 9, q4 = 10, B4 = 11, X4 = 12, xy = 13, I4 = 19, Z4 = 20, W4 = 29, z4 = 33, V4 = 34, U4 = 47, j4 = 0, bd = 1, Uf = 2, Jn = 3, jf = 4;
class _r {
  constructor(e, t, r) {
    this.parent = e, this.depth = t, this.type = r, this.hash = (e ? e.hash + e.hash << 8 : 0) + t + (t << 4) + r;
  }
}
_r.top = new _r(null, -1, j4);
function dn(i, e) {
  for (let t = 0, r = e - i.pos - 1; ; r--, t++) {
    let s = i.peek(r);
    if (zi(s) || s == -1) return t;
  }
}
function Nf(i) {
  return i == 32 || i == 9;
}
function zi(i) {
  return i == 10 || i == 13;
}
function ky(i) {
  return Nf(i) || zi(i);
}
function kr(i) {
  return i < 0 || ky(i);
}
const N4 = new bo({
  start: _r.top,
  reduce(i, e) {
    return i.type == Jn && (e == Z4 || e == V4) ? i.parent : i;
  },
  shift(i, e, t, r) {
    if (e == by)
      return new _r(i, dn(r, r.pos), bd);
    if (e == wy || e == yy)
      return new _r(i, dn(r, r.pos), Uf);
    if (e == Hr)
      return i.parent;
    if (e == I4 || e == z4)
      return new _r(i, 0, Jn);
    if (e == xy && i.type == jf)
      return i.parent;
    if (e == U4) {
      let s = /[1-9]/.exec(r.read(r.pos, t.pos));
      if (s) return new _r(i, i.depth + +s[0], jf);
    }
    return i;
  },
  hash(i) {
    return i.hash;
  }
});
function bs(i, e, t = 0) {
  return i.peek(t) == e && i.peek(t + 1) == e && i.peek(t + 2) == e && kr(i.peek(t + 3));
}
const Y4 = new Xe((i, e) => {
  if (i.next == -1 && e.canShift(fm))
    return i.acceptToken(fm);
  let t = i.peek(-1);
  if ((zi(t) || t < 0) && e.context.type != Jn) {
    if (bs(
      i,
      45
      /* '-' */
    ))
      if (e.canShift(Hr)) i.acceptToken(Hr);
      else return i.acceptToken($4, 3);
    if (bs(
      i,
      46
      /* '.' */
    ))
      if (e.canShift(Hr)) i.acceptToken(Hr);
      else return i.acceptToken(T4, 3);
    let r = 0;
    for (; i.next == 32; )
      r++, i.advance();
    (r < e.context.depth || r == e.context.depth && e.context.type == bd && (i.next != 45 || !kr(i.peek(1)))) && // Not blank
    i.next != -1 && !zi(i.next) && i.next != 35 && i.acceptToken(Hr, -r);
  }
}, { contextual: !0 }), F4 = new Xe((i, e) => {
  if (e.context.type == Jn) {
    i.next == 63 && (i.advance(), kr(i.next) && i.acceptToken(A4));
    return;
  }
  if (i.next == 45)
    i.advance(), kr(i.next) && i.acceptToken(e.context.type == bd && e.context.depth == dn(i, i.pos - 1) ? R4 : by);
  else if (i.next == 63)
    i.advance(), kr(i.next) && i.acceptToken(e.context.type == Uf && e.context.depth == dn(i, i.pos - 1) ? E4 : yy);
  else {
    let t = i.pos;
    for (; ; )
      if (Nf(i.next)) {
        if (i.pos == t) return;
        i.advance();
      } else if (i.next == 33)
        Cy(i);
      else if (i.next == 38)
        Yf(i);
      else if (i.next == 42) {
        Yf(i);
        break;
      } else if (i.next == 39 || i.next == 34) {
        if (yd(i, !0)) break;
        return;
      } else if (i.next == 91 || i.next == 123) {
        if (!G4(i)) return;
        break;
      } else {
        Qy(i, !0, !1, 0);
        break;
      }
    for (; Nf(i.next); ) i.advance();
    if (i.next == 58) {
      if (i.pos == t && e.canShift(W4)) return;
      let r = i.peek(1);
      kr(r) && i.acceptTokenTo(e.context.type == Uf && e.context.depth == dn(i, t) ? L4 : wy, t);
    }
  }
}, { contextual: !0 });
function H4(i) {
  return i > 32 && i < 127 && i != 34 && i != 37 && i != 44 && i != 60 && i != 62 && i != 92 && i != 94 && i != 96 && i != 123 && i != 124 && i != 125;
}
function um(i) {
  return i >= 48 && i <= 57 || i >= 97 && i <= 102 || i >= 65 && i <= 70;
}
function dm(i, e) {
  return i.next == 37 ? (i.advance(), um(i.next) && i.advance(), um(i.next) && i.advance(), !0) : H4(i.next) || e && i.next == 44 ? (i.advance(), !0) : !1;
}
function Cy(i) {
  if (i.advance(), i.next == 60) {
    for (i.advance(); ; )
      if (!dm(i, !0)) {
        i.next == 62 && i.advance();
        break;
      }
  } else
    for (; dm(i, !1); )
      ;
}
function Yf(i) {
  for (i.advance(); !kr(i.next) && vl(i.tag) != "f"; ) i.advance();
}
function yd(i, e) {
  let t = i.next, r = !1, s = i.pos;
  for (i.advance(); ; ) {
    let n = i.next;
    if (n < 0) break;
    if (i.advance(), n == t)
      if (n == 39)
        if (i.next == 39) i.advance();
        else break;
      else
        break;
    else if (n == 92 && t == 34)
      i.next >= 0 && i.advance();
    else if (zi(n)) {
      if (e) return !1;
      r = !0;
    } else if (e && i.pos >= s + 1024)
      return !1;
  }
  return !r;
}
function G4(i) {
  for (let e = [], t = i.pos + 1024; ; )
    if (i.next == 91 || i.next == 123)
      e.push(i.next), i.advance();
    else if (i.next == 39 || i.next == 34) {
      if (!yd(i, !0)) return !1;
    } else if (i.next == 93 || i.next == 125) {
      if (e[e.length - 1] != i.next - 2) return !1;
      if (e.pop(), i.advance(), !e.length) return !0;
    } else {
      if (i.next < 0 || i.pos > t || zi(i.next))
        return !1;
      i.advance();
    }
}
const K4 = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function vl(i) {
  return i < 33 ? "u" : i > 125 ? "s" : K4[i - 33];
}
function rh(i, e) {
  let t = vl(i);
  return t != "u" && !(e && t == "f");
}
function Qy(i, e, t, r) {
  if (vl(i.next) == "s" || (i.next == 63 || i.next == 58 || i.next == 45) && rh(i.peek(1), t))
    i.advance();
  else
    return !1;
  let s = i.pos;
  for (; ; ) {
    let n = i.next, o = 0, a = r + 1;
    for (; ky(n); ) {
      if (zi(n)) {
        if (e) return !1;
        a = 0;
      } else
        a++;
      n = i.peek(++o);
    }
    if (!(n >= 0 && (n == 58 ? rh(i.peek(o + 1), t) : n == 35 ? i.peek(o - 1) != 32 : rh(n, t))) || !t && a <= r || a == 0 && !t && (bs(i, 45, o) || bs(i, 46, o)))
      break;
    if (e && vl(n) == "f") return !1;
    for (let c = o; c >= 0; c--) i.advance();
    if (e && i.pos > s + 1024) return !1;
  }
  return !0;
}
const J4 = new Xe((i, e) => {
  if (i.next == 33)
    Cy(i), i.acceptToken(X4);
  else if (i.next == 38 || i.next == 42) {
    let t = i.next == 38 ? q4 : B4;
    Yf(i), i.acceptToken(t);
  } else i.next == 39 || i.next == 34 ? (yd(i, !1), i.acceptToken(D4)) : Qy(i, !1, e.context.type == Jn, e.context.depth) && i.acceptToken(M4);
}), eq = new Xe((i, e) => {
  let t = e.context.type == jf ? e.context.depth : -1, r = i.pos;
  e: for (; ; ) {
    let s = 0, n = i.next;
    for (; n == 32; ) n = i.peek(++s);
    if (!s && (bs(i, 45, s) || bs(i, 46, s)) || !zi(n) && (t < 0 && (t = Math.max(e.context.depth + 1, s)), s < t))
      break;
    for (; ; ) {
      if (i.next < 0) break e;
      let o = zi(i.next);
      if (i.advance(), o) continue e;
      r = i.pos;
    }
  }
  i.acceptTokenTo(xy, r);
}), tq = Jt({
  DirectiveName: C.keyword,
  DirectiveContent: C.attributeValue,
  "DirectiveEnd DocEnd": C.meta,
  QuotedLiteral: C.string,
  BlockLiteralHeader: C.special(C.string),
  BlockLiteralContent: C.content,
  Literal: C.content,
  "Key/Literal Key/QuotedLiteral": C.definition(C.propertyName),
  "Anchor Alias": C.labelName,
  Tag: C.typeName,
  Comment: C.lineComment,
  ": , -": C.separator,
  "?": C.punctuation,
  "[ ]": C.squareBracket,
  "{ }": C.brace
}), iq = Gt.deserialize({
  version: 14,
  states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
  stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
  goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
  nodeNames: "⚠ DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 74,
  context: N4,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 32, "{"],
    ["closedBy", 19, "]", 33, "}"]
  ],
  propSources: [tq],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [Y4, F4, J4, eq, 0, 1],
  topRules: { Stream: [0, 15] },
  tokenPrec: 0
}), rq = /* @__PURE__ */ Ht.define({
  name: "yaml",
  parser: /* @__PURE__ */ iq.configure({
    props: [
      /* @__PURE__ */ ki.add({
        Stream: (i) => {
          for (let e = i.node.resolve(i.pos, -1); e && e.to >= i.pos; e = e.parent) {
            if (e.name == "BlockLiteralContent" && e.from < e.to)
              return i.baseIndentFor(e);
            if (e.name == "BlockLiteral")
              return i.baseIndentFor(e) + i.unit;
            if (e.name == "BlockSequence" || e.name == "BlockMapping")
              return i.column(e.from, 1);
            if (e.name == "QuotedLiteral")
              return null;
            if (e.name == "Literal") {
              let t = i.column(e.from, 1);
              if (t == i.lineIndent(e.from, 1))
                return t;
              if (e.to > i.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: /* @__PURE__ */ ns({ closing: "}" }),
        FlowSequence: /* @__PURE__ */ ns({ closing: "]" })
      }),
      /* @__PURE__ */ ei.add({
        "FlowMapping FlowSequence": go,
        "Item Pair BlockLiteral": (i, e) => ({ from: e.doc.lineAt(i.from).to, to: i.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function sq() {
  return new bi(rq);
}
const Ff = 1, nq = 2, oq = 3, aq = 4, lq = 5, cq = 36, hq = 37, fq = 38, uq = 11, dq = 13;
function Oq(i) {
  return i == 45 || i == 46 || i == 58 || i >= 65 && i <= 90 || i == 95 || i >= 97 && i <= 122 || i >= 161;
}
function pq(i) {
  return i == 9 || i == 10 || i == 13 || i == 32;
}
let Om = null, pm = null, gm = 0;
function Hf(i, e) {
  let t = i.pos + e;
  if (pm == i && gm == t) return Om;
  for (; pq(i.peek(e)); ) e++;
  let r = "";
  for (; ; ) {
    let s = i.peek(e);
    if (!Oq(s)) break;
    r += String.fromCharCode(s), e++;
  }
  return pm = i, gm = t, Om = r || null;
}
function mm(i, e) {
  this.name = i, this.parent = e;
}
const gq = new bo({
  start: null,
  shift(i, e, t, r) {
    return e == Ff ? new mm(Hf(r, 1) || "", i) : i;
  },
  reduce(i, e) {
    return e == uq && i ? i.parent : i;
  },
  reuse(i, e, t, r) {
    let s = e.type.id;
    return s == Ff || s == dq ? new mm(Hf(r, 1) || "", i) : i;
  },
  strict: !1
}), mq = new Xe((i, e) => {
  if (i.next == 60) {
    if (i.advance(), i.next == 47) {
      i.advance();
      let t = Hf(i, 0);
      if (!t) return i.acceptToken(lq);
      if (e.context && t == e.context.name) return i.acceptToken(nq);
      for (let r = e.context; r; r = r.parent) if (r.name == t) return i.acceptToken(oq, -2);
      i.acceptToken(aq);
    } else if (i.next != 33 && i.next != 63)
      return i.acceptToken(Ff);
  }
}, { contextual: !0 });
function wd(i, e) {
  return new Xe((t) => {
    let r = 0, s = e.charCodeAt(0);
    e: for (; !(t.next < 0); t.advance(), r++)
      if (t.next == s) {
        for (let n = 1; n < e.length; n++)
          if (t.peek(n) != e.charCodeAt(n)) continue e;
        break;
      }
    r && t.acceptToken(i);
  });
}
const vq = wd(cq, "-->"), Sq = wd(hq, "?>"), _q = wd(fq, "]]>"), bq = Jt({
  Text: C.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": C.angleBracket,
  TagName: C.tagName,
  "MismatchedCloseTag/TagName": [C.tagName, C.invalid],
  AttributeName: C.attributeName,
  AttributeValue: C.attributeValue,
  Is: C.definitionOperator,
  "EntityReference CharacterReference": C.character,
  Comment: C.blockComment,
  ProcessingInst: C.processingInstruction,
  DoctypeDecl: C.documentMeta,
  Cdata: C.special(C.string)
}), yq = Gt.deserialize({
  version: 14,
  states: ",lOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DT'#DTOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C|'#C|O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C}'#C}O$dOrO,59^OOOP,59^,59^OOOS'#DO'#DOO$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6z-E6zOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6{-E6{OOOP1G.x1G.xOOOS-E6|-E6|OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'mO!bO,59eOOOO-E6w-E6wO'{OpO1G.uO'{OpO1G.uOOOP1G.u1G.uO(TOpO7+$fOOOP7+$f7+$fO(]O!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(hO#tO'#CnO(vO&jO'#CnOOOO1G.q1G.qO)UOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO)^O#tO,59YOOOO,59Y,59YOOOO'#C{'#C{O)lO&jO,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.tOOOO-E6y-E6y",
  stateData: ")z~OPQOSVOTWOVWOWWOXWOiXOyPO!QTO!SUO~OvZOx]O~O^`Oz^O~OPQOQcOSVOTWOVWOWWOXWOyPO!QTO!SUO~ORdO~P!SOteO!PgO~OuhO!RjO~O^lOz^O~OvZOxoO~O^qOz^O~O[vO`sOdwOz^O~ORyO~P!SO^{Oz^O~OteO!P}O~OuhO!R!PO~O^!QOz^O~O[!SOz^O~O[!VO`sOd!WOz^O~Oa!YOz^O~Oz^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oz^O~O[!_Oz^O~O[!aOz^O~O[!cO`sOd!dOz^O~O[!cO`sOd!dO~Oa!eOz^O~Oz^O{!gO}!hO~Oz^O[ma`madma~O[!kOz^O~O[!lOz^O~O[!mO`sOd!nO~OW!qOX!qO{!sO|!qO~OW!tOX!tO}!sO!O!tO~O[!vOz^O~OW!qOX!qO{!yO|!qO~OW!tOX!tO}!yO!O!tO~O",
  goto: "%cxPPPPPPPPPPyyP!PP!VPP!`!jP!pyyyP!v!|#S$[$k$q$w$}%TPPPP%ZXWORYbXRORYb_t`qru!T!U!bQ!i!YS!p!e!fR!w!oQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!j!oQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!j!]R!o!eQu`S!UqrU![u!U!bR!b!TQ!r!gR!x!rQ!u!hR!z!uQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "⚠ StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 50,
  context: gq,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"],
    ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]
  ],
  propSources: [bq],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!)v~R!YOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs*vsv$qvw+fwx/ix}$q}!O0[!O!P$q!P!Q2z!Q![$q![!]4n!]!^$q!^!_8U!_!`!#t!`!a!$l!a!b!%d!b!c$q!c!}4n!}#P$q#P#Q!'W#Q#R$q#R#S4n#S#T$q#T#o4n#o%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U$q4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qi$zXVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qa%nVVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%gP&YTVPOv&Tw!^&T!_;'S&T;'S;=`&i<%lO&TP&lP;=`<%l&T`&tS!O`Ov&ox;'S&o;'S;=`'Q<%lO&o`'TP;=`<%l&oa'ZP;=`<%l%gX'eWVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^W(ST|WOr'}sv'}w;'S'};'S;=`(c<%lO'}W(fP;=`<%l'}X(lP;=`<%l'^h(vV|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oh)`P;=`<%l(oi)fP;=`<%l$qo)t`VP|W!O`zUOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk+PV{YVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%g~+iast,n![!]-r!c!}-r#R#S-r#T#o-r%W%o-r%p&a-r&b1p-r4U4d-r4e$IS-r$I`$Ib-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~,qQ!Q![,w#l#m-V~,zQ!Q![,w!]!^-Q~-VOX~~-YR!Q![-c!c!i-c#T#Z-c~-fS!Q![-c!]!^-Q!c!i-c#T#Z-c~-ug}!O-r!O!P-r!Q![-r![!]-r!]!^/^!c!}-r#R#S-r#T#o-r$}%O-r%W%o-r%p&a-r&b1p-r1p4U-r4U4d-r4e$IS-r$I`$Ib-r$Je$Jg-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~/cOW~~/fP;=`<%l-rk/rW}bVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^k0eZVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O1W!O!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk1aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a2S!a;'S$q;'S;=`)c<%lO$qk2_X!PQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qm3TZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a3v!a;'S$q;'S;=`)c<%lO$qm4RXdSVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo4{!P`S^QVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O4n!O!P4n!P!Q$q!Q![4n![!]4n!]!^$q!^!_(o!_!c$q!c!}4n!}#R$q#R#S4n#S#T$q#T#o4n#o$}$q$}%O4n%O%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U4n4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Je$q$Je$Jg4n$Jg$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qo8RP;=`<%l4ni8]Y|W!O`Oq(oqr8{rs&osv(owx'}x!a(o!a!b!#U!b;'S(o;'S;=`)]<%lO(oi9S_|W!O`Or(ors&osv(owx'}x}(o}!O:R!O!f(o!f!g;e!g!}(o!}#ODh#O#W(o#W#XLp#X;'S(o;'S;=`)]<%lO(oi:YX|W!O`Or(ors&osv(owx'}x}(o}!O:u!O;'S(o;'S;=`)]<%lO(oi;OV!QP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oi;lX|W!O`Or(ors&osv(owx'}x!q(o!q!r<X!r;'S(o;'S;=`)]<%lO(oi<`X|W!O`Or(ors&osv(owx'}x!e(o!e!f<{!f;'S(o;'S;=`)]<%lO(oi=SX|W!O`Or(ors&osv(owx'}x!v(o!v!w=o!w;'S(o;'S;=`)]<%lO(oi=vX|W!O`Or(ors&osv(owx'}x!{(o!{!|>c!|;'S(o;'S;=`)]<%lO(oi>jX|W!O`Or(ors&osv(owx'}x!r(o!r!s?V!s;'S(o;'S;=`)]<%lO(oi?^X|W!O`Or(ors&osv(owx'}x!g(o!g!h?y!h;'S(o;'S;=`)]<%lO(oi@QY|W!O`Or?yrs@psv?yvwA[wxBdx!`?y!`!aCr!a;'S?y;'S;=`Db<%lO?ya@uV!O`Ov@pvxA[x!`@p!`!aAy!a;'S@p;'S;=`B^<%lO@pPA_TO!`A[!`!aAn!a;'SA[;'S;=`As<%lOA[PAsOiPPAvP;=`<%lA[aBQSiP!O`Ov&ox;'S&o;'S;=`'Q<%lO&oaBaP;=`<%l@pXBiX|WOrBdrsA[svBdvwA[w!`Bd!`!aCU!a;'SBd;'S;=`Cl<%lOBdXC]TiP|WOr'}sv'}w;'S'};'S;=`(c<%lO'}XCoP;=`<%lBdiC{ViP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiDeP;=`<%l?yiDoZ|W!O`Or(ors&osv(owx'}x!e(o!e!fEb!f#V(o#V#WIr#W;'S(o;'S;=`)]<%lO(oiEiX|W!O`Or(ors&osv(owx'}x!f(o!f!gFU!g;'S(o;'S;=`)]<%lO(oiF]X|W!O`Or(ors&osv(owx'}x!c(o!c!dFx!d;'S(o;'S;=`)]<%lO(oiGPX|W!O`Or(ors&osv(owx'}x!v(o!v!wGl!w;'S(o;'S;=`)]<%lO(oiGsX|W!O`Or(ors&osv(owx'}x!c(o!c!dH`!d;'S(o;'S;=`)]<%lO(oiHgX|W!O`Or(ors&osv(owx'}x!}(o!}#OIS#O;'S(o;'S;=`)]<%lO(oiI]V|W!O`yPOr(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiIyX|W!O`Or(ors&osv(owx'}x#W(o#W#XJf#X;'S(o;'S;=`)]<%lO(oiJmX|W!O`Or(ors&osv(owx'}x#T(o#T#UKY#U;'S(o;'S;=`)]<%lO(oiKaX|W!O`Or(ors&osv(owx'}x#h(o#h#iK|#i;'S(o;'S;=`)]<%lO(oiLTX|W!O`Or(ors&osv(owx'}x#T(o#T#UH`#U;'S(o;'S;=`)]<%lO(oiLwX|W!O`Or(ors&osv(owx'}x#c(o#c#dMd#d;'S(o;'S;=`)]<%lO(oiMkX|W!O`Or(ors&osv(owx'}x#V(o#V#WNW#W;'S(o;'S;=`)]<%lO(oiN_X|W!O`Or(ors&osv(owx'}x#h(o#h#iNz#i;'S(o;'S;=`)]<%lO(oi! RX|W!O`Or(ors&osv(owx'}x#m(o#m#n! n#n;'S(o;'S;=`)]<%lO(oi! uX|W!O`Or(ors&osv(owx'}x#d(o#d#e!!b#e;'S(o;'S;=`)]<%lO(oi!!iX|W!O`Or(ors&osv(owx'}x#X(o#X#Y?y#Y;'S(o;'S;=`)]<%lO(oi!#_V!SP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(ok!$PXaQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo!$wX[UVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!%mZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!&`!a;'S$q;'S;=`)c<%lO$qk!&kX!RQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!'aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_#P$q#P#Q!(S#Q;'S$q;'S;=`)c<%lO$qk!(]ZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!)O!a;'S$q;'S;=`)c<%lO$qk!)ZXxQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$q",
  tokenizers: [mq, vq, Sq, _q, 0, 1, 2, 3, 4],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function wa(i, e) {
  let t = e && e.getChild("TagName");
  return t ? i.sliceString(t.from, t.to) : "";
}
function sh(i, e) {
  let t = e && e.firstChild;
  return !t || t.name != "OpenTag" ? "" : wa(i, t);
}
function wq(i, e, t) {
  let r = e && e.getChildren("Attribute").find((n) => n.from <= t && n.to >= t), s = r && r.getChild("AttributeName");
  return s ? i.sliceString(s.from, s.to) : "";
}
function nh(i) {
  for (let e = i && i.parent; e; e = e.parent)
    if (e.name == "Element")
      return e;
  return null;
}
function xq(i, e) {
  var t;
  let r = ke(i).resolveInner(e, -1), s = null;
  for (let n = r; !s && n.parent; n = n.parent)
    (n.name == "OpenTag" || n.name == "CloseTag" || n.name == "SelfClosingTag" || n.name == "MismatchedCloseTag") && (s = n);
  if (s && (s.to > e || s.lastChild.type.isError)) {
    let n = s.parent;
    if (r.name == "TagName")
      return s.name == "CloseTag" || s.name == "MismatchedCloseTag" ? { type: "closeTag", from: r.from, context: n } : { type: "openTag", from: r.from, context: nh(n) };
    if (r.name == "AttributeName")
      return { type: "attrName", from: r.from, context: s };
    if (r.name == "AttributeValue")
      return { type: "attrValue", from: r.from, context: s };
    let o = r == s || r.name == "Attribute" ? r.childBefore(e) : r;
    return o?.name == "StartTag" ? { type: "openTag", from: e, context: nh(n) } : o?.name == "StartCloseTag" && o.to <= e ? { type: "closeTag", from: e, context: n } : o?.name == "Is" ? { type: "attrValue", from: e, context: s } : o ? { type: "attrName", from: e, context: s } : null;
  } else if (r.name == "StartCloseTag")
    return { type: "closeTag", from: e, context: r.parent };
  for (; r.parent && r.to == e && !(!((t = r.lastChild) === null || t === void 0) && t.type.isError); )
    r = r.parent;
  return r.name == "Element" || r.name == "Text" || r.name == "Document" ? { type: "tag", from: e, context: r.name == "Element" ? r : nh(r) } : null;
}
class kq {
  constructor(e, t, r) {
    this.attrs = t, this.attrValues = r, this.children = [], this.name = e.name, this.completion = Object.assign(Object.assign({ type: "type" }, e.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = e.textContent ? e.textContent.map((s) => ({ label: s, type: "text" })) : [];
  }
}
const oh = /^[:\-\.\w\u00b7-\uffff]*$/;
function vm(i) {
  return Object.assign(Object.assign({ type: "property" }, i.completion || {}), { label: i.name });
}
function Sm(i) {
  return typeof i == "string" ? { label: `"${i}"`, type: "constant" } : /^"/.test(i.label) ? i : Object.assign(Object.assign({}, i), { label: `"${i.label}"` });
}
function Cq(i, e) {
  let t = [], r = [], s = /* @__PURE__ */ Object.create(null);
  for (let l of e) {
    let c = vm(l);
    t.push(c), l.global && r.push(c), l.values && (s[l.name] = l.values.map(Sm));
  }
  let n = [], o = [], a = /* @__PURE__ */ Object.create(null);
  for (let l of i) {
    let c = r, h = s;
    l.attributes && (c = c.concat(l.attributes.map((u) => typeof u == "string" ? t.find((g) => g.label == u) || { label: u, type: "property" } : (u.values && (h == s && (h = Object.create(h)), h[u.name] = u.values.map(Sm)), vm(u)))));
    let f = new kq(l, c, h);
    a[f.name] = f, n.push(f), l.top && o.push(f);
  }
  o.length || (o = n);
  for (let l = 0; l < n.length; l++) {
    let c = i[l], h = n[l];
    if (c.children)
      for (let f of c.children)
        a[f] && h.children.push(a[f]);
    else
      h.children = n;
  }
  return (l) => {
    var c;
    let { doc: h } = l.state, f = xq(l.state, l.pos);
    if (!f || f.type == "tag" && !l.explicit)
      return null;
    let { type: u, from: g, context: S } = f;
    if (u == "openTag") {
      let v = o, d = sh(h, S);
      if (d) {
        let O = a[d];
        v = O?.children || n;
      }
      return {
        from: g,
        options: v.map((O) => O.completion),
        validFor: oh
      };
    } else if (u == "closeTag") {
      let v = sh(h, S);
      return v ? {
        from: g,
        to: l.pos + (h.sliceString(l.pos, l.pos + 1) == ">" ? 1 : 0),
        options: [((c = a[v]) === null || c === void 0 ? void 0 : c.closeNameCompletion) || { label: v + ">", type: "type" }],
        validFor: oh
      } : null;
    } else if (u == "attrName") {
      let v = a[wa(h, S)];
      return {
        from: g,
        options: v?.attrs || r,
        validFor: oh
      };
    } else if (u == "attrValue") {
      let v = wq(h, S, g);
      if (!v)
        return null;
      let d = a[wa(h, S)], O = (d?.attrValues || s)[v];
      return !O || !O.length ? null : {
        from: g,
        to: l.pos + (h.sliceString(l.pos, l.pos + 1) == '"' ? 1 : 0),
        options: O,
        validFor: /^"[^"]*"?$/
      };
    } else if (u == "tag") {
      let v = sh(h, S), d = a[v], O = [], p = S && S.lastChild;
      v && (!p || p.name != "CloseTag" || wa(h, p) != v) && O.push(d ? d.closeCompletion : { label: "</" + v + ">", type: "type", boost: 2 });
      let m = O.concat((d?.children || (S ? n : o)).map((_) => _.openCompletion));
      if (S && d?.text.length) {
        let _ = S.firstChild;
        _.to > l.pos - 20 && !/\S/.test(l.state.sliceDoc(_.to, l.pos)) && (m = m.concat(d.text));
      }
      return {
        from: g,
        options: m,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
const Gf = /* @__PURE__ */ Ht.define({
  name: "xml",
  parser: /* @__PURE__ */ yq.configure({
    props: [
      /* @__PURE__ */ ki.add({
        Element(i) {
          let e = /^\s*<\//.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        }
      }),
      /* @__PURE__ */ ei.add({
        Element(i) {
          let e = i.firstChild, t = i.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : i.to };
        }
      }),
      /* @__PURE__ */ Uu.add({
        "OpenTag CloseTag": (i) => i.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function Qq(i = {}) {
  let e = [Gf.data.of({
    autocomplete: Cq(i.elements || [], i.attributes || [])
  })];
  return i.autoCloseTags !== !1 && e.push(Pq), new bi(Gf, e);
}
function _m(i, e, t = i.length) {
  if (!e)
    return "";
  let r = e.firstChild, s = r && r.getChild("TagName");
  return s ? i.sliceString(s.from, Math.min(s.to, t)) : "";
}
const Pq = /* @__PURE__ */ K.inputHandler.of((i, e, t, r, s) => {
  if (i.composing || i.state.readOnly || e != t || r != ">" && r != "/" || !Gf.isActiveAt(i.state, e, -1))
    return !1;
  let n = s(), { state: o } = n, a = o.changeByRange((l) => {
    var c, h, f;
    let { head: u } = l, g = o.doc.sliceString(u - 1, u) == r, S = ke(o).resolveInner(u, -1), v;
    if (g && r == ">" && S.name == "EndTag") {
      let d = S.parent;
      if (((h = (c = d.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (v = _m(o.doc, d.parent, u))) {
        let O = u + (o.doc.sliceString(u, u + 1) === ">" ? 1 : 0), p = `</${v}>`;
        return { range: l, changes: { from: u, to: O, insert: p } };
      }
    } else if (g && r == "/" && S.name == "StartCloseTag") {
      let d = S.parent;
      if (S.from == u - 2 && ((f = d.lastChild) === null || f === void 0 ? void 0 : f.name) != "CloseTag" && (v = _m(o.doc, d, u))) {
        let O = u + (o.doc.sliceString(u, u + 1) === ">" ? 1 : 0), p = `${v}>`;
        return {
          range: V.cursor(u + p.length, -1),
          changes: { from: u, to: O, insert: p }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    n,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), $q = Jt({
  String: C.string,
  Number: C.number,
  "True False": C.bool,
  PropertyName: C.propertyName,
  Null: C.null,
  ", :": C.separator,
  "[ ]": C.squareBracket,
  "{ }": C.brace
}), Tq = Gt.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [$q],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), Rq = /* @__PURE__ */ Ht.define({
  name: "json",
  parser: /* @__PURE__ */ Tq.configure({
    props: [
      /* @__PURE__ */ ki.add({
        Object: /* @__PURE__ */ Pr({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ Pr({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ ei.add({
        "Object Array": go
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function Eq() {
  return new bi(Rq);
}
function Aq(i) {
  switch (i.split(".").pop()?.toLowerCase()) {
    case "js":
    case "ts":
    case "tsx":
    case "jsx":
    case "cjs":
    case "mjs":
    case "ejs":
    case "prisma":
      return nb();
    case "json":
      return Eq();
    case "html":
    case "hbs":
      return Kb();
    case "css":
      return zb();
    case "md":
      return yM();
    case "xml":
      return Qq();
    case "py":
      return P4();
    case "yml":
    case "yaml":
      return sq();
    case "sql":
      return uD();
    //case "hbs":
    //return handlebarsLanguage();
    default:
      return [];
  }
}
const Lq = K.theme(
  {
    "&": {
      backgroundColor: "#030712",
      height: "100%",
      color: "#f5f5f5"
    },
    ".cm-content": {
      caretColor: "#f4f4f5"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: "#f4f4f5"
    },
    "&.cm-focused .cm-selectionBackground, ::selection": {
      backgroundColor: "#3f3f46"
    },
    ".cm-gutters": {
      backgroundColor: "#030712",
      color: "#a3a3a3",
      border: "none"
    }
  },
  { dark: !0 }
), Mq = K.theme(
  {
    "&": {
      backgroundColor: "#ffffff",
      height: "100%",
      color: "#1f2937"
    },
    ".cm-content": {
      caretColor: "#111827"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: "#111827"
    },
    "&.cm-focused .cm-selectionBackground, ::selection": {
      backgroundColor: "#e5e7eb"
    },
    ".cm-gutters": {
      backgroundColor: "#f9fafb",
      color: "#9ca3af",
      border: "none"
    }
  },
  { dark: !1 }
), Dq = ks.define([
  { tag: C.keyword, color: "#22d3ee" },
  { tag: [C.name, C.deleted, C.character, C.propertyName], color: "#f87171" },
  { tag: [C.variableName], color: "#e4e4e7" },
  { tag: [C.string, C.meta], color: "#86efac" },
  { tag: [C.function(C.variableName)], color: "#c4b5fd" },
  { tag: [C.number], color: "#facc15" },
  { tag: [C.comment], color: "#71717a", fontStyle: "italic" }
]), qq = ks.define([
  { tag: C.keyword, color: "#0ea5e9" },
  { tag: [C.name, C.deleted, C.character, C.propertyName], color: "#b91c1c" },
  { tag: [C.variableName], color: "#374151" },
  { tag: [C.string, C.meta], color: "#16a34a" },
  { tag: [C.function(C.variableName)], color: "#7c3aed" },
  { tag: [C.number], color: "#ca8a04" },
  { tag: [C.comment], color: "#6b7280", fontStyle: "italic" }
]);
function bm(i) {
  return [
    i === "dark" ? Lq : Mq,
    VS(i === "dark" ? Dq : qq)
  ];
}
var Bq = /* @__PURE__ */ Y('<div class="bg-gray-950 h-screen flex flex-col overflow-auto relative"><div class="h-full w-full">');
const Xq = (i) => {
  let e, t = null;
  const r = R0(xn), [s, n] = ie(""), [o, a] = ie(!0), [l, c] = ie(!1), [h, f] = ie(""), [u, g] = ie(null), S = new lo(), v = (w) => {
    t && t.destroy();
    const x = _e.create({
      doc: w,
      extensions: [xA, Aq(i.filePath), S.of(bm(r())), K.lineWrapping, K.updateListener.of((y) => {
        y.docChanged && n(y.state.doc.toString());
      })]
    });
    t = new K({
      state: x,
      parent: e
    });
  };
  Tr(() => {
    t && t.dispatch({
      effects: S.reconfigure(bm(r()))
    });
  });
  const d = async () => {
    a(!0);
    try {
      const w = new FormData();
      w.append(i.param ?? "filePath", i.filePath);
      const y = (await Si.post("/file/read", w)).data?.content;
      if (!y) throw new Error("Failed to load file");
      n(y), v(y);
    } catch (w) {
      hc(w.message, "error"), f(w.message);
    } finally {
      a(!1);
    }
  }, O = async () => {
    c(!0);
    try {
      i.param;
      const w = new FormData();
      if (w.append("filePath", i.filePath), w.append("content", s()), !(await Si.post("/file/write", w)).data.success) throw new Error("Failed to save file");
      hc("File saved successfully.", "success");
    } catch (w) {
      hc(`Error saving file: ${w.message}`, "error");
    } finally {
      c(!1);
    }
  }, p = (w) => {
    e?.contains(w.target) && (w.preventDefault(), g({
      x: w.clientX,
      y: w.clientY
    }));
  }, m = () => g(null), _ = (w) => {
    (w.ctrlKey || w.metaKey) && w.key.toLowerCase() === "s" && (w.preventDefault(), O());
  };
  kt(() => {
    window.addEventListener("contextmenu", p), window.addEventListener("click", m), window.addEventListener("keydown", _), d();
  }), ft(() => {
    t?.destroy(), window.removeEventListener("contextmenu", p), window.removeEventListener("click", m), window.removeEventListener("keydown", _);
  });
  let b = "";
  return Tr(() => {
    i.filePath !== b && (b = i.filePath, d());
  }), (() => {
    var w = Bq(), x = w.firstChild, y = e;
    return typeof y == "function" ? mi(y, x) : e = x, w;
  })();
};
var Iq = /* @__PURE__ */ Y('<div class="flex min-h-0 min-w-0 flex-col overflow-hidden relative"><div class="sticky top-0 z-20 border-b border-gray-950 bg-white dark:bg-gray-800"><div class="flex items-center justify-between p-2"><button class="flex items-center gap-2 px-2 py-1 text-sm uppercase tracking-widest text-left dark:hover:text-yellow-500"> File Explorer</button><div class="flex items-center gap-2"><button class="cursor-pointer flex items-center gap-1 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700"title="Refresh files"></button></div></div></div><div class="transition-[max-height] duration-300 ease-in-out overflow-auto"><div class="pb-4 pt-2"> ');
const Zq = (i) => {
  const [e, t] = ie(null), [r, s] = ie(!0);
  let n;
  const o = () => {
    const a = n;
    a && (r() ? (a.style.maxHeight = `${a.scrollHeight}px`, requestAnimationFrame(() => {
      a.style.maxHeight = "0px", a.style.overflow = "hidden";
    })) : (a.style.maxHeight = "0px", a.style.overflow = "hidden", requestAnimationFrame(() => {
      a.style.maxHeight = `${a.scrollHeight}px`, setTimeout(() => {
        a && (a.style.maxHeight = "none", a.style.overflow = "visible");
      }, 300);
    })), s(!r()));
  };
  return kt(() => {
    r() && n && (n.style.maxHeight = "none");
  }), // Conditional flex style based on whether props.left is a signal or direct value
  (() => {
    var a = Iq(), l = a.firstChild, c = l.firstChild, h = c.firstChild, f = h.firstChild, u = h.nextSibling, g = u.firstChild, S = l.nextSibling, v = S.firstChild;
    v.firstChild, h.$$click = o, X(h, B(Ae, {
      icon: "mdi:file",
      width: "22",
      height: "22"
    }), f), g.$$click = () => {
      const O = e();
      O && O();
    }, X(g, B(Ae, {
      icon: "mdi:refresh",
      width: "18",
      height: "18"
    })), X(u, B(Ae, {
      get icon() {
        return r() ? "mdi:chevron-down" : "mdi:chevron-right";
      },
      width: "18",
      height: "18",
      class: "transition-transform duration-200 cursor-pointer",
      onClick: o
    }), null);
    var d = n;
    return typeof d == "function" ? mi(d, S) : n = S, X(v, B(DC, {
      get onFileSelect() {
        return i.loadFile;
      },
      refreshList: (O) => t(() => O)
    }), null), ce((O) => {
      var p = `flex: ${typeof i.left == "function" ? i.left() : i.left || 1}`, m = r() ? "max-height: none;" : "max-height: 0px;";
      return O.e = Sn(a, p, O.e), O.t = Sn(S, m, O.t), O;
    }, {
      e: void 0,
      t: void 0
    }), a;
  })();
};
He(["click"]);
const ym = (i, e) => {
  let t = !1, r, s;
  const n = (...a) => {
    s = a, !t && (t = !0, r = setTimeout(() => {
      i(...s), t = !1;
    }, e));
  }, o = () => {
    clearTimeout(r), t = !1;
  };
  return eo() && ft(o), Object.assign(n, { clear: o });
}, xa = window, cs = xa.navigator, On = cs.userAgent, wm = /* @__PURE__ */ /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(On);
xa.opr && xa.opr.addons || xa.opera;
cs.vendor && cs.vendor.includes("Apple") && On && !On.includes("CriOS") && On.includes("FxiOS");
cs.brave && cs.brave.isBrave && cs.brave.isBrave.name;
var Wq = /* @__PURE__ */ Y('<span class="h-1 w-1 rounded-full bg-gray-900 dark:bg-gray-300 dark:group-hover:bg-sky-200">'), zq = /* @__PURE__ */ Y('<div class="hover:bg-sky-500 dark:hover:bg-sky-600 flex items-center justify-center gap-2 border-gray-200 dark:border-gray-900"><div>');
const ah = (i) => (() => {
  var e = Wq();
  return ce((t) => vn(e, {
    "bg-sky-200": i.isDragging,
    "dark:bg-sky-200": i.isDragging
  }, t)), e;
})(), Vq = (i) => {
  const [e, t] = ie(!1), r = () => t(!0), s = () => t(!1), n = ym((l) => {
    i.onResize(l.clientX, l.clientY);
  }, 10), o = ym((l) => {
    const c = l.touches[0];
    i.onResize(c.clientX, c.clientY);
  }, 10), a = (l) => {
    i.ref(l), l.addEventListener("mousedown", r, {
      passive: !0
    }), l.addEventListener("touchstart", r, {
      passive: !0
    }), ft(() => {
      l.removeEventListener("mousedown", r), l.removeEventListener("touchstart", r);
    });
  };
  return Tr(() => {
    e() ? (wm && document.querySelectorAll("iframe").forEach((l) => l.style.pointerEvents = "none"), window.addEventListener("mousemove", n), window.addEventListener("mouseup", s), window.addEventListener("touchmove", o), window.addEventListener("touchend", s)) : (wm && document.querySelectorAll("iframe").forEach((l) => l.style.pointerEvents = ""), window.removeEventListener("mousemove", n), window.removeEventListener("mouseup", s), window.removeEventListener("touchmove", o), window.removeEventListener("touchend", s));
  }), (() => {
    var l = zq(), c = l.firstChild;
    return mi(a, l), X(l, B(ah, {
      get isDragging() {
        return e();
      }
    }), null), X(l, B(ah, {
      get isDragging() {
        return e();
      }
    }), null), X(l, B(ah, {
      get isDragging() {
        return e();
      }
    }), null), ce((h) => {
      var f = {
        "bg-brand-default dark:bg-brand-default": e(),
        "bg-gray-100 dark:bg-gray-950/50": !e(),
        "flex-col cursor-col-resize border-l-1 border-r-1 w-[12px]": !i.isHorizontal,
        "flex-row cursor-row-resize border-t-1 border-b-1 h-[12px]": i.isHorizontal
      }, u = {
        "fixed inset-0 z-10": e(),
        hidden: !e(),
        "cursor-col-resize": !i.isHorizontal,
        "cursor-row-resize": i.isHorizontal
      };
      return h.e = vn(l, f, h.e), h.t = vn(c, u, h.t), h;
    }, {
      e: void 0,
      t: void 0
    }), l;
  })();
};
var lh = { exports: {} }, xm;
function Uq() {
  return xm || (xm = 1, function(i, e) {
    (function(t, r) {
      i.exports = r();
    })(self, () => (() => {
      var t = { 4567: function(o, a, l) {
        var c = this && this.__decorate || function(m, _, b, w) {
          var x, y = arguments.length, k = y < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, b) : w;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(m, _, b, w);
          else for (var T = m.length - 1; T >= 0; T--) (x = m[T]) && (k = (y < 3 ? x(k) : y > 3 ? x(_, b, k) : x(_, b)) || k);
          return y > 3 && k && Object.defineProperty(_, b, k), k;
        }, h = this && this.__param || function(m, _) {
          return function(b, w) {
            _(b, w, m);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.AccessibilityManager = void 0;
        const f = l(9042), u = l(6114), g = l(9924), S = l(844), v = l(5596), d = l(4725), O = l(3656);
        let p = a.AccessibilityManager = class extends S.Disposable {
          constructor(m, _) {
            super(), this._terminal = m, this._renderService = _, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
            for (let b = 0; b < this._terminal.rows; b++) this._rowElements[b] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[b]);
            if (this._topBoundaryFocusListener = (b) => this._handleBoundaryFocus(b, 0), this._bottomBoundaryFocusListener = (b) => this._handleBoundaryFocus(b, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new g.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
            this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((b) => this._handleResize(b.rows))), this.register(this._terminal.onRender((b) => this._refreshRows(b.start, b.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((b) => this._handleChar(b))), this.register(this._terminal.onLineFeed(() => this._handleChar(`
`))), this.register(this._terminal.onA11yTab((b) => this._handleTab(b))), this.register(this._terminal.onKey((b) => this._handleKey(b.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new v.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, O.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, S.toDisposable)(() => {
              this._accessibilityContainer.remove(), this._rowElements.length = 0;
            }));
          }
          _handleTab(m) {
            for (let _ = 0; _ < m; _++) this._handleChar(" ");
          }
          _handleChar(m) {
            this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== m && (this._charsToAnnounce += m) : this._charsToAnnounce += m, m === `
` && (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += f.tooMuchOutput)), u.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
              this._accessibilityContainer.appendChild(this._liveRegion);
            }, 0));
          }
          _clearLiveRegion() {
            this._liveRegion.textContent = "", this._liveRegionLineCount = 0, u.isMac && this._liveRegion.remove();
          }
          _handleKey(m) {
            this._clearLiveRegion(), /\p{Control}/u.test(m) || this._charsToConsume.push(m);
          }
          _refreshRows(m, _) {
            this._liveRegionDebouncer.refresh(m, _, this._terminal.rows);
          }
          _renderRows(m, _) {
            const b = this._terminal.buffer, w = b.lines.length.toString();
            for (let x = m; x <= _; x++) {
              const y = b.translateBufferLineToString(b.ydisp + x, !0), k = (b.ydisp + x + 1).toString(), T = this._rowElements[x];
              T && (y.length === 0 ? T.innerText = " " : T.textContent = y, T.setAttribute("aria-posinset", k), T.setAttribute("aria-setsize", w));
            }
            this._announceCharacters();
          }
          _announceCharacters() {
            this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
          }
          _handleBoundaryFocus(m, _) {
            const b = m.target, w = this._rowElements[_ === 0 ? 1 : this._rowElements.length - 2];
            if (b.getAttribute("aria-posinset") === (_ === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || m.relatedTarget !== w) return;
            let x, y;
            if (_ === 0 ? (x = b, y = this._rowElements.pop(), this._rowContainer.removeChild(y)) : (x = this._rowElements.shift(), y = b, this._rowContainer.removeChild(x)), x.removeEventListener("focus", this._topBoundaryFocusListener), y.removeEventListener("focus", this._bottomBoundaryFocusListener), _ === 0) {
              const k = this._createAccessibilityTreeNode();
              this._rowElements.unshift(k), this._rowContainer.insertAdjacentElement("afterbegin", k);
            } else {
              const k = this._createAccessibilityTreeNode();
              this._rowElements.push(k), this._rowContainer.appendChild(k);
            }
            this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(_ === 0 ? -1 : 1), this._rowElements[_ === 0 ? 1 : this._rowElements.length - 2].focus(), m.preventDefault(), m.stopImmediatePropagation();
          }
          _handleResize(m) {
            this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
            for (let _ = this._rowContainer.children.length; _ < this._terminal.rows; _++) this._rowElements[_] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[_]);
            for (; this._rowElements.length > m; ) this._rowContainer.removeChild(this._rowElements.pop());
            this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
          }
          _createAccessibilityTreeNode() {
            const m = document.createElement("div");
            return m.setAttribute("role", "listitem"), m.tabIndex = -1, this._refreshRowDimensions(m), m;
          }
          _refreshRowsDimensions() {
            if (this._renderService.dimensions.css.cell.height) {
              this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
              for (let m = 0; m < this._terminal.rows; m++) this._refreshRowDimensions(this._rowElements[m]);
            }
          }
          _refreshRowDimensions(m) {
            m.style.height = `${this._renderService.dimensions.css.cell.height}px`;
          }
        };
        a.AccessibilityManager = p = c([h(1, d.IRenderService)], p);
      }, 3614: (o, a) => {
        function l(u) {
          return u.replace(/\r?\n/g, "\r");
        }
        function c(u, g) {
          return g ? "\x1B[200~" + u + "\x1B[201~" : u;
        }
        function h(u, g, S, v) {
          u = c(u = l(u), S.decPrivateModes.bracketedPasteMode && v.rawOptions.ignoreBracketedPasteMode !== !0), S.triggerDataEvent(u, !0), g.value = "";
        }
        function f(u, g, S) {
          const v = S.getBoundingClientRect(), d = u.clientX - v.left - 10, O = u.clientY - v.top - 10;
          g.style.width = "20px", g.style.height = "20px", g.style.left = `${d}px`, g.style.top = `${O}px`, g.style.zIndex = "1000", g.focus();
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.rightClickHandler = a.moveTextAreaUnderMouseCursor = a.paste = a.handlePasteEvent = a.copyHandler = a.bracketTextForPaste = a.prepareTextForTerminal = void 0, a.prepareTextForTerminal = l, a.bracketTextForPaste = c, a.copyHandler = function(u, g) {
          u.clipboardData && u.clipboardData.setData("text/plain", g.selectionText), u.preventDefault();
        }, a.handlePasteEvent = function(u, g, S, v) {
          u.stopPropagation(), u.clipboardData && h(u.clipboardData.getData("text/plain"), g, S, v);
        }, a.paste = h, a.moveTextAreaUnderMouseCursor = f, a.rightClickHandler = function(u, g, S, v, d) {
          f(u, g, S), d && v.rightClickSelect(u), g.value = v.selectionText, g.select();
        };
      }, 7239: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorContrastCache = void 0;
        const c = l(1505);
        a.ColorContrastCache = class {
          constructor() {
            this._color = new c.TwoKeyMap(), this._css = new c.TwoKeyMap();
          }
          setCss(h, f, u) {
            this._css.set(h, f, u);
          }
          getCss(h, f) {
            return this._css.get(h, f);
          }
          setColor(h, f, u) {
            this._color.set(h, f, u);
          }
          getColor(h, f) {
            return this._color.get(h, f);
          }
          clear() {
            this._color.clear(), this._css.clear();
          }
        };
      }, 3656: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.addDisposableDomListener = void 0, a.addDisposableDomListener = function(l, c, h, f) {
          l.addEventListener(c, h, f);
          let u = !1;
          return { dispose: () => {
            u || (u = !0, l.removeEventListener(c, h, f));
          } };
        };
      }, 6465: function(o, a, l) {
        var c = this && this.__decorate || function(d, O, p, m) {
          var _, b = arguments.length, w = b < 3 ? O : m === null ? m = Object.getOwnPropertyDescriptor(O, p) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(d, O, p, m);
          else for (var x = d.length - 1; x >= 0; x--) (_ = d[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(O, p, w) : _(O, p)) || w);
          return b > 3 && w && Object.defineProperty(O, p, w), w;
        }, h = this && this.__param || function(d, O) {
          return function(p, m) {
            O(p, m, d);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Linkifier2 = void 0;
        const f = l(3656), u = l(8460), g = l(844), S = l(2585);
        let v = a.Linkifier2 = class extends g.Disposable {
          get currentLink() {
            return this._currentLink;
          }
          constructor(d) {
            super(), this._bufferService = d, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = !0, this._wasResized = !1, this._activeLine = -1, this._onShowLinkUnderline = this.register(new u.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new u.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, g.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, g.toDisposable)(() => {
              this._lastMouseEvent = void 0;
            })), this.register(this._bufferService.onResize(() => {
              this._clearCurrentLink(), this._wasResized = !0;
            }));
          }
          registerLinkProvider(d) {
            return this._linkProviders.push(d), { dispose: () => {
              const O = this._linkProviders.indexOf(d);
              O !== -1 && this._linkProviders.splice(O, 1);
            } };
          }
          attachToDom(d, O, p) {
            this._element = d, this._mouseService = O, this._renderService = p, this.register((0, f.addDisposableDomListener)(this._element, "mouseleave", () => {
              this._isMouseOut = !0, this._clearCurrentLink();
            })), this.register((0, f.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, f.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, f.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
          }
          _handleMouseMove(d) {
            if (this._lastMouseEvent = d, !this._element || !this._mouseService) return;
            const O = this._positionFromMouseEvent(d, this._element, this._mouseService);
            if (!O) return;
            this._isMouseOut = !1;
            const p = d.composedPath();
            for (let m = 0; m < p.length; m++) {
              const _ = p[m];
              if (_.classList.contains("xterm")) break;
              if (_.classList.contains("xterm-hover")) return;
            }
            this._lastBufferCell && O.x === this._lastBufferCell.x && O.y === this._lastBufferCell.y || (this._handleHover(O), this._lastBufferCell = O);
          }
          _handleHover(d) {
            if (this._activeLine !== d.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(d, !1), void (this._wasResized = !1);
            this._currentLink && this._linkAtPosition(this._currentLink.link, d) || (this._clearCurrentLink(), this._askForLink(d, !0));
          }
          _askForLink(d, O) {
            var p, m;
            this._activeProviderReplies && O || ((p = this._activeProviderReplies) === null || p === void 0 || p.forEach((b) => {
              b?.forEach((w) => {
                w.link.dispose && w.link.dispose();
              });
            }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = d.y);
            let _ = !1;
            for (const [b, w] of this._linkProviders.entries()) O ? !((m = this._activeProviderReplies) === null || m === void 0) && m.get(b) && (_ = this._checkLinkProviderResult(b, d, _)) : w.provideLinks(d.y, (x) => {
              var y, k;
              if (this._isMouseOut) return;
              const T = x?.map((R) => ({ link: R }));
              (y = this._activeProviderReplies) === null || y === void 0 || y.set(b, T), _ = this._checkLinkProviderResult(b, d, _), ((k = this._activeProviderReplies) === null || k === void 0 ? void 0 : k.size) === this._linkProviders.length && this._removeIntersectingLinks(d.y, this._activeProviderReplies);
            });
          }
          _removeIntersectingLinks(d, O) {
            const p = /* @__PURE__ */ new Set();
            for (let m = 0; m < O.size; m++) {
              const _ = O.get(m);
              if (_) for (let b = 0; b < _.length; b++) {
                const w = _[b], x = w.link.range.start.y < d ? 0 : w.link.range.start.x, y = w.link.range.end.y > d ? this._bufferService.cols : w.link.range.end.x;
                for (let k = x; k <= y; k++) {
                  if (p.has(k)) {
                    _.splice(b--, 1);
                    break;
                  }
                  p.add(k);
                }
              }
            }
          }
          _checkLinkProviderResult(d, O, p) {
            var m;
            if (!this._activeProviderReplies) return p;
            const _ = this._activeProviderReplies.get(d);
            let b = !1;
            for (let w = 0; w < d; w++) this._activeProviderReplies.has(w) && !this._activeProviderReplies.get(w) || (b = !0);
            if (!b && _) {
              const w = _.find((x) => this._linkAtPosition(x.link, O));
              w && (p = !0, this._handleNewLink(w));
            }
            if (this._activeProviderReplies.size === this._linkProviders.length && !p) for (let w = 0; w < this._activeProviderReplies.size; w++) {
              const x = (m = this._activeProviderReplies.get(w)) === null || m === void 0 ? void 0 : m.find((y) => this._linkAtPosition(y.link, O));
              if (x) {
                p = !0, this._handleNewLink(x);
                break;
              }
            }
            return p;
          }
          _handleMouseDown() {
            this._mouseDownLink = this._currentLink;
          }
          _handleMouseUp(d) {
            if (!this._element || !this._mouseService || !this._currentLink) return;
            const O = this._positionFromMouseEvent(d, this._element, this._mouseService);
            O && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, O) && this._currentLink.link.activate(d, this._currentLink.link.text);
          }
          _clearCurrentLink(d, O) {
            this._element && this._currentLink && this._lastMouseEvent && (!d || !O || this._currentLink.link.range.start.y >= d && this._currentLink.link.range.end.y <= O) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, g.disposeArray)(this._linkCacheDisposables));
          }
          _handleNewLink(d) {
            if (!this._element || !this._lastMouseEvent || !this._mouseService) return;
            const O = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
            O && this._linkAtPosition(d.link, O) && (this._currentLink = d, this._currentLink.state = { decorations: { underline: d.link.decorations === void 0 || d.link.decorations.underline, pointerCursor: d.link.decorations === void 0 || d.link.decorations.pointerCursor }, isHovered: !0 }, this._linkHover(this._element, d.link, this._lastMouseEvent), d.link.decorations = {}, Object.defineProperties(d.link.decorations, { pointerCursor: { get: () => {
              var p, m;
              return (m = (p = this._currentLink) === null || p === void 0 ? void 0 : p.state) === null || m === void 0 ? void 0 : m.decorations.pointerCursor;
            }, set: (p) => {
              var m, _;
              !((m = this._currentLink) === null || m === void 0) && m.state && this._currentLink.state.decorations.pointerCursor !== p && (this._currentLink.state.decorations.pointerCursor = p, this._currentLink.state.isHovered && ((_ = this._element) === null || _ === void 0 || _.classList.toggle("xterm-cursor-pointer", p)));
            } }, underline: { get: () => {
              var p, m;
              return (m = (p = this._currentLink) === null || p === void 0 ? void 0 : p.state) === null || m === void 0 ? void 0 : m.decorations.underline;
            }, set: (p) => {
              var m, _, b;
              !((m = this._currentLink) === null || m === void 0) && m.state && ((b = (_ = this._currentLink) === null || _ === void 0 ? void 0 : _.state) === null || b === void 0 ? void 0 : b.decorations.underline) !== p && (this._currentLink.state.decorations.underline = p, this._currentLink.state.isHovered && this._fireUnderlineEvent(d.link, p));
            } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((p) => {
              if (!this._currentLink) return;
              const m = p.start === 0 ? 0 : p.start + 1 + this._bufferService.buffer.ydisp, _ = this._bufferService.buffer.ydisp + 1 + p.end;
              if (this._currentLink.link.range.start.y >= m && this._currentLink.link.range.end.y <= _ && (this._clearCurrentLink(m, _), this._lastMouseEvent && this._element)) {
                const b = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                b && this._askForLink(b, !1);
              }
            })));
          }
          _linkHover(d, O, p) {
            var m;
            !((m = this._currentLink) === null || m === void 0) && m.state && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(O, !0), this._currentLink.state.decorations.pointerCursor && d.classList.add("xterm-cursor-pointer")), O.hover && O.hover(p, O.text);
          }
          _fireUnderlineEvent(d, O) {
            const p = d.range, m = this._bufferService.buffer.ydisp, _ = this._createLinkUnderlineEvent(p.start.x - 1, p.start.y - m - 1, p.end.x, p.end.y - m - 1, void 0);
            (O ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(_);
          }
          _linkLeave(d, O, p) {
            var m;
            !((m = this._currentLink) === null || m === void 0) && m.state && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(O, !1), this._currentLink.state.decorations.pointerCursor && d.classList.remove("xterm-cursor-pointer")), O.leave && O.leave(p, O.text);
          }
          _linkAtPosition(d, O) {
            const p = d.range.start.y * this._bufferService.cols + d.range.start.x, m = d.range.end.y * this._bufferService.cols + d.range.end.x, _ = O.y * this._bufferService.cols + O.x;
            return p <= _ && _ <= m;
          }
          _positionFromMouseEvent(d, O, p) {
            const m = p.getCoords(d, O, this._bufferService.cols, this._bufferService.rows);
            if (m) return { x: m[0], y: m[1] + this._bufferService.buffer.ydisp };
          }
          _createLinkUnderlineEvent(d, O, p, m, _) {
            return { x1: d, y1: O, x2: p, y2: m, cols: this._bufferService.cols, fg: _ };
          }
        };
        a.Linkifier2 = v = c([h(0, S.IBufferService)], v);
      }, 9042: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.tooMuchOutput = a.promptLabel = void 0, a.promptLabel = "Terminal input", a.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
      }, 3730: function(o, a, l) {
        var c = this && this.__decorate || function(v, d, O, p) {
          var m, _ = arguments.length, b = _ < 3 ? d : p === null ? p = Object.getOwnPropertyDescriptor(d, O) : p;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") b = Reflect.decorate(v, d, O, p);
          else for (var w = v.length - 1; w >= 0; w--) (m = v[w]) && (b = (_ < 3 ? m(b) : _ > 3 ? m(d, O, b) : m(d, O)) || b);
          return _ > 3 && b && Object.defineProperty(d, O, b), b;
        }, h = this && this.__param || function(v, d) {
          return function(O, p) {
            d(O, p, v);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkProvider = void 0;
        const f = l(511), u = l(2585);
        let g = a.OscLinkProvider = class {
          constructor(v, d, O) {
            this._bufferService = v, this._optionsService = d, this._oscLinkService = O;
          }
          provideLinks(v, d) {
            var O;
            const p = this._bufferService.buffer.lines.get(v - 1);
            if (!p) return void d(void 0);
            const m = [], _ = this._optionsService.rawOptions.linkHandler, b = new f.CellData(), w = p.getTrimmedLength();
            let x = -1, y = -1, k = !1;
            for (let T = 0; T < w; T++) if (y !== -1 || p.hasContent(T)) {
              if (p.loadCell(T, b), b.hasExtendedAttrs() && b.extended.urlId) {
                if (y === -1) {
                  y = T, x = b.extended.urlId;
                  continue;
                }
                k = b.extended.urlId !== x;
              } else y !== -1 && (k = !0);
              if (k || y !== -1 && T === w - 1) {
                const R = (O = this._oscLinkService.getLinkData(x)) === null || O === void 0 ? void 0 : O.uri;
                if (R) {
                  const $ = { start: { x: y + 1, y: v }, end: { x: T + (k || T !== w - 1 ? 0 : 1), y: v } };
                  let E = !1;
                  if (!_?.allowNonHttpProtocols) try {
                    const D = new URL(R);
                    ["http:", "https:"].includes(D.protocol) || (E = !0);
                  } catch {
                    E = !0;
                  }
                  E || m.push({ text: R, range: $, activate: (D, q) => _ ? _.activate(D, q, $) : S(0, q), hover: (D, q) => {
                    var W;
                    return (W = _?.hover) === null || W === void 0 ? void 0 : W.call(_, D, q, $);
                  }, leave: (D, q) => {
                    var W;
                    return (W = _?.leave) === null || W === void 0 ? void 0 : W.call(_, D, q, $);
                  } });
                }
                k = !1, b.hasExtendedAttrs() && b.extended.urlId ? (y = T, x = b.extended.urlId) : (y = -1, x = -1);
              }
            }
            d(m);
          }
        };
        function S(v, d) {
          if (confirm(`Do you want to navigate to ${d}?

WARNING: This link could potentially be dangerous`)) {
            const O = window.open();
            if (O) {
              try {
                O.opener = null;
              } catch {
              }
              O.location.href = d;
            } else console.warn("Opening link blocked as opener could not be cleared");
          }
        }
        a.OscLinkProvider = g = c([h(0, u.IBufferService), h(1, u.IOptionsService), h(2, u.IOscLinkService)], g);
      }, 6193: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderDebouncer = void 0, a.RenderDebouncer = class {
          constructor(l, c) {
            this._parentWindow = l, this._renderCallback = c, this._refreshCallbacks = [];
          }
          dispose() {
            this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
          }
          addRefreshCallback(l) {
            return this._refreshCallbacks.push(l), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
          }
          refresh(l, c, h) {
            this._rowCount = h, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._animationFrame = void 0, this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return void this._runRefreshCallbacks();
            const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c), this._runRefreshCallbacks();
          }
          _runRefreshCallbacks() {
            for (const l of this._refreshCallbacks) l(0);
            this._refreshCallbacks = [];
          }
        };
      }, 5596: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ScreenDprMonitor = void 0;
        const c = l(844);
        class h extends c.Disposable {
          constructor(u) {
            super(), this._parentWindow = u, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, c.toDisposable)(() => {
              this.clearListener();
            }));
          }
          setListener(u) {
            this._listener && this.clearListener(), this._listener = u, this._outerListener = () => {
              this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
            }, this._updateDpr();
          }
          _updateDpr() {
            var u;
            this._outerListener && ((u = this._resolutionMediaMatchList) === null || u === void 0 || u.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
          }
          clearListener() {
            this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
          }
        }
        a.ScreenDprMonitor = h;
      }, 3236: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Terminal = void 0;
        const c = l(3614), h = l(3656), f = l(6465), u = l(9042), g = l(3730), S = l(1680), v = l(3107), d = l(5744), O = l(2950), p = l(1296), m = l(428), _ = l(4269), b = l(5114), w = l(8934), x = l(3230), y = l(9312), k = l(4725), T = l(6731), R = l(8055), $ = l(8969), E = l(8460), D = l(844), q = l(6114), W = l(8437), z = l(2584), Q = l(7399), A = l(5941), L = l(9074), M = l(2585), U = l(5435), F = l(4567), ne = typeof window < "u" ? window.document : null;
        class te extends $.CoreTerminal {
          get onFocus() {
            return this._onFocus.event;
          }
          get onBlur() {
            return this._onBlur.event;
          }
          get onA11yChar() {
            return this._onA11yCharEmitter.event;
          }
          get onA11yTab() {
            return this._onA11yTabEmitter.event;
          }
          get onWillOpen() {
            return this._onWillOpen.event;
          }
          constructor(P = {}) {
            super(P), this.browser = q, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._accessibilityManager = this.register(new D.MutableDisposable()), this._onCursorMove = this.register(new E.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new E.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new E.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new E.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new E.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new E.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new E.EventEmitter()), this._onBlur = this.register(new E.EventEmitter()), this._onA11yCharEmitter = this.register(new E.EventEmitter()), this._onA11yTabEmitter = this.register(new E.EventEmitter()), this._onWillOpen = this.register(new E.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(f.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(g.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(L.DecorationService), this._instantiationService.setService(M.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((I, N) => this.refresh(I, N))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((I) => this._reportWindowsOptions(I))), this.register(this._inputHandler.onColor((I) => this._handleColorEvent(I))), this.register((0, E.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, E.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, E.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, E.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((I) => this._afterResize(I.cols, I.rows))), this.register((0, D.toDisposable)(() => {
              var I, N;
              this._customKeyEventHandler = void 0, (N = (I = this.element) === null || I === void 0 ? void 0 : I.parentNode) === null || N === void 0 || N.removeChild(this.element);
            }));
          }
          _handleColorEvent(P) {
            if (this._themeService) for (const I of P) {
              let N, j = "";
              switch (I.index) {
                case 256:
                  N = "foreground", j = "10";
                  break;
                case 257:
                  N = "background", j = "11";
                  break;
                case 258:
                  N = "cursor", j = "12";
                  break;
                default:
                  N = "ansi", j = "4;" + I.index;
              }
              switch (I.type) {
                case 0:
                  const ue = R.color.toColorRGB(N === "ansi" ? this._themeService.colors.ansi[I.index] : this._themeService.colors[N]);
                  this.coreService.triggerDataEvent(`${z.C0.ESC}]${j};${(0, A.toRgbString)(ue)}${z.C1_ESCAPED.ST}`);
                  break;
                case 1:
                  if (N === "ansi") this._themeService.modifyColors((se) => se.ansi[I.index] = R.rgba.toColor(...I.color));
                  else {
                    const se = N;
                    this._themeService.modifyColors((Ce) => Ce[se] = R.rgba.toColor(...I.color));
                  }
                  break;
                case 2:
                  this._themeService.restoreColor(I.index);
              }
            }
          }
          _setup() {
            super._setup(), this._customKeyEventHandler = void 0;
          }
          get buffer() {
            return this.buffers.active;
          }
          focus() {
            this.textarea && this.textarea.focus({ preventScroll: !0 });
          }
          _handleScreenReaderModeOptionChange(P) {
            P ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(F.AccessibilityManager, this)) : this._accessibilityManager.clear();
          }
          _handleTextAreaFocus(P) {
            this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(z.C0.ESC + "[I"), this.updateCursorStyle(P), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
          }
          blur() {
            var P;
            return (P = this.textarea) === null || P === void 0 ? void 0 : P.blur();
          }
          _handleTextAreaBlur() {
            this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(z.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
          }
          _syncTextArea() {
            if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
            const P = this.buffer.ybase + this.buffer.y, I = this.buffer.lines.get(P);
            if (!I) return;
            const N = Math.min(this.buffer.x, this.cols - 1), j = this._renderService.dimensions.css.cell.height, ue = I.getWidth(N), se = this._renderService.dimensions.css.cell.width * ue, Ce = this.buffer.y * this._renderService.dimensions.css.cell.height, Ke = N * this._renderService.dimensions.css.cell.width;
            this.textarea.style.left = Ke + "px", this.textarea.style.top = Ce + "px", this.textarea.style.width = se + "px", this.textarea.style.height = j + "px", this.textarea.style.lineHeight = j + "px", this.textarea.style.zIndex = "-5";
          }
          _initGlobal() {
            this._bindKeys(), this.register((0, h.addDisposableDomListener)(this.element, "copy", (I) => {
              this.hasSelection() && (0, c.copyHandler)(I, this._selectionService);
            }));
            const P = (I) => (0, c.handlePasteEvent)(I, this.textarea, this.coreService, this.optionsService);
            this.register((0, h.addDisposableDomListener)(this.textarea, "paste", P)), this.register((0, h.addDisposableDomListener)(this.element, "paste", P)), q.isFirefox ? this.register((0, h.addDisposableDomListener)(this.element, "mousedown", (I) => {
              I.button === 2 && (0, c.rightClickHandler)(I, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })) : this.register((0, h.addDisposableDomListener)(this.element, "contextmenu", (I) => {
              (0, c.rightClickHandler)(I, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })), q.isLinux && this.register((0, h.addDisposableDomListener)(this.element, "auxclick", (I) => {
              I.button === 1 && (0, c.moveTextAreaUnderMouseCursor)(I, this.textarea, this.screenElement);
            }));
          }
          _bindKeys() {
            this.register((0, h.addDisposableDomListener)(this.textarea, "keyup", (P) => this._keyUp(P), !0)), this.register((0, h.addDisposableDomListener)(this.textarea, "keydown", (P) => this._keyDown(P), !0)), this.register((0, h.addDisposableDomListener)(this.textarea, "keypress", (P) => this._keyPress(P), !0)), this.register((0, h.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, h.addDisposableDomListener)(this.textarea, "compositionupdate", (P) => this._compositionHelper.compositionupdate(P))), this.register((0, h.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, h.addDisposableDomListener)(this.textarea, "input", (P) => this._inputEvent(P), !0)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
          }
          open(P) {
            var I;
            if (!P) throw new Error("Terminal requires a parent element.");
            P.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = P.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), P.appendChild(this.element);
            const N = ne.createDocumentFragment();
            this._viewportElement = ne.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), N.appendChild(this._viewportElement), this._viewportScrollArea = ne.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = ne.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = ne.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), N.appendChild(this.screenElement), this.textarea = ne.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", u.promptLabel), q.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(b.CoreBrowserService, this.textarea, (I = this._document.defaultView) !== null && I !== void 0 ? I : window), this._instantiationService.setService(k.ICoreBrowserService, this._coreBrowserService), this.register((0, h.addDisposableDomListener)(this.textarea, "focus", (j) => this._handleTextAreaFocus(j))), this.register((0, h.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(m.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(k.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(T.ThemeService), this._instantiationService.setService(k.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(_.CharacterJoinerService), this._instantiationService.setService(k.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(x.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(k.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((j) => this._onRender.fire(j))), this.onResize((j) => this._renderService.resize(j.cols, j.rows)), this._compositionView = ne.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(O.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(N);
            try {
              this._onWillOpen.fire(this.element);
            } catch {
            }
            this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(w.MouseService), this._instantiationService.setService(k.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(S.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((j) => this.scrollLines(j.amount, j.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
              this._renderService.handleCursorMove(), this._syncTextArea();
            })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(y.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(k.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((j) => this.scrollLines(j.amount, j.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((j) => this._renderService.handleSelectionChanged(j.start, j.end, j.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((j) => {
              this.textarea.value = j, this.textarea.focus(), this.textarea.select();
            })), this.register(this._onScroll.event((j) => {
              this.viewport.syncScrollArea(), this._selectionService.refresh();
            })), this.register((0, h.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(v.BufferDecorationRenderer, this.screenElement)), this.register((0, h.addDisposableDomListener)(this.element, "mousedown", (j) => this._selectionService.handleMouseDown(j))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(F.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (j) => this._handleScreenReaderModeOptionChange(j))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(d.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (j) => {
              !this._overviewRulerRenderer && j && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(d.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
            }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
          }
          _createRenderer() {
            return this._instantiationService.createInstance(p.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
          }
          bindMouse() {
            const P = this, I = this.element;
            function N(se) {
              const Ce = P._mouseService.getMouseReportCoords(se, P.screenElement);
              if (!Ce) return !1;
              let Ke, gt;
              switch (se.overrideType || se.type) {
                case "mousemove":
                  gt = 32, se.buttons === void 0 ? (Ke = 3, se.button !== void 0 && (Ke = se.button < 3 ? se.button : 3)) : Ke = 1 & se.buttons ? 0 : 4 & se.buttons ? 1 : 2 & se.buttons ? 2 : 3;
                  break;
                case "mouseup":
                  gt = 0, Ke = se.button < 3 ? se.button : 3;
                  break;
                case "mousedown":
                  gt = 1, Ke = se.button < 3 ? se.button : 3;
                  break;
                case "wheel":
                  if (P.viewport.getLinesScrolled(se) === 0) return !1;
                  gt = se.deltaY < 0 ? 0 : 1, Ke = 4;
                  break;
                default:
                  return !1;
              }
              return !(gt === void 0 || Ke === void 0 || Ke > 4) && P.coreMouseService.triggerMouseEvent({ col: Ce.col, row: Ce.row, x: Ce.x, y: Ce.y, button: Ke, action: gt, ctrl: se.ctrlKey, alt: se.altKey, shift: se.shiftKey });
            }
            const j = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, ue = { mouseup: (se) => (N(se), se.buttons || (this._document.removeEventListener("mouseup", j.mouseup), j.mousedrag && this._document.removeEventListener("mousemove", j.mousedrag)), this.cancel(se)), wheel: (se) => (N(se), this.cancel(se, !0)), mousedrag: (se) => {
              se.buttons && N(se);
            }, mousemove: (se) => {
              se.buttons || N(se);
            } };
            this.register(this.coreMouseService.onProtocolChange((se) => {
              se ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(se)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & se ? j.mousemove || (I.addEventListener("mousemove", ue.mousemove), j.mousemove = ue.mousemove) : (I.removeEventListener("mousemove", j.mousemove), j.mousemove = null), 16 & se ? j.wheel || (I.addEventListener("wheel", ue.wheel, { passive: !1 }), j.wheel = ue.wheel) : (I.removeEventListener("wheel", j.wheel), j.wheel = null), 2 & se ? j.mouseup || (I.addEventListener("mouseup", ue.mouseup), j.mouseup = ue.mouseup) : (this._document.removeEventListener("mouseup", j.mouseup), I.removeEventListener("mouseup", j.mouseup), j.mouseup = null), 4 & se ? j.mousedrag || (j.mousedrag = ue.mousedrag) : (this._document.removeEventListener("mousemove", j.mousedrag), j.mousedrag = null);
            })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, h.addDisposableDomListener)(I, "mousedown", (se) => {
              if (se.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(se)) return N(se), j.mouseup && this._document.addEventListener("mouseup", j.mouseup), j.mousedrag && this._document.addEventListener("mousemove", j.mousedrag), this.cancel(se);
            })), this.register((0, h.addDisposableDomListener)(I, "wheel", (se) => {
              if (!j.wheel) {
                if (!this.buffer.hasScrollback) {
                  const Ce = this.viewport.getLinesScrolled(se);
                  if (Ce === 0) return;
                  const Ke = z.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (se.deltaY < 0 ? "A" : "B");
                  let gt = "";
                  for (let Zr = 0; Zr < Math.abs(Ce); Zr++) gt += Ke;
                  return this.coreService.triggerDataEvent(gt, !0), this.cancel(se, !0);
                }
                return this.viewport.handleWheel(se) ? this.cancel(se) : void 0;
              }
            }, { passive: !1 })), this.register((0, h.addDisposableDomListener)(I, "touchstart", (se) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(se), this.cancel(se);
            }, { passive: !0 })), this.register((0, h.addDisposableDomListener)(I, "touchmove", (se) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(se) ? void 0 : this.cancel(se);
            }, { passive: !1 }));
          }
          refresh(P, I) {
            var N;
            (N = this._renderService) === null || N === void 0 || N.refreshRows(P, I);
          }
          updateCursorStyle(P) {
            var I;
            !((I = this._selectionService) === null || I === void 0) && I.shouldColumnSelect(P) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
          }
          _showCursor() {
            this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y));
          }
          scrollLines(P, I, N = 0) {
            var j;
            N === 1 ? (super.scrollLines(P, I, N), this.refresh(0, this.rows - 1)) : (j = this.viewport) === null || j === void 0 || j.scrollLines(P);
          }
          paste(P) {
            (0, c.paste)(P, this.textarea, this.coreService, this.optionsService);
          }
          attachCustomKeyEventHandler(P) {
            this._customKeyEventHandler = P;
          }
          registerLinkProvider(P) {
            return this.linkifier2.registerLinkProvider(P);
          }
          registerCharacterJoiner(P) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            const I = this._characterJoinerService.register(P);
            return this.refresh(0, this.rows - 1), I;
          }
          deregisterCharacterJoiner(P) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            this._characterJoinerService.deregister(P) && this.refresh(0, this.rows - 1);
          }
          get markers() {
            return this.buffer.markers;
          }
          registerMarker(P) {
            return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + P);
          }
          registerDecoration(P) {
            return this._decorationService.registerDecoration(P);
          }
          hasSelection() {
            return !!this._selectionService && this._selectionService.hasSelection;
          }
          select(P, I, N) {
            this._selectionService.setSelection(P, I, N);
          }
          getSelection() {
            return this._selectionService ? this._selectionService.selectionText : "";
          }
          getSelectionPosition() {
            if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
          }
          clearSelection() {
            var P;
            (P = this._selectionService) === null || P === void 0 || P.clearSelection();
          }
          selectAll() {
            var P;
            (P = this._selectionService) === null || P === void 0 || P.selectAll();
          }
          selectLines(P, I) {
            var N;
            (N = this._selectionService) === null || N === void 0 || N.selectLines(P, I);
          }
          _keyDown(P) {
            if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && this._customKeyEventHandler(P) === !1) return !1;
            const I = this.browser.isMac && this.options.macOptionIsMeta && P.altKey;
            if (!I && !this._compositionHelper.keydown(P)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), !1;
            I || P.key !== "Dead" && P.key !== "AltGraph" || (this._unprocessedDeadKey = !0);
            const N = (0, Q.evaluateKeyboardEvent)(P, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
            if (this.updateCursorStyle(P), N.type === 3 || N.type === 2) {
              const j = this.rows - 1;
              return this.scrollLines(N.type === 2 ? -j : j), this.cancel(P, !0);
            }
            return N.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, P) || (N.cancel && this.cancel(P, !0), !N.key || !!(P.key && !P.ctrlKey && !P.altKey && !P.metaKey && P.key.length === 1 && P.key.charCodeAt(0) >= 65 && P.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : (N.key !== z.C0.ETX && N.key !== z.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: N.key, domEvent: P }), this._showCursor(), this.coreService.triggerDataEvent(N.key, !0), !this.optionsService.rawOptions.screenReaderMode || P.altKey || P.ctrlKey ? this.cancel(P, !0) : void (this._keyDownHandled = !0))));
          }
          _isThirdLevelShift(P, I) {
            const N = P.isMac && !this.options.macOptionIsMeta && I.altKey && !I.ctrlKey && !I.metaKey || P.isWindows && I.altKey && I.ctrlKey && !I.metaKey || P.isWindows && I.getModifierState("AltGraph");
            return I.type === "keypress" ? N : N && (!I.keyCode || I.keyCode > 47);
          }
          _keyUp(P) {
            this._keyDownSeen = !1, this._customKeyEventHandler && this._customKeyEventHandler(P) === !1 || (function(I) {
              return I.keyCode === 16 || I.keyCode === 17 || I.keyCode === 18;
            }(P) || this.focus(), this.updateCursorStyle(P), this._keyPressHandled = !1);
          }
          _keyPress(P) {
            let I;
            if (this._keyPressHandled = !1, this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(P) === !1) return !1;
            if (this.cancel(P), P.charCode) I = P.charCode;
            else if (P.which === null || P.which === void 0) I = P.keyCode;
            else {
              if (P.which === 0 || P.charCode === 0) return !1;
              I = P.which;
            }
            return !(!I || (P.altKey || P.ctrlKey || P.metaKey) && !this._isThirdLevelShift(this.browser, P) || (I = String.fromCharCode(I), this._onKey.fire({ key: I, domEvent: P }), this._showCursor(), this.coreService.triggerDataEvent(I, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0));
          }
          _inputEvent(P) {
            if (P.data && P.inputType === "insertText" && (!P.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
              if (this._keyPressHandled) return !1;
              this._unprocessedDeadKey = !1;
              const I = P.data;
              return this.coreService.triggerDataEvent(I, !0), this.cancel(P), !0;
            }
            return !1;
          }
          resize(P, I) {
            P !== this.cols || I !== this.rows ? super.resize(P, I) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
          }
          _afterResize(P, I) {
            var N, j;
            (N = this._charSizeService) === null || N === void 0 || N.measure(), (j = this.viewport) === null || j === void 0 || j.syncScrollArea(!0);
          }
          clear() {
            var P;
            if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
              this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
              for (let I = 1; I < this.rows; I++) this.buffer.lines.push(this.buffer.getBlankLine(W.DEFAULT_ATTR_DATA));
              this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), (P = this.viewport) === null || P === void 0 || P.reset(), this.refresh(0, this.rows - 1);
            }
          }
          reset() {
            var P, I;
            this.options.rows = this.rows, this.options.cols = this.cols;
            const N = this._customKeyEventHandler;
            this._setup(), super.reset(), (P = this._selectionService) === null || P === void 0 || P.reset(), this._decorationService.reset(), (I = this.viewport) === null || I === void 0 || I.reset(), this._customKeyEventHandler = N, this.refresh(0, this.rows - 1);
          }
          clearTextureAtlas() {
            var P;
            (P = this._renderService) === null || P === void 0 || P.clearTextureAtlas();
          }
          _reportFocus() {
            var P;
            !((P = this.element) === null || P === void 0) && P.classList.contains("focus") ? this.coreService.triggerDataEvent(z.C0.ESC + "[I") : this.coreService.triggerDataEvent(z.C0.ESC + "[O");
          }
          _reportWindowsOptions(P) {
            if (this._renderService) switch (P) {
              case U.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                const I = this._renderService.dimensions.css.canvas.width.toFixed(0), N = this._renderService.dimensions.css.canvas.height.toFixed(0);
                this.coreService.triggerDataEvent(`${z.C0.ESC}[4;${N};${I}t`);
                break;
              case U.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                const j = this._renderService.dimensions.css.cell.width.toFixed(0), ue = this._renderService.dimensions.css.cell.height.toFixed(0);
                this.coreService.triggerDataEvent(`${z.C0.ESC}[6;${ue};${j}t`);
            }
          }
          cancel(P, I) {
            if (this.options.cancelEvents || I) return P.preventDefault(), P.stopPropagation(), !1;
          }
        }
        a.Terminal = te;
      }, 9924: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.TimeBasedDebouncer = void 0, a.TimeBasedDebouncer = class {
          constructor(l, c = 1e3) {
            this._renderCallback = l, this._debounceThresholdMS = c, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1;
          }
          dispose() {
            this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
          }
          refresh(l, c, h) {
            this._rowCount = h, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c;
            const f = Date.now();
            if (f - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = f, this._innerRefresh();
            else if (!this._additionalRefreshRequested) {
              const u = f - this._lastRefreshMs, g = this._debounceThresholdMS - u;
              this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(() => {
                this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0;
              }, g);
            }
          }
          _innerRefresh() {
            if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return;
            const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c);
          }
        };
      }, 1680: function(o, a, l) {
        var c = this && this.__decorate || function(O, p, m, _) {
          var b, w = arguments.length, x = w < 3 ? p : _ === null ? _ = Object.getOwnPropertyDescriptor(p, m) : _;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(O, p, m, _);
          else for (var y = O.length - 1; y >= 0; y--) (b = O[y]) && (x = (w < 3 ? b(x) : w > 3 ? b(p, m, x) : b(p, m)) || x);
          return w > 3 && x && Object.defineProperty(p, m, x), x;
        }, h = this && this.__param || function(O, p) {
          return function(m, _) {
            p(m, _, O);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Viewport = void 0;
        const f = l(3656), u = l(4725), g = l(8460), S = l(844), v = l(2585);
        let d = a.Viewport = class extends S.Disposable {
          constructor(O, p, m, _, b, w, x, y) {
            super(), this._viewportElement = O, this._scrollArea = p, this._bufferService = m, this._optionsService = _, this._charSizeService = b, this._renderService = w, this._coreBrowserService = x, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new g.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, f.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((k) => this._activeBuffer = k.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((k) => this._renderDimensions = k)), this._handleThemeChange(y.colors), this.register(y.onChangeColors((k) => this._handleThemeChange(k))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
          }
          _handleThemeChange(O) {
            this._viewportElement.style.backgroundColor = O.background.css;
          }
          reset() {
            this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
          }
          _refresh(O) {
            if (O) return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
            this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._charSizeService.height > 0) {
              this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
              const p = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
              this._lastRecordedBufferHeight !== p && (this._lastRecordedBufferHeight = p, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
            }
            const O = this._bufferService.buffer.ydisp * this._currentRowHeight;
            this._viewportElement.scrollTop !== O && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = O), this._refreshAnimationFrame = null;
          }
          syncScrollArea(O = !1) {
            if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(O);
            this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(O);
          }
          _handleScroll(O) {
            if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
            if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = !1, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: !0 });
            const p = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
            this._onRequestScrollLines.fire({ amount: p, suppressScrollEvent: !0 });
          }
          _smoothScroll() {
            if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1) return;
            const O = this._smoothScrollPercent();
            this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(O * (this._smoothScrollState.target - this._smoothScrollState.origin)), O < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
          }
          _smoothScrollPercent() {
            return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
          }
          _clearSmoothScrollState() {
            this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
          }
          _bubbleScroll(O, p) {
            const m = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
            return !(p < 0 && this._viewportElement.scrollTop !== 0 || p > 0 && m < this._lastRecordedBufferHeight) || (O.cancelable && O.preventDefault(), !1);
          }
          handleWheel(O) {
            const p = this._getPixelsScrolled(O);
            return p !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + p : this._smoothScrollState.target += p, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += p, this._bubbleScroll(O, p));
          }
          scrollLines(O) {
            if (O !== 0) if (this._optionsService.rawOptions.smoothScrollDuration) {
              const p = O * this._currentRowHeight;
              this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + p, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
            } else this._onRequestScrollLines.fire({ amount: O, suppressScrollEvent: !1 });
          }
          _getPixelsScrolled(O) {
            if (O.deltaY === 0 || O.shiftKey) return 0;
            let p = this._applyScrollModifier(O.deltaY, O);
            return O.deltaMode === WheelEvent.DOM_DELTA_LINE ? p *= this._currentRowHeight : O.deltaMode === WheelEvent.DOM_DELTA_PAGE && (p *= this._currentRowHeight * this._bufferService.rows), p;
          }
          getBufferElements(O, p) {
            var m;
            let _, b = "";
            const w = [], x = p ?? this._bufferService.buffer.lines.length, y = this._bufferService.buffer.lines;
            for (let k = O; k < x; k++) {
              const T = y.get(k);
              if (!T) continue;
              const R = (m = y.get(k + 1)) === null || m === void 0 ? void 0 : m.isWrapped;
              if (b += T.translateToString(!R), !R || k === y.length - 1) {
                const $ = document.createElement("div");
                $.textContent = b, w.push($), b.length > 0 && (_ = $), b = "";
              }
            }
            return { bufferElements: w, cursorElement: _ };
          }
          getLinesScrolled(O) {
            if (O.deltaY === 0 || O.shiftKey) return 0;
            let p = this._applyScrollModifier(O.deltaY, O);
            return O.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (p /= this._currentRowHeight + 0, this._wheelPartialScroll += p, p = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : O.deltaMode === WheelEvent.DOM_DELTA_PAGE && (p *= this._bufferService.rows), p;
          }
          _applyScrollModifier(O, p) {
            const m = this._optionsService.rawOptions.fastScrollModifier;
            return m === "alt" && p.altKey || m === "ctrl" && p.ctrlKey || m === "shift" && p.shiftKey ? O * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : O * this._optionsService.rawOptions.scrollSensitivity;
          }
          handleTouchStart(O) {
            this._lastTouchY = O.touches[0].pageY;
          }
          handleTouchMove(O) {
            const p = this._lastTouchY - O.touches[0].pageY;
            return this._lastTouchY = O.touches[0].pageY, p !== 0 && (this._viewportElement.scrollTop += p, this._bubbleScroll(O, p));
          }
        };
        a.Viewport = d = c([h(2, v.IBufferService), h(3, v.IOptionsService), h(4, u.ICharSizeService), h(5, u.IRenderService), h(6, u.ICoreBrowserService), h(7, u.IThemeService)], d);
      }, 3107: function(o, a, l) {
        var c = this && this.__decorate || function(d, O, p, m) {
          var _, b = arguments.length, w = b < 3 ? O : m === null ? m = Object.getOwnPropertyDescriptor(O, p) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(d, O, p, m);
          else for (var x = d.length - 1; x >= 0; x--) (_ = d[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(O, p, w) : _(O, p)) || w);
          return b > 3 && w && Object.defineProperty(O, p, w), w;
        }, h = this && this.__param || function(d, O) {
          return function(p, m) {
            O(p, m, d);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferDecorationRenderer = void 0;
        const f = l(3656), u = l(4725), g = l(844), S = l(2585);
        let v = a.BufferDecorationRenderer = class extends g.Disposable {
          constructor(d, O, p, m) {
            super(), this._screenElement = d, this._bufferService = O, this._decorationService = p, this._renderService = m, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
              this._dimensionsChanged = !0, this._queueRefresh();
            })), this.register((0, f.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
            })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((_) => this._removeDecoration(_))), this.register((0, g.toDisposable)(() => {
              this._container.remove(), this._decorationElements.clear();
            }));
          }
          _queueRefresh() {
            this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback(() => {
              this._doRefreshDecorations(), this._animationFrame = void 0;
            }));
          }
          _doRefreshDecorations() {
            for (const d of this._decorationService.decorations) this._renderDecoration(d);
            this._dimensionsChanged = !1;
          }
          _renderDecoration(d) {
            this._refreshStyle(d), this._dimensionsChanged && this._refreshXPosition(d);
          }
          _createElement(d) {
            var O, p;
            const m = document.createElement("div");
            m.classList.add("xterm-decoration"), m.classList.toggle("xterm-decoration-top-layer", ((O = d?.options) === null || O === void 0 ? void 0 : O.layer) === "top"), m.style.width = `${Math.round((d.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, m.style.height = (d.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", m.style.top = (d.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", m.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
            const _ = (p = d.options.x) !== null && p !== void 0 ? p : 0;
            return _ && _ > this._bufferService.cols && (m.style.display = "none"), this._refreshXPosition(d, m), m;
          }
          _refreshStyle(d) {
            const O = d.marker.line - this._bufferService.buffers.active.ydisp;
            if (O < 0 || O >= this._bufferService.rows) d.element && (d.element.style.display = "none", d.onRenderEmitter.fire(d.element));
            else {
              let p = this._decorationElements.get(d);
              p || (p = this._createElement(d), d.element = p, this._decorationElements.set(d, p), this._container.appendChild(p), d.onDispose(() => {
                this._decorationElements.delete(d), p.remove();
              })), p.style.top = O * this._renderService.dimensions.css.cell.height + "px", p.style.display = this._altBufferIsActive ? "none" : "block", d.onRenderEmitter.fire(p);
            }
          }
          _refreshXPosition(d, O = d.element) {
            var p;
            if (!O) return;
            const m = (p = d.options.x) !== null && p !== void 0 ? p : 0;
            (d.options.anchor || "left") === "right" ? O.style.right = m ? m * this._renderService.dimensions.css.cell.width + "px" : "" : O.style.left = m ? m * this._renderService.dimensions.css.cell.width + "px" : "";
          }
          _removeDecoration(d) {
            var O;
            (O = this._decorationElements.get(d)) === null || O === void 0 || O.remove(), this._decorationElements.delete(d), d.dispose();
          }
        };
        a.BufferDecorationRenderer = v = c([h(1, S.IBufferService), h(2, S.IDecorationService), h(3, u.IRenderService)], v);
      }, 5871: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorZoneStore = void 0, a.ColorZoneStore = class {
          constructor() {
            this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
          }
          get zones() {
            return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
          }
          clear() {
            this._zones.length = 0, this._zonePoolIndex = 0;
          }
          addDecoration(l) {
            if (l.options.overviewRulerOptions) {
              for (const c of this._zones) if (c.color === l.options.overviewRulerOptions.color && c.position === l.options.overviewRulerOptions.position) {
                if (this._lineIntersectsZone(c, l.marker.line)) return;
                if (this._lineAdjacentToZone(c, l.marker.line, l.options.overviewRulerOptions.position)) return void this._addLineToZone(c, l.marker.line);
              }
              if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = l.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = l.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = l.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = l.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
              this._zones.push({ color: l.options.overviewRulerOptions.color, position: l.options.overviewRulerOptions.position, startBufferLine: l.marker.line, endBufferLine: l.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
            }
          }
          setPadding(l) {
            this._linePadding = l;
          }
          _lineIntersectsZone(l, c) {
            return c >= l.startBufferLine && c <= l.endBufferLine;
          }
          _lineAdjacentToZone(l, c, h) {
            return c >= l.startBufferLine - this._linePadding[h || "full"] && c <= l.endBufferLine + this._linePadding[h || "full"];
          }
          _addLineToZone(l, c) {
            l.startBufferLine = Math.min(l.startBufferLine, c), l.endBufferLine = Math.max(l.endBufferLine, c);
          }
        };
      }, 5744: function(o, a, l) {
        var c = this && this.__decorate || function(_, b, w, x) {
          var y, k = arguments.length, T = k < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, w) : x;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(_, b, w, x);
          else for (var R = _.length - 1; R >= 0; R--) (y = _[R]) && (T = (k < 3 ? y(T) : k > 3 ? y(b, w, T) : y(b, w)) || T);
          return k > 3 && T && Object.defineProperty(b, w, T), T;
        }, h = this && this.__param || function(_, b) {
          return function(w, x) {
            b(w, x, _);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OverviewRulerRenderer = void 0;
        const f = l(5871), u = l(3656), g = l(4725), S = l(844), v = l(2585), d = { full: 0, left: 0, center: 0, right: 0 }, O = { full: 0, left: 0, center: 0, right: 0 }, p = { full: 0, left: 0, center: 0, right: 0 };
        let m = a.OverviewRulerRenderer = class extends S.Disposable {
          get _width() {
            return this._optionsService.options.overviewRulerWidth || 0;
          }
          constructor(_, b, w, x, y, k, T) {
            var R;
            super(), this._viewportElement = _, this._screenElement = b, this._bufferService = w, this._decorationService = x, this._renderService = y, this._optionsService = k, this._coreBrowseService = T, this._colorZoneStore = new f.ColorZoneStore(), this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), (R = this._viewportElement.parentElement) === null || R === void 0 || R.insertBefore(this._canvas, this._viewportElement);
            const $ = this._canvas.getContext("2d");
            if (!$) throw new Error("Ctx cannot be null");
            this._ctx = $, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, S.toDisposable)(() => {
              var E;
              (E = this._canvas) === null || E === void 0 || E.remove();
            }));
          }
          _registerDecorationListeners() {
            this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, !0)));
          }
          _registerBufferChangeListeners() {
            this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
            })), this.register(this._bufferService.onScroll(() => {
              this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
            }));
          }
          _registerDimensionChangeListeners() {
            this.register(this._renderService.onRender(() => {
              this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight);
            })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(!0))), this.register((0, u.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(!0))), this._queueRefresh(!0);
          }
          _refreshDrawConstants() {
            const _ = Math.floor(this._canvas.width / 3), b = Math.ceil(this._canvas.width / 3);
            O.full = this._canvas.width, O.left = _, O.center = b, O.right = _, this._refreshDrawHeightConstants(), p.full = 0, p.left = 0, p.center = O.left, p.right = O.left + O.center;
          }
          _refreshDrawHeightConstants() {
            d.full = Math.round(2 * this._coreBrowseService.dpr);
            const _ = this._canvas.height / this._bufferService.buffer.lines.length, b = Math.round(Math.max(Math.min(_, 12), 6) * this._coreBrowseService.dpr);
            d.left = b, d.center = b, d.right = b;
          }
          _refreshColorZonePadding() {
            this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
          }
          _refreshCanvasDimensions() {
            this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
          }
          _refreshDecorations() {
            this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
            for (const b of this._decorationService.decorations) this._colorZoneStore.addDecoration(b);
            this._ctx.lineWidth = 1;
            const _ = this._colorZoneStore.zones;
            for (const b of _) b.position !== "full" && this._renderColorZone(b);
            for (const b of _) b.position === "full" && this._renderColorZone(b);
            this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1;
          }
          _renderColorZone(_) {
            this._ctx.fillStyle = _.color, this._ctx.fillRect(p[_.position || "full"], Math.round((this._canvas.height - 1) * (_.startBufferLine / this._bufferService.buffers.active.lines.length) - d[_.position || "full"] / 2), O[_.position || "full"], Math.round((this._canvas.height - 1) * ((_.endBufferLine - _.startBufferLine) / this._bufferService.buffers.active.lines.length) + d[_.position || "full"]));
          }
          _queueRefresh(_, b) {
            this._shouldUpdateDimensions = _ || this._shouldUpdateDimensions, this._shouldUpdateAnchor = b || this._shouldUpdateAnchor, this._animationFrame === void 0 && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
              this._refreshDecorations(), this._animationFrame = void 0;
            }));
          }
        };
        a.OverviewRulerRenderer = m = c([h(2, v.IBufferService), h(3, v.IDecorationService), h(4, g.IRenderService), h(5, v.IOptionsService), h(6, g.ICoreBrowserService)], m);
      }, 2950: function(o, a, l) {
        var c = this && this.__decorate || function(v, d, O, p) {
          var m, _ = arguments.length, b = _ < 3 ? d : p === null ? p = Object.getOwnPropertyDescriptor(d, O) : p;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") b = Reflect.decorate(v, d, O, p);
          else for (var w = v.length - 1; w >= 0; w--) (m = v[w]) && (b = (_ < 3 ? m(b) : _ > 3 ? m(d, O, b) : m(d, O)) || b);
          return _ > 3 && b && Object.defineProperty(d, O, b), b;
        }, h = this && this.__param || function(v, d) {
          return function(O, p) {
            d(O, p, v);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CompositionHelper = void 0;
        const f = l(4725), u = l(2585), g = l(2584);
        let S = a.CompositionHelper = class {
          get isComposing() {
            return this._isComposing;
          }
          constructor(v, d, O, p, m, _) {
            this._textarea = v, this._compositionView = d, this._bufferService = O, this._optionsService = p, this._coreService = m, this._renderService = _, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
          }
          compositionstart() {
            this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
          }
          compositionupdate(v) {
            this._compositionView.textContent = v.data, this.updateCompositionElements(), setTimeout(() => {
              this._compositionPosition.end = this._textarea.value.length;
            }, 0);
          }
          compositionend() {
            this._finalizeComposition(!0);
          }
          keydown(v) {
            if (this._isComposing || this._isSendingComposition) {
              if (v.keyCode === 229 || v.keyCode === 16 || v.keyCode === 17 || v.keyCode === 18) return !1;
              this._finalizeComposition(!1);
            }
            return v.keyCode !== 229 || (this._handleAnyTextareaChanges(), !1);
          }
          _finalizeComposition(v) {
            if (this._compositionView.classList.remove("active"), this._isComposing = !1, v) {
              const d = { start: this._compositionPosition.start, end: this._compositionPosition.end };
              this._isSendingComposition = !0, setTimeout(() => {
                if (this._isSendingComposition) {
                  let O;
                  this._isSendingComposition = !1, d.start += this._dataAlreadySent.length, O = this._isComposing ? this._textarea.value.substring(d.start, d.end) : this._textarea.value.substring(d.start), O.length > 0 && this._coreService.triggerDataEvent(O, !0);
                }
              }, 0);
            } else {
              this._isSendingComposition = !1;
              const d = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
              this._coreService.triggerDataEvent(d, !0);
            }
          }
          _handleAnyTextareaChanges() {
            const v = this._textarea.value;
            setTimeout(() => {
              if (!this._isComposing) {
                const d = this._textarea.value, O = d.replace(v, "");
                this._dataAlreadySent = O, d.length > v.length ? this._coreService.triggerDataEvent(O, !0) : d.length < v.length ? this._coreService.triggerDataEvent(`${g.C0.DEL}`, !0) : d.length === v.length && d !== v && this._coreService.triggerDataEvent(d, !0);
              }
            }, 0);
          }
          updateCompositionElements(v) {
            if (this._isComposing) {
              if (this._bufferService.buffer.isCursorInViewport) {
                const d = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), O = this._renderService.dimensions.css.cell.height, p = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, m = d * this._renderService.dimensions.css.cell.width;
                this._compositionView.style.left = m + "px", this._compositionView.style.top = p + "px", this._compositionView.style.height = O + "px", this._compositionView.style.lineHeight = O + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                const _ = this._compositionView.getBoundingClientRect();
                this._textarea.style.left = m + "px", this._textarea.style.top = p + "px", this._textarea.style.width = Math.max(_.width, 1) + "px", this._textarea.style.height = Math.max(_.height, 1) + "px", this._textarea.style.lineHeight = _.height + "px";
              }
              v || setTimeout(() => this.updateCompositionElements(!0), 0);
            }
          }
        };
        a.CompositionHelper = S = c([h(2, u.IBufferService), h(3, u.IOptionsService), h(4, u.ICoreService), h(5, f.IRenderService)], S);
      }, 9806: (o, a) => {
        function l(c, h, f) {
          const u = f.getBoundingClientRect(), g = c.getComputedStyle(f), S = parseInt(g.getPropertyValue("padding-left")), v = parseInt(g.getPropertyValue("padding-top"));
          return [h.clientX - u.left - S, h.clientY - u.top - v];
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getCoords = a.getCoordsRelativeToElement = void 0, a.getCoordsRelativeToElement = l, a.getCoords = function(c, h, f, u, g, S, v, d, O) {
          if (!S) return;
          const p = l(c, h, f);
          return p ? (p[0] = Math.ceil((p[0] + (O ? v / 2 : 0)) / v), p[1] = Math.ceil(p[1] / d), p[0] = Math.min(Math.max(p[0], 1), u + (O ? 1 : 0)), p[1] = Math.min(Math.max(p[1], 1), g), p) : void 0;
        };
      }, 9504: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.moveToCellSequence = void 0;
        const c = l(2584);
        function h(d, O, p, m) {
          const _ = d - f(d, p), b = O - f(O, p), w = Math.abs(_ - b) - function(x, y, k) {
            let T = 0;
            const R = x - f(x, k), $ = y - f(y, k);
            for (let E = 0; E < Math.abs(R - $); E++) {
              const D = u(x, y) === "A" ? -1 : 1, q = k.buffer.lines.get(R + D * E);
              q?.isWrapped && T++;
            }
            return T;
          }(d, O, p);
          return v(w, S(u(d, O), m));
        }
        function f(d, O) {
          let p = 0, m = O.buffer.lines.get(d), _ = m?.isWrapped;
          for (; _ && d >= 0 && d < O.rows; ) p++, m = O.buffer.lines.get(--d), _ = m?.isWrapped;
          return p;
        }
        function u(d, O) {
          return d > O ? "A" : "B";
        }
        function g(d, O, p, m, _, b) {
          let w = d, x = O, y = "";
          for (; w !== p || x !== m; ) w += _ ? 1 : -1, _ && w > b.cols - 1 ? (y += b.buffer.translateBufferLineToString(x, !1, d, w), w = 0, d = 0, x++) : !_ && w < 0 && (y += b.buffer.translateBufferLineToString(x, !1, 0, d + 1), w = b.cols - 1, d = w, x--);
          return y + b.buffer.translateBufferLineToString(x, !1, d, w);
        }
        function S(d, O) {
          const p = O ? "O" : "[";
          return c.C0.ESC + p + d;
        }
        function v(d, O) {
          d = Math.floor(d);
          let p = "";
          for (let m = 0; m < d; m++) p += O;
          return p;
        }
        a.moveToCellSequence = function(d, O, p, m) {
          const _ = p.buffer.x, b = p.buffer.y;
          if (!p.buffer.hasScrollback) return function(y, k, T, R, $, E) {
            return h(k, R, $, E).length === 0 ? "" : v(g(y, k, y, k - f(k, $), !1, $).length, S("D", E));
          }(_, b, 0, O, p, m) + h(b, O, p, m) + function(y, k, T, R, $, E) {
            let D;
            D = h(k, R, $, E).length > 0 ? R - f(R, $) : k;
            const q = R, W = function(z, Q, A, L, M, U) {
              let F;
              return F = h(A, L, M, U).length > 0 ? L - f(L, M) : Q, z < A && F <= L || z >= A && F < L ? "C" : "D";
            }(y, k, T, R, $, E);
            return v(g(y, D, T, q, W === "C", $).length, S(W, E));
          }(_, b, d, O, p, m);
          let w;
          if (b === O) return w = _ > d ? "D" : "C", v(Math.abs(_ - d), S(w, m));
          w = b > O ? "D" : "C";
          const x = Math.abs(b - O);
          return v(function(y, k) {
            return k.cols - y;
          }(b > O ? d : _, p) + (x - 1) * p.cols + 1 + ((b > O ? _ : d) - 1), S(w, m));
        };
      }, 1296: function(o, a, l) {
        var c = this && this.__decorate || function($, E, D, q) {
          var W, z = arguments.length, Q = z < 3 ? E : q === null ? q = Object.getOwnPropertyDescriptor(E, D) : q;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Q = Reflect.decorate($, E, D, q);
          else for (var A = $.length - 1; A >= 0; A--) (W = $[A]) && (Q = (z < 3 ? W(Q) : z > 3 ? W(E, D, Q) : W(E, D)) || Q);
          return z > 3 && Q && Object.defineProperty(E, D, Q), Q;
        }, h = this && this.__param || function($, E) {
          return function(D, q) {
            E(D, q, $);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRenderer = void 0;
        const f = l(3787), u = l(2550), g = l(2223), S = l(6171), v = l(4725), d = l(8055), O = l(8460), p = l(844), m = l(2585), _ = "xterm-dom-renderer-owner-", b = "xterm-rows", w = "xterm-fg-", x = "xterm-bg-", y = "xterm-focus", k = "xterm-selection";
        let T = 1, R = a.DomRenderer = class extends p.Disposable {
          constructor($, E, D, q, W, z, Q, A, L, M) {
            super(), this._element = $, this._screenElement = E, this._viewportElement = D, this._linkifier2 = q, this._charSizeService = z, this._optionsService = Q, this._bufferService = A, this._coreBrowserService = L, this._themeService = M, this._terminalClass = T++, this._rowElements = [], this.onRequestRedraw = this.register(new O.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add(b), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add(k), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, S.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((U) => this._injectCss(U))), this._injectCss(this._themeService.colors), this._rowFactory = W.createInstance(f.DomRendererRowFactory, document), this._element.classList.add(_ + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((U) => this._handleLinkHover(U))), this.register(this._linkifier2.onHideLinkUnderline((U) => this._handleLinkLeave(U))), this.register((0, p.toDisposable)(() => {
              this._element.classList.remove(_ + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
            })), this._widthCache = new u.WidthCache(document), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          _updateDimensions() {
            const $ = this._coreBrowserService.dpr;
            this.dimensions.device.char.width = this._charSizeService.width * $, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * $), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / $), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / $), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
            for (const D of this._rowElements) D.style.width = `${this.dimensions.css.canvas.width}px`, D.style.height = `${this.dimensions.css.cell.height}px`, D.style.lineHeight = `${this.dimensions.css.cell.height}px`, D.style.overflow = "hidden";
            this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
            const E = `${this._terminalSelector} .${b} span { display: inline-block; height: 100%; vertical-align: top;}`;
            this._dimensionsStyleElement.textContent = E, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
          }
          _injectCss($) {
            this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
            let E = `${this._terminalSelector} .${b} { color: ${$.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
            E += `${this._terminalSelector} .${b} .xterm-dim { color: ${d.color.multiplyOpacity($.foreground, 0.5).css};}`, E += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, E += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", E += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${$.cursor.css};  color: ${$.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${$.cursor.css}; }}`, E += `${this._terminalSelector} .${b}.${y} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${b}.${y} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-block { background-color: ${$.cursor.css}; color: ${$.cursorAccent.css};}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${$.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${$.cursor.css} inset;}${this._terminalSelector} .${b} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${$.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, E += `${this._terminalSelector} .${k} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${k} div { position: absolute; background-color: ${$.selectionBackgroundOpaque.css};}${this._terminalSelector} .${k} div { position: absolute; background-color: ${$.selectionInactiveBackgroundOpaque.css};}`;
            for (const [D, q] of $.ansi.entries()) E += `${this._terminalSelector} .${w}${D} { color: ${q.css}; }${this._terminalSelector} .${w}${D}.xterm-dim { color: ${d.color.multiplyOpacity(q, 0.5).css}; }${this._terminalSelector} .${x}${D} { background-color: ${q.css}; }`;
            E += `${this._terminalSelector} .${w}${g.INVERTED_DEFAULT_COLOR} { color: ${d.color.opaque($.background).css}; }${this._terminalSelector} .${w}${g.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${d.color.multiplyOpacity(d.color.opaque($.background), 0.5).css}; }${this._terminalSelector} .${x}${g.INVERTED_DEFAULT_COLOR} { background-color: ${$.foreground.css}; }`, this._themeStyleElement.textContent = E;
          }
          _setDefaultSpacing() {
            const $ = this.dimensions.css.cell.width - this._widthCache.get("W", !1, !1);
            this._rowContainer.style.letterSpacing = `${$}px`, this._rowFactory.defaultSpacing = $;
          }
          handleDevicePixelRatioChange() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          _refreshRowElements($, E) {
            for (let D = this._rowElements.length; D <= E; D++) {
              const q = document.createElement("div");
              this._rowContainer.appendChild(q), this._rowElements.push(q);
            }
            for (; this._rowElements.length > E; ) this._rowContainer.removeChild(this._rowElements.pop());
          }
          handleResize($, E) {
            this._refreshRowElements($, E), this._updateDimensions();
          }
          handleCharSizeChanged() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          handleBlur() {
            this._rowContainer.classList.remove(y);
          }
          handleFocus() {
            this._rowContainer.classList.add(y), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
          }
          handleSelectionChanged($, E, D) {
            if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged($, E, D), this.renderRows(0, this._bufferService.rows - 1), !$ || !E) return;
            const q = $[1] - this._bufferService.buffer.ydisp, W = E[1] - this._bufferService.buffer.ydisp, z = Math.max(q, 0), Q = Math.min(W, this._bufferService.rows - 1);
            if (z >= this._bufferService.rows || Q < 0) return;
            const A = document.createDocumentFragment();
            if (D) {
              const L = $[0] > E[0];
              A.appendChild(this._createSelectionElement(z, L ? E[0] : $[0], L ? $[0] : E[0], Q - z + 1));
            } else {
              const L = q === z ? $[0] : 0, M = z === W ? E[0] : this._bufferService.cols;
              A.appendChild(this._createSelectionElement(z, L, M));
              const U = Q - z - 1;
              if (A.appendChild(this._createSelectionElement(z + 1, 0, this._bufferService.cols, U)), z !== Q) {
                const F = W === Q ? E[0] : this._bufferService.cols;
                A.appendChild(this._createSelectionElement(Q, 0, F));
              }
            }
            this._selectionContainer.appendChild(A);
          }
          _createSelectionElement($, E, D, q = 1) {
            const W = document.createElement("div");
            return W.style.height = q * this.dimensions.css.cell.height + "px", W.style.top = $ * this.dimensions.css.cell.height + "px", W.style.left = E * this.dimensions.css.cell.width + "px", W.style.width = this.dimensions.css.cell.width * (D - E) + "px", W;
          }
          handleCursorMove() {
          }
          _handleOptionsChanged() {
            this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          clear() {
            for (const $ of this._rowElements) $.replaceChildren();
          }
          renderRows($, E) {
            const D = this._bufferService.buffer, q = D.ybase + D.y, W = Math.min(D.x, this._bufferService.cols - 1), z = this._optionsService.rawOptions.cursorBlink, Q = this._optionsService.rawOptions.cursorStyle, A = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let L = $; L <= E; L++) {
              const M = L + D.ydisp, U = this._rowElements[L], F = D.lines.get(M);
              if (!U || !F) break;
              U.replaceChildren(...this._rowFactory.createRow(F, M, M === q, Q, A, W, z, this.dimensions.css.cell.width, this._widthCache, -1, -1));
            }
          }
          get _terminalSelector() {
            return `.${_}${this._terminalClass}`;
          }
          _handleLinkHover($) {
            this._setCellUnderline($.x1, $.x2, $.y1, $.y2, $.cols, !0);
          }
          _handleLinkLeave($) {
            this._setCellUnderline($.x1, $.x2, $.y1, $.y2, $.cols, !1);
          }
          _setCellUnderline($, E, D, q, W, z) {
            D < 0 && ($ = 0), q < 0 && (E = 0);
            const Q = this._bufferService.rows - 1;
            D = Math.max(Math.min(D, Q), 0), q = Math.max(Math.min(q, Q), 0), W = Math.min(W, this._bufferService.cols);
            const A = this._bufferService.buffer, L = A.ybase + A.y, M = Math.min(A.x, W - 1), U = this._optionsService.rawOptions.cursorBlink, F = this._optionsService.rawOptions.cursorStyle, ne = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let te = D; te <= q; ++te) {
              const de = te + A.ydisp, P = this._rowElements[te], I = A.lines.get(de);
              if (!P || !I) break;
              P.replaceChildren(...this._rowFactory.createRow(I, de, de === L, F, ne, M, U, this.dimensions.css.cell.width, this._widthCache, z ? te === D ? $ : 0 : -1, z ? (te === q ? E : W) - 1 : -1));
            }
          }
        };
        a.DomRenderer = R = c([h(4, m.IInstantiationService), h(5, v.ICharSizeService), h(6, m.IOptionsService), h(7, m.IBufferService), h(8, v.ICoreBrowserService), h(9, v.IThemeService)], R);
      }, 3787: function(o, a, l) {
        var c = this && this.__decorate || function(w, x, y, k) {
          var T, R = arguments.length, $ = R < 3 ? x : k === null ? k = Object.getOwnPropertyDescriptor(x, y) : k;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") $ = Reflect.decorate(w, x, y, k);
          else for (var E = w.length - 1; E >= 0; E--) (T = w[E]) && ($ = (R < 3 ? T($) : R > 3 ? T(x, y, $) : T(x, y)) || $);
          return R > 3 && $ && Object.defineProperty(x, y, $), $;
        }, h = this && this.__param || function(w, x) {
          return function(y, k) {
            x(y, k, w);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRendererRowFactory = void 0;
        const f = l(2223), u = l(643), g = l(511), S = l(2585), v = l(8055), d = l(4725), O = l(4269), p = l(6171), m = l(3734);
        let _ = a.DomRendererRowFactory = class {
          constructor(w, x, y, k, T, R, $) {
            this._document = w, this._characterJoinerService = x, this._optionsService = y, this._coreBrowserService = k, this._coreService = T, this._decorationService = R, this._themeService = $, this._workCell = new g.CellData(), this._columnSelectMode = !1, this.defaultSpacing = 0;
          }
          handleSelectionChanged(w, x, y) {
            this._selectionStart = w, this._selectionEnd = x, this._columnSelectMode = y;
          }
          createRow(w, x, y, k, T, R, $, E, D, q, W) {
            const z = [], Q = this._characterJoinerService.getJoinedCharacters(x), A = this._themeService.colors;
            let L, M = w.getNoBgTrimmedLength();
            y && M < R + 1 && (M = R + 1);
            let U = 0, F = "", ne = 0, te = 0, de = 0, P = !1, I = 0, N = !1, j = 0;
            const ue = [], se = q !== -1 && W !== -1;
            for (let Ce = 0; Ce < M; Ce++) {
              w.loadCell(Ce, this._workCell);
              let Ke = this._workCell.getWidth();
              if (Ke === 0) continue;
              let gt = !1, Zr = Ce, ge = this._workCell;
              if (Q.length > 0 && Ce === Q[0][0]) {
                gt = !0;
                const qe = Q.shift();
                ge = new O.JoinedCellData(this._workCell, w.translateToString(!0, qe[0], qe[1]), qe[1] - qe[0]), Zr = qe[1] - 1, Ke = ge.getWidth();
              }
              const Ts = this._isCellInSelection(Ce, x), Yl = y && Ce === R, Fl = se && Ce >= q && Ce <= W;
              let Hl = !1;
              this._decorationService.forEachDecorationAtCell(Ce, x, void 0, (qe) => {
                Hl = !0;
              });
              let yo = ge.getChars() || u.WHITESPACE_CELL_CHAR;
              if (yo === " " && (ge.isUnderline() || ge.isOverline()) && (yo = " "), j = Ke * E - D.get(yo, ge.isBold(), ge.isItalic()), L) {
                if (U && (Ts && N || !Ts && !N && ge.bg === ne) && (Ts && N && A.selectionForeground || ge.fg === te) && ge.extended.ext === de && Fl === P && j === I && !Yl && !gt && !Hl) {
                  F += yo, U++;
                  continue;
                }
                U && (L.textContent = F), L = this._document.createElement("span"), U = 0, F = "";
              } else L = this._document.createElement("span");
              if (ne = ge.bg, te = ge.fg, de = ge.extended.ext, P = Fl, I = j, N = Ts, gt && R >= Ce && R <= Zr && (R = Ce), !this._coreService.isCursorHidden && Yl) {
                if (ue.push("xterm-cursor"), this._coreBrowserService.isFocused) $ && ue.push("xterm-cursor-blink"), ue.push(k === "bar" ? "xterm-cursor-bar" : k === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block");
                else if (T) switch (T) {
                  case "outline":
                    ue.push("xterm-cursor-outline");
                    break;
                  case "block":
                    ue.push("xterm-cursor-block");
                    break;
                  case "bar":
                    ue.push("xterm-cursor-bar");
                    break;
                  case "underline":
                    ue.push("xterm-cursor-underline");
                }
              }
              if (ge.isBold() && ue.push("xterm-bold"), ge.isItalic() && ue.push("xterm-italic"), ge.isDim() && ue.push("xterm-dim"), F = ge.isInvisible() ? u.WHITESPACE_CELL_CHAR : ge.getChars() || u.WHITESPACE_CELL_CHAR, ge.isUnderline() && (ue.push(`xterm-underline-${ge.extended.underlineStyle}`), F === " " && (F = " "), !ge.isUnderlineColorDefault())) if (ge.isUnderlineColorRGB()) L.style.textDecorationColor = `rgb(${m.AttributeData.toColorRGB(ge.getUnderlineColor()).join(",")})`;
              else {
                let qe = ge.getUnderlineColor();
                this._optionsService.rawOptions.drawBoldTextInBrightColors && ge.isBold() && qe < 8 && (qe += 8), L.style.textDecorationColor = A.ansi[qe].css;
              }
              ge.isOverline() && (ue.push("xterm-overline"), F === " " && (F = " ")), ge.isStrikethrough() && ue.push("xterm-strikethrough"), Fl && (L.style.textDecoration = "underline");
              let Et = ge.getFgColor(), Rs = ge.getFgColorMode(), ii = ge.getBgColor(), Es = ge.getBgColorMode();
              const Gl = !!ge.isInverse();
              if (Gl) {
                const qe = Et;
                Et = ii, ii = qe;
                const zy = Rs;
                Rs = Es, Es = zy;
              }
              let Ni, Kl, Yi, As = !1;
              switch (this._decorationService.forEachDecorationAtCell(Ce, x, void 0, (qe) => {
                qe.options.layer !== "top" && As || (qe.backgroundColorRGB && (Es = 50331648, ii = qe.backgroundColorRGB.rgba >> 8 & 16777215, Ni = qe.backgroundColorRGB), qe.foregroundColorRGB && (Rs = 50331648, Et = qe.foregroundColorRGB.rgba >> 8 & 16777215, Kl = qe.foregroundColorRGB), As = qe.options.layer === "top");
              }), !As && Ts && (Ni = this._coreBrowserService.isFocused ? A.selectionBackgroundOpaque : A.selectionInactiveBackgroundOpaque, ii = Ni.rgba >> 8 & 16777215, Es = 50331648, As = !0, A.selectionForeground && (Rs = 50331648, Et = A.selectionForeground.rgba >> 8 & 16777215, Kl = A.selectionForeground)), As && ue.push("xterm-decoration-top"), Es) {
                case 16777216:
                case 33554432:
                  Yi = A.ansi[ii], ue.push(`xterm-bg-${ii}`);
                  break;
                case 50331648:
                  Yi = v.rgba.toColor(ii >> 16, ii >> 8 & 255, 255 & ii), this._addStyle(L, `background-color:#${b((ii >>> 0).toString(16), "0", 6)}`);
                  break;
                default:
                  Gl ? (Yi = A.foreground, ue.push(`xterm-bg-${f.INVERTED_DEFAULT_COLOR}`)) : Yi = A.background;
              }
              switch (Ni || ge.isDim() && (Ni = v.color.multiplyOpacity(Yi, 0.5)), Rs) {
                case 16777216:
                case 33554432:
                  ge.isBold() && Et < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (Et += 8), this._applyMinimumContrast(L, Yi, A.ansi[Et], ge, Ni, void 0) || ue.push(`xterm-fg-${Et}`);
                  break;
                case 50331648:
                  const qe = v.rgba.toColor(Et >> 16 & 255, Et >> 8 & 255, 255 & Et);
                  this._applyMinimumContrast(L, Yi, qe, ge, Ni, Kl) || this._addStyle(L, `color:#${b(Et.toString(16), "0", 6)}`);
                  break;
                default:
                  this._applyMinimumContrast(L, Yi, A.foreground, ge, Ni, void 0) || Gl && ue.push(`xterm-fg-${f.INVERTED_DEFAULT_COLOR}`);
              }
              ue.length && (L.className = ue.join(" "), ue.length = 0), Yl || gt || Hl ? L.textContent = F : U++, j !== this.defaultSpacing && (L.style.letterSpacing = `${j}px`), z.push(L), Ce = Zr;
            }
            return L && U && (L.textContent = F), z;
          }
          _applyMinimumContrast(w, x, y, k, T, R) {
            if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, p.excludeFromContrastRatioDemands)(k.getCode())) return !1;
            const $ = this._getContrastCache(k);
            let E;
            if (T || R || (E = $.getColor(x.rgba, y.rgba)), E === void 0) {
              const D = this._optionsService.rawOptions.minimumContrastRatio / (k.isDim() ? 2 : 1);
              E = v.color.ensureContrastRatio(T || x, R || y, D), $.setColor((T || x).rgba, (R || y).rgba, E ?? null);
            }
            return !!E && (this._addStyle(w, `color:${E.css}`), !0);
          }
          _getContrastCache(w) {
            return w.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
          }
          _addStyle(w, x) {
            w.setAttribute("style", `${w.getAttribute("style") || ""}${x};`);
          }
          _isCellInSelection(w, x) {
            const y = this._selectionStart, k = this._selectionEnd;
            return !(!y || !k) && (this._columnSelectMode ? y[0] <= k[0] ? w >= y[0] && x >= y[1] && w < k[0] && x <= k[1] : w < y[0] && x >= y[1] && w >= k[0] && x <= k[1] : x > y[1] && x < k[1] || y[1] === k[1] && x === y[1] && w >= y[0] && w < k[0] || y[1] < k[1] && x === k[1] && w < k[0] || y[1] < k[1] && x === y[1] && w >= y[0]);
          }
        };
        function b(w, x, y) {
          for (; w.length < y; ) w = x + w;
          return w;
        }
        a.DomRendererRowFactory = _ = c([h(1, d.ICharacterJoinerService), h(2, S.IOptionsService), h(3, d.ICoreBrowserService), h(4, S.ICoreService), h(5, S.IDecorationService), h(6, d.IThemeService)], _);
      }, 2550: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.WidthCache = void 0, a.WidthCache = class {
          constructor(l) {
            this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = l.createElement("div"), this._container.style.position = "absolute", this._container.style.top = "-50000px", this._container.style.width = "50000px", this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
            const c = l.createElement("span"), h = l.createElement("span");
            h.style.fontWeight = "bold";
            const f = l.createElement("span");
            f.style.fontStyle = "italic";
            const u = l.createElement("span");
            u.style.fontWeight = "bold", u.style.fontStyle = "italic", this._measureElements = [c, h, f, u], this._container.appendChild(c), this._container.appendChild(h), this._container.appendChild(f), this._container.appendChild(u), l.body.appendChild(this._container), this.clear();
          }
          dispose() {
            this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
          }
          clear() {
            this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
          }
          setFont(l, c, h, f) {
            l === this._font && c === this._fontSize && h === this._weight && f === this._weightBold || (this._font = l, this._fontSize = c, this._weight = h, this._weightBold = f, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${h}`, this._measureElements[1].style.fontWeight = `${f}`, this._measureElements[2].style.fontWeight = `${h}`, this._measureElements[3].style.fontWeight = `${f}`, this.clear());
          }
          get(l, c, h) {
            let f = 0;
            if (!c && !h && l.length === 1 && (f = l.charCodeAt(0)) < 256) return this._flat[f] !== -9999 ? this._flat[f] : this._flat[f] = this._measure(l, 0);
            let u = l;
            c && (u += "B"), h && (u += "I");
            let g = this._holey.get(u);
            if (g === void 0) {
              let S = 0;
              c && (S |= 1), h && (S |= 2), g = this._measure(l, S), this._holey.set(u, g);
            }
            return g;
          }
          _measure(l, c) {
            const h = this._measureElements[c];
            return h.textContent = l.repeat(32), h.offsetWidth / 32;
          }
        };
      }, 2223: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.TEXT_BASELINE = a.DIM_OPACITY = a.INVERTED_DEFAULT_COLOR = void 0;
        const c = l(6114);
        a.INVERTED_DEFAULT_COLOR = 257, a.DIM_OPACITY = 0.5, a.TEXT_BASELINE = c.isFirefox || c.isLegacyEdge ? "bottom" : "ideographic";
      }, 6171: (o, a) => {
        function l(c) {
          return 57508 <= c && c <= 57558;
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.createRenderDimensions = a.excludeFromContrastRatioDemands = a.isRestrictedPowerlineGlyph = a.isPowerlineGlyph = a.throwIfFalsy = void 0, a.throwIfFalsy = function(c) {
          if (!c) throw new Error("value must not be falsy");
          return c;
        }, a.isPowerlineGlyph = l, a.isRestrictedPowerlineGlyph = function(c) {
          return 57520 <= c && c <= 57527;
        }, a.excludeFromContrastRatioDemands = function(c) {
          return l(c) || function(h) {
            return 9472 <= h && h <= 9631;
          }(c);
        }, a.createRenderDimensions = function() {
          return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
        };
      }, 456: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionModel = void 0, a.SelectionModel = class {
          constructor(l) {
            this._bufferService = l, this.isSelectAllActive = !1, this.selectionStartLength = 0;
          }
          clearSelection() {
            this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0;
          }
          get finalSelectionStart() {
            return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
          }
          get finalSelectionEnd() {
            if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
            if (this.selectionStart) {
              if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                const l = this.selectionStart[0] + this.selectionStartLength;
                return l > this._bufferService.cols ? l % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols) - 1] : [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [l, this.selectionStart[1]];
              }
              if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                const l = this.selectionStart[0] + this.selectionStartLength;
                return l > this._bufferService.cols ? [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [Math.max(l, this.selectionEnd[0]), this.selectionEnd[1]];
              }
              return this.selectionEnd;
            }
          }
          areSelectionValuesReversed() {
            const l = this.selectionStart, c = this.selectionEnd;
            return !(!l || !c) && (l[1] > c[1] || l[1] === c[1] && l[0] > c[0]);
          }
          handleTrim(l) {
            return this.selectionStart && (this.selectionStart[1] -= l), this.selectionEnd && (this.selectionEnd[1] -= l), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1);
          }
        };
      }, 428: function(o, a, l) {
        var c = this && this.__decorate || function(d, O, p, m) {
          var _, b = arguments.length, w = b < 3 ? O : m === null ? m = Object.getOwnPropertyDescriptor(O, p) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(d, O, p, m);
          else for (var x = d.length - 1; x >= 0; x--) (_ = d[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(O, p, w) : _(O, p)) || w);
          return b > 3 && w && Object.defineProperty(O, p, w), w;
        }, h = this && this.__param || function(d, O) {
          return function(p, m) {
            O(p, m, d);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CharSizeService = void 0;
        const f = l(2585), u = l(8460), g = l(844);
        let S = a.CharSizeService = class extends g.Disposable {
          get hasValidSize() {
            return this.width > 0 && this.height > 0;
          }
          constructor(d, O, p) {
            super(), this._optionsService = p, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new u.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new v(d, O, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
          }
          measure() {
            const d = this._measureStrategy.measure();
            d.width === this.width && d.height === this.height || (this.width = d.width, this.height = d.height, this._onCharSizeChange.fire());
          }
        };
        a.CharSizeService = S = c([h(2, f.IOptionsService)], S);
        class v {
          constructor(O, p, m) {
            this._document = O, this._parentElement = p, this._optionsService = m, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
          }
          measure() {
            this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
            const O = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) };
            return O.width !== 0 && O.height !== 0 && (this._result.width = O.width / 32, this._result.height = Math.ceil(O.height)), this._result;
          }
        }
      }, 4269: function(o, a, l) {
        var c = this && this.__decorate || function(O, p, m, _) {
          var b, w = arguments.length, x = w < 3 ? p : _ === null ? _ = Object.getOwnPropertyDescriptor(p, m) : _;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(O, p, m, _);
          else for (var y = O.length - 1; y >= 0; y--) (b = O[y]) && (x = (w < 3 ? b(x) : w > 3 ? b(p, m, x) : b(p, m)) || x);
          return w > 3 && x && Object.defineProperty(p, m, x), x;
        }, h = this && this.__param || function(O, p) {
          return function(m, _) {
            p(m, _, O);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CharacterJoinerService = a.JoinedCellData = void 0;
        const f = l(3734), u = l(643), g = l(511), S = l(2585);
        class v extends f.AttributeData {
          constructor(p, m, _) {
            super(), this.content = 0, this.combinedData = "", this.fg = p.fg, this.bg = p.bg, this.combinedData = m, this._width = _;
          }
          isCombined() {
            return 2097152;
          }
          getWidth() {
            return this._width;
          }
          getChars() {
            return this.combinedData;
          }
          getCode() {
            return 2097151;
          }
          setFromCharData(p) {
            throw new Error("not implemented");
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        a.JoinedCellData = v;
        let d = a.CharacterJoinerService = class Py {
          constructor(p) {
            this._bufferService = p, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new g.CellData();
          }
          register(p) {
            const m = { id: this._nextCharacterJoinerId++, handler: p };
            return this._characterJoiners.push(m), m.id;
          }
          deregister(p) {
            for (let m = 0; m < this._characterJoiners.length; m++) if (this._characterJoiners[m].id === p) return this._characterJoiners.splice(m, 1), !0;
            return !1;
          }
          getJoinedCharacters(p) {
            if (this._characterJoiners.length === 0) return [];
            const m = this._bufferService.buffer.lines.get(p);
            if (!m || m.length === 0) return [];
            const _ = [], b = m.translateToString(!0);
            let w = 0, x = 0, y = 0, k = m.getFg(0), T = m.getBg(0);
            for (let R = 0; R < m.getTrimmedLength(); R++) if (m.loadCell(R, this._workCell), this._workCell.getWidth() !== 0) {
              if (this._workCell.fg !== k || this._workCell.bg !== T) {
                if (R - w > 1) {
                  const $ = this._getJoinedRanges(b, y, x, m, w);
                  for (let E = 0; E < $.length; E++) _.push($[E]);
                }
                w = R, y = x, k = this._workCell.fg, T = this._workCell.bg;
              }
              x += this._workCell.getChars().length || u.WHITESPACE_CELL_CHAR.length;
            }
            if (this._bufferService.cols - w > 1) {
              const R = this._getJoinedRanges(b, y, x, m, w);
              for (let $ = 0; $ < R.length; $++) _.push(R[$]);
            }
            return _;
          }
          _getJoinedRanges(p, m, _, b, w) {
            const x = p.substring(m, _);
            let y = [];
            try {
              y = this._characterJoiners[0].handler(x);
            } catch (k) {
              console.error(k);
            }
            for (let k = 1; k < this._characterJoiners.length; k++) try {
              const T = this._characterJoiners[k].handler(x);
              for (let R = 0; R < T.length; R++) Py._mergeRanges(y, T[R]);
            } catch (T) {
              console.error(T);
            }
            return this._stringRangesToCellRanges(y, b, w), y;
          }
          _stringRangesToCellRanges(p, m, _) {
            let b = 0, w = !1, x = 0, y = p[b];
            if (y) {
              for (let k = _; k < this._bufferService.cols; k++) {
                const T = m.getWidth(k), R = m.getString(k).length || u.WHITESPACE_CELL_CHAR.length;
                if (T !== 0) {
                  if (!w && y[0] <= x && (y[0] = k, w = !0), y[1] <= x) {
                    if (y[1] = k, y = p[++b], !y) break;
                    y[0] <= x ? (y[0] = k, w = !0) : w = !1;
                  }
                  x += R;
                }
              }
              y && (y[1] = this._bufferService.cols);
            }
          }
          static _mergeRanges(p, m) {
            let _ = !1;
            for (let b = 0; b < p.length; b++) {
              const w = p[b];
              if (_) {
                if (m[1] <= w[0]) return p[b - 1][1] = m[1], p;
                if (m[1] <= w[1]) return p[b - 1][1] = Math.max(m[1], w[1]), p.splice(b, 1), p;
                p.splice(b, 1), b--;
              } else {
                if (m[1] <= w[0]) return p.splice(b, 0, m), p;
                if (m[1] <= w[1]) return w[0] = Math.min(m[0], w[0]), p;
                m[0] < w[1] && (w[0] = Math.min(m[0], w[0]), _ = !0);
              }
            }
            return _ ? p[p.length - 1][1] = m[1] : p.push(m), p;
          }
        };
        a.CharacterJoinerService = d = c([h(0, S.IBufferService)], d);
      }, 5114: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreBrowserService = void 0, a.CoreBrowserService = class {
          constructor(l, c) {
            this._textarea = l, this.window = c, this._isFocused = !1, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = !0), this._textarea.addEventListener("blur", () => this._isFocused = !1);
          }
          get dpr() {
            return this.window.devicePixelRatio;
          }
          get isFocused() {
            return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
          }
        };
      }, 8934: function(o, a, l) {
        var c = this && this.__decorate || function(S, v, d, O) {
          var p, m = arguments.length, _ = m < 3 ? v : O === null ? O = Object.getOwnPropertyDescriptor(v, d) : O;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") _ = Reflect.decorate(S, v, d, O);
          else for (var b = S.length - 1; b >= 0; b--) (p = S[b]) && (_ = (m < 3 ? p(_) : m > 3 ? p(v, d, _) : p(v, d)) || _);
          return m > 3 && _ && Object.defineProperty(v, d, _), _;
        }, h = this && this.__param || function(S, v) {
          return function(d, O) {
            v(d, O, S);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.MouseService = void 0;
        const f = l(4725), u = l(9806);
        let g = a.MouseService = class {
          constructor(S, v) {
            this._renderService = S, this._charSizeService = v;
          }
          getCoords(S, v, d, O, p) {
            return (0, u.getCoords)(window, S, v, d, O, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, p);
          }
          getMouseReportCoords(S, v) {
            const d = (0, u.getCoordsRelativeToElement)(window, S, v);
            if (this._charSizeService.hasValidSize) return d[0] = Math.min(Math.max(d[0], 0), this._renderService.dimensions.css.canvas.width - 1), d[1] = Math.min(Math.max(d[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(d[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(d[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(d[0]), y: Math.floor(d[1]) };
          }
        };
        a.MouseService = g = c([h(0, f.IRenderService), h(1, f.ICharSizeService)], g);
      }, 3230: function(o, a, l) {
        var c = this && this.__decorate || function(_, b, w, x) {
          var y, k = arguments.length, T = k < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, w) : x;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(_, b, w, x);
          else for (var R = _.length - 1; R >= 0; R--) (y = _[R]) && (T = (k < 3 ? y(T) : k > 3 ? y(b, w, T) : y(b, w)) || T);
          return k > 3 && T && Object.defineProperty(b, w, T), T;
        }, h = this && this.__param || function(_, b) {
          return function(w, x) {
            b(w, x, _);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderService = void 0;
        const f = l(3656), u = l(6193), g = l(5596), S = l(4725), v = l(8460), d = l(844), O = l(7226), p = l(2585);
        let m = a.RenderService = class extends d.Disposable {
          get dimensions() {
            return this._renderer.value.dimensions;
          }
          constructor(_, b, w, x, y, k, T, R) {
            if (super(), this._rowCount = _, this._charSizeService = x, this._renderer = this.register(new d.MutableDisposable()), this._pausedResizeTask = new O.DebouncedIdleTask(), this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: !1 }, this._onDimensionsChange = this.register(new v.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new v.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new v.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new v.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new u.RenderDebouncer(T.window, ($, E) => this._renderRows($, E)), this.register(this._renderDebouncer), this._screenDprMonitor = new g.ScreenDprMonitor(T.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(k.onResize(() => this._fullRefresh())), this.register(k.buffers.onBufferActivate(() => {
              var $;
              return ($ = this._renderer.value) === null || $ === void 0 ? void 0 : $.clear();
            })), this.register(w.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(y.onDecorationRegistered(() => this._fullRefresh())), this.register(y.onDecorationRemoved(() => this._fullRefresh())), this.register(w.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
              this.clear(), this.handleResize(k.cols, k.rows), this._fullRefresh();
            })), this.register(w.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(k.buffer.y, k.buffer.y, !0))), this.register((0, f.addDisposableDomListener)(T.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(R.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in T.window) {
              const $ = new T.window.IntersectionObserver((E) => this._handleIntersectionChange(E[E.length - 1]), { threshold: 0 });
              $.observe(b), this.register({ dispose: () => $.disconnect() });
            }
          }
          _handleIntersectionChange(_) {
            this._isPaused = _.isIntersecting === void 0 ? _.intersectionRatio === 0 : !_.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1);
          }
          refreshRows(_, b, w = !1) {
            this._isPaused ? this._needsFullRefresh = !0 : (w || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(_, b, this._rowCount));
          }
          _renderRows(_, b) {
            this._renderer.value && (_ = Math.min(_, this._rowCount - 1), b = Math.min(b, this._rowCount - 1), this._renderer.value.renderRows(_, b), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: _, end: b }), this._onRender.fire({ start: _, end: b }), this._isNextRenderRedrawOnly = !0);
          }
          resize(_, b) {
            this._rowCount = b, this._fireOnCanvasResize();
          }
          _handleOptionsChanged() {
            this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
          }
          _fireOnCanvasResize() {
            this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
          }
          hasRenderer() {
            return !!this._renderer.value;
          }
          setRenderer(_) {
            this._renderer.value = _, this._renderer.value.onRequestRedraw((b) => this.refreshRows(b.start, b.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh();
          }
          addRefreshCallback(_) {
            return this._renderDebouncer.addRefreshCallback(_);
          }
          _fullRefresh() {
            this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1);
          }
          clearTextureAtlas() {
            var _, b;
            this._renderer.value && ((b = (_ = this._renderer.value).clearTextureAtlas) === null || b === void 0 || b.call(_), this._fullRefresh());
          }
          handleDevicePixelRatioChange() {
            this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
          }
          handleResize(_, b) {
            this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(_, b)) : this._renderer.value.handleResize(_, b), this._fullRefresh());
          }
          handleCharSizeChanged() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleCharSizeChanged();
          }
          handleBlur() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleBlur();
          }
          handleFocus() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleFocus();
          }
          handleSelectionChanged(_, b, w) {
            var x;
            this._selectionState.start = _, this._selectionState.end = b, this._selectionState.columnSelectMode = w, (x = this._renderer.value) === null || x === void 0 || x.handleSelectionChanged(_, b, w);
          }
          handleCursorMove() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.handleCursorMove();
          }
          clear() {
            var _;
            (_ = this._renderer.value) === null || _ === void 0 || _.clear();
          }
        };
        a.RenderService = m = c([h(2, p.IOptionsService), h(3, S.ICharSizeService), h(4, p.IDecorationService), h(5, p.IBufferService), h(6, S.ICoreBrowserService), h(7, S.IThemeService)], m);
      }, 9312: function(o, a, l) {
        var c = this && this.__decorate || function(y, k, T, R) {
          var $, E = arguments.length, D = E < 3 ? k : R === null ? R = Object.getOwnPropertyDescriptor(k, T) : R;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") D = Reflect.decorate(y, k, T, R);
          else for (var q = y.length - 1; q >= 0; q--) ($ = y[q]) && (D = (E < 3 ? $(D) : E > 3 ? $(k, T, D) : $(k, T)) || D);
          return E > 3 && D && Object.defineProperty(k, T, D), D;
        }, h = this && this.__param || function(y, k) {
          return function(T, R) {
            k(T, R, y);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionService = void 0;
        const f = l(9806), u = l(9504), g = l(456), S = l(4725), v = l(8460), d = l(844), O = l(6114), p = l(4841), m = l(511), _ = l(2585), b = " ", w = new RegExp(b, "g");
        let x = a.SelectionService = class extends d.Disposable {
          constructor(y, k, T, R, $, E, D, q, W) {
            super(), this._element = y, this._screenElement = k, this._linkifier = T, this._bufferService = R, this._coreService = $, this._mouseService = E, this._optionsService = D, this._renderService = q, this._coreBrowserService = W, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new m.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new v.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new v.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new v.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new v.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (z) => this._handleMouseMove(z), this._mouseUpListener = (z) => this._handleMouseUp(z), this._coreService.onUserInput(() => {
              this.hasSelection && this.clearSelection();
            }), this._trimListener = this._bufferService.buffer.lines.onTrim((z) => this._handleTrim(z)), this.register(this._bufferService.buffers.onBufferActivate((z) => this._handleBufferActivate(z))), this.enable(), this._model = new g.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, d.toDisposable)(() => {
              this._removeMouseDownListeners();
            }));
          }
          reset() {
            this.clearSelection();
          }
          disable() {
            this.clearSelection(), this._enabled = !1;
          }
          enable() {
            this._enabled = !0;
          }
          get selectionStart() {
            return this._model.finalSelectionStart;
          }
          get selectionEnd() {
            return this._model.finalSelectionEnd;
          }
          get hasSelection() {
            const y = this._model.finalSelectionStart, k = this._model.finalSelectionEnd;
            return !(!y || !k || y[0] === k[0] && y[1] === k[1]);
          }
          get selectionText() {
            const y = this._model.finalSelectionStart, k = this._model.finalSelectionEnd;
            if (!y || !k) return "";
            const T = this._bufferService.buffer, R = [];
            if (this._activeSelectionMode === 3) {
              if (y[0] === k[0]) return "";
              const $ = y[0] < k[0] ? y[0] : k[0], E = y[0] < k[0] ? k[0] : y[0];
              for (let D = y[1]; D <= k[1]; D++) {
                const q = T.translateBufferLineToString(D, !0, $, E);
                R.push(q);
              }
            } else {
              const $ = y[1] === k[1] ? k[0] : void 0;
              R.push(T.translateBufferLineToString(y[1], !0, y[0], $));
              for (let E = y[1] + 1; E <= k[1] - 1; E++) {
                const D = T.lines.get(E), q = T.translateBufferLineToString(E, !0);
                D?.isWrapped ? R[R.length - 1] += q : R.push(q);
              }
              if (y[1] !== k[1]) {
                const E = T.lines.get(k[1]), D = T.translateBufferLineToString(k[1], !0, 0, k[0]);
                E && E.isWrapped ? R[R.length - 1] += D : R.push(D);
              }
            }
            return R.map(($) => $.replace(w, " ")).join(O.isWindows ? `\r
` : `
`);
          }
          clearSelection() {
            this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
          }
          refresh(y) {
            this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), O.isLinux && y && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
          }
          _refresh() {
            this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 });
          }
          _isClickInSelection(y) {
            const k = this._getMouseBufferCoords(y), T = this._model.finalSelectionStart, R = this._model.finalSelectionEnd;
            return !!(T && R && k) && this._areCoordsInSelection(k, T, R);
          }
          isCellInSelection(y, k) {
            const T = this._model.finalSelectionStart, R = this._model.finalSelectionEnd;
            return !(!T || !R) && this._areCoordsInSelection([y, k], T, R);
          }
          _areCoordsInSelection(y, k, T) {
            return y[1] > k[1] && y[1] < T[1] || k[1] === T[1] && y[1] === k[1] && y[0] >= k[0] && y[0] < T[0] || k[1] < T[1] && y[1] === T[1] && y[0] < T[0] || k[1] < T[1] && y[1] === k[1] && y[0] >= k[0];
          }
          _selectWordAtCursor(y, k) {
            var T, R;
            const $ = (R = (T = this._linkifier.currentLink) === null || T === void 0 ? void 0 : T.link) === null || R === void 0 ? void 0 : R.range;
            if ($) return this._model.selectionStart = [$.start.x - 1, $.start.y - 1], this._model.selectionStartLength = (0, p.getRangeLength)($, this._bufferService.cols), this._model.selectionEnd = void 0, !0;
            const E = this._getMouseBufferCoords(y);
            return !!E && (this._selectWordAt(E, k), this._model.selectionEnd = void 0, !0);
          }
          selectAll() {
            this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire();
          }
          selectLines(y, k) {
            this._model.clearSelection(), y = Math.max(y, 0), k = Math.min(k, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, y], this._model.selectionEnd = [this._bufferService.cols, k], this.refresh(), this._onSelectionChange.fire();
          }
          _handleTrim(y) {
            this._model.handleTrim(y) && this.refresh();
          }
          _getMouseBufferCoords(y) {
            const k = this._mouseService.getCoords(y, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);
            if (k) return k[0]--, k[1]--, k[1] += this._bufferService.buffer.ydisp, k;
          }
          _getMouseEventScrollAmount(y) {
            let k = (0, f.getCoordsRelativeToElement)(this._coreBrowserService.window, y, this._screenElement)[1];
            const T = this._renderService.dimensions.css.canvas.height;
            return k >= 0 && k <= T ? 0 : (k > T && (k -= T), k = Math.min(Math.max(k, -50), 50), k /= 50, k / Math.abs(k) + Math.round(14 * k));
          }
          shouldForceSelection(y) {
            return O.isMac ? y.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : y.shiftKey;
          }
          handleMouseDown(y) {
            if (this._mouseDownTimeStamp = y.timeStamp, (y.button !== 2 || !this.hasSelection) && y.button === 0) {
              if (!this._enabled) {
                if (!this.shouldForceSelection(y)) return;
                y.stopPropagation();
              }
              y.preventDefault(), this._dragScrollAmount = 0, this._enabled && y.shiftKey ? this._handleIncrementalClick(y) : y.detail === 1 ? this._handleSingleClick(y) : y.detail === 2 ? this._handleDoubleClick(y) : y.detail === 3 && this._handleTripleClick(y), this._addMouseDownListeners(), this.refresh(!0);
            }
          }
          _addMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
          }
          _removeMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
          }
          _handleIncrementalClick(y) {
            this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(y));
          }
          _handleSingleClick(y) {
            if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(y) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(y), !this._model.selectionStart) return;
            this._model.selectionEnd = void 0;
            const k = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
            k && k.length !== this._model.selectionStart[0] && k.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++;
          }
          _handleDoubleClick(y) {
            this._selectWordAtCursor(y, !0) && (this._activeSelectionMode = 1);
          }
          _handleTripleClick(y) {
            const k = this._getMouseBufferCoords(y);
            k && (this._activeSelectionMode = 2, this._selectLineAt(k[1]));
          }
          shouldColumnSelect(y) {
            return y.altKey && !(O.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
          }
          _handleMouseMove(y) {
            if (y.stopImmediatePropagation(), !this._model.selectionStart) return;
            const k = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
            if (this._model.selectionEnd = this._getMouseBufferCoords(y), !this._model.selectionEnd) return void this.refresh(!0);
            this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(y), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
            const T = this._bufferService.buffer;
            if (this._model.selectionEnd[1] < T.lines.length) {
              const R = T.lines.get(this._model.selectionEnd[1]);
              R && R.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0]++;
            }
            k && k[0] === this._model.selectionEnd[0] && k[1] === this._model.selectionEnd[1] || this.refresh(!0);
          }
          _dragScroll() {
            if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
              this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: !1 });
              const y = this._bufferService.buffer;
              this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(y.ydisp + this._bufferService.rows, y.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = y.ydisp), this.refresh();
            }
          }
          _handleMouseUp(y) {
            const k = y.timeStamp - this._mouseDownTimeStamp;
            if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && k < 500 && y.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
              if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                const T = this._mouseService.getCoords(y, this._element, this._bufferService.cols, this._bufferService.rows, !1);
                if (T && T[0] !== void 0 && T[1] !== void 0) {
                  const R = (0, u.moveToCellSequence)(T[0] - 1, T[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                  this._coreService.triggerDataEvent(R, !0);
                }
              }
            } else this._fireEventIfSelectionChanged();
          }
          _fireEventIfSelectionChanged() {
            const y = this._model.finalSelectionStart, k = this._model.finalSelectionEnd, T = !(!y || !k || y[0] === k[0] && y[1] === k[1]);
            T ? y && k && (this._oldSelectionStart && this._oldSelectionEnd && y[0] === this._oldSelectionStart[0] && y[1] === this._oldSelectionStart[1] && k[0] === this._oldSelectionEnd[0] && k[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(y, k, T)) : this._oldHasSelection && this._fireOnSelectionChange(y, k, T);
          }
          _fireOnSelectionChange(y, k, T) {
            this._oldSelectionStart = y, this._oldSelectionEnd = k, this._oldHasSelection = T, this._onSelectionChange.fire();
          }
          _handleBufferActivate(y) {
            this.clearSelection(), this._trimListener.dispose(), this._trimListener = y.activeBuffer.lines.onTrim((k) => this._handleTrim(k));
          }
          _convertViewportColToCharacterIndex(y, k) {
            let T = k;
            for (let R = 0; k >= R; R++) {
              const $ = y.loadCell(R, this._workCell).getChars().length;
              this._workCell.getWidth() === 0 ? T-- : $ > 1 && k !== R && (T += $ - 1);
            }
            return T;
          }
          setSelection(y, k, T) {
            this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [y, k], this._model.selectionStartLength = T, this.refresh(), this._fireEventIfSelectionChanged();
          }
          rightClickSelect(y) {
            this._isClickInSelection(y) || (this._selectWordAtCursor(y, !1) && this.refresh(!0), this._fireEventIfSelectionChanged());
          }
          _getWordAt(y, k, T = !0, R = !0) {
            if (y[0] >= this._bufferService.cols) return;
            const $ = this._bufferService.buffer, E = $.lines.get(y[1]);
            if (!E) return;
            const D = $.translateBufferLineToString(y[1], !1);
            let q = this._convertViewportColToCharacterIndex(E, y[0]), W = q;
            const z = y[0] - q;
            let Q = 0, A = 0, L = 0, M = 0;
            if (D.charAt(q) === " ") {
              for (; q > 0 && D.charAt(q - 1) === " "; ) q--;
              for (; W < D.length && D.charAt(W + 1) === " "; ) W++;
            } else {
              let ne = y[0], te = y[0];
              E.getWidth(ne) === 0 && (Q++, ne--), E.getWidth(te) === 2 && (A++, te++);
              const de = E.getString(te).length;
              for (de > 1 && (M += de - 1, W += de - 1); ne > 0 && q > 0 && !this._isCharWordSeparator(E.loadCell(ne - 1, this._workCell)); ) {
                E.loadCell(ne - 1, this._workCell);
                const P = this._workCell.getChars().length;
                this._workCell.getWidth() === 0 ? (Q++, ne--) : P > 1 && (L += P - 1, q -= P - 1), q--, ne--;
              }
              for (; te < E.length && W + 1 < D.length && !this._isCharWordSeparator(E.loadCell(te + 1, this._workCell)); ) {
                E.loadCell(te + 1, this._workCell);
                const P = this._workCell.getChars().length;
                this._workCell.getWidth() === 2 ? (A++, te++) : P > 1 && (M += P - 1, W += P - 1), W++, te++;
              }
            }
            W++;
            let U = q + z - Q + L, F = Math.min(this._bufferService.cols, W - q + Q + A - L - M);
            if (k || D.slice(q, W).trim() !== "") {
              if (T && U === 0 && E.getCodePoint(0) !== 32) {
                const ne = $.lines.get(y[1] - 1);
                if (ne && E.isWrapped && ne.getCodePoint(this._bufferService.cols - 1) !== 32) {
                  const te = this._getWordAt([this._bufferService.cols - 1, y[1] - 1], !1, !0, !1);
                  if (te) {
                    const de = this._bufferService.cols - te.start;
                    U -= de, F += de;
                  }
                }
              }
              if (R && U + F === this._bufferService.cols && E.getCodePoint(this._bufferService.cols - 1) !== 32) {
                const ne = $.lines.get(y[1] + 1);
                if (ne?.isWrapped && ne.getCodePoint(0) !== 32) {
                  const te = this._getWordAt([0, y[1] + 1], !1, !1, !0);
                  te && (F += te.length);
                }
              }
              return { start: U, length: F };
            }
          }
          _selectWordAt(y, k) {
            const T = this._getWordAt(y, k);
            if (T) {
              for (; T.start < 0; ) T.start += this._bufferService.cols, y[1]--;
              this._model.selectionStart = [T.start, y[1]], this._model.selectionStartLength = T.length;
            }
          }
          _selectToWordAt(y) {
            const k = this._getWordAt(y, !0);
            if (k) {
              let T = y[1];
              for (; k.start < 0; ) k.start += this._bufferService.cols, T--;
              if (!this._model.areSelectionValuesReversed()) for (; k.start + k.length > this._bufferService.cols; ) k.length -= this._bufferService.cols, T++;
              this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? k.start : k.start + k.length, T];
            }
          }
          _isCharWordSeparator(y) {
            return y.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(y.getChars()) >= 0;
          }
          _selectLineAt(y) {
            const k = this._bufferService.buffer.getWrappedRangeForLine(y), T = { start: { x: 0, y: k.first }, end: { x: this._bufferService.cols - 1, y: k.last } };
            this._model.selectionStart = [0, k.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, p.getRangeLength)(T, this._bufferService.cols);
          }
        };
        a.SelectionService = x = c([h(3, _.IBufferService), h(4, _.ICoreService), h(5, S.IMouseService), h(6, _.IOptionsService), h(7, S.IRenderService), h(8, S.ICoreBrowserService)], x);
      }, 4725: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.IThemeService = a.ICharacterJoinerService = a.ISelectionService = a.IRenderService = a.IMouseService = a.ICoreBrowserService = a.ICharSizeService = void 0;
        const c = l(8343);
        a.ICharSizeService = (0, c.createDecorator)("CharSizeService"), a.ICoreBrowserService = (0, c.createDecorator)("CoreBrowserService"), a.IMouseService = (0, c.createDecorator)("MouseService"), a.IRenderService = (0, c.createDecorator)("RenderService"), a.ISelectionService = (0, c.createDecorator)("SelectionService"), a.ICharacterJoinerService = (0, c.createDecorator)("CharacterJoinerService"), a.IThemeService = (0, c.createDecorator)("ThemeService");
      }, 6731: function(o, a, l) {
        var c = this && this.__decorate || function(x, y, k, T) {
          var R, $ = arguments.length, E = $ < 3 ? y : T === null ? T = Object.getOwnPropertyDescriptor(y, k) : T;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") E = Reflect.decorate(x, y, k, T);
          else for (var D = x.length - 1; D >= 0; D--) (R = x[D]) && (E = ($ < 3 ? R(E) : $ > 3 ? R(y, k, E) : R(y, k)) || E);
          return $ > 3 && E && Object.defineProperty(y, k, E), E;
        }, h = this && this.__param || function(x, y) {
          return function(k, T) {
            y(k, T, x);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ThemeService = a.DEFAULT_ANSI_COLORS = void 0;
        const f = l(7239), u = l(8055), g = l(8460), S = l(844), v = l(2585), d = u.css.toColor("#ffffff"), O = u.css.toColor("#000000"), p = u.css.toColor("#ffffff"), m = u.css.toColor("#000000"), _ = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
        a.DEFAULT_ANSI_COLORS = Object.freeze((() => {
          const x = [u.css.toColor("#2e3436"), u.css.toColor("#cc0000"), u.css.toColor("#4e9a06"), u.css.toColor("#c4a000"), u.css.toColor("#3465a4"), u.css.toColor("#75507b"), u.css.toColor("#06989a"), u.css.toColor("#d3d7cf"), u.css.toColor("#555753"), u.css.toColor("#ef2929"), u.css.toColor("#8ae234"), u.css.toColor("#fce94f"), u.css.toColor("#729fcf"), u.css.toColor("#ad7fa8"), u.css.toColor("#34e2e2"), u.css.toColor("#eeeeec")], y = [0, 95, 135, 175, 215, 255];
          for (let k = 0; k < 216; k++) {
            const T = y[k / 36 % 6 | 0], R = y[k / 6 % 6 | 0], $ = y[k % 6];
            x.push({ css: u.channels.toCss(T, R, $), rgba: u.channels.toRgba(T, R, $) });
          }
          for (let k = 0; k < 24; k++) {
            const T = 8 + 10 * k;
            x.push({ css: u.channels.toCss(T, T, T), rgba: u.channels.toRgba(T, T, T) });
          }
          return x;
        })());
        let b = a.ThemeService = class extends S.Disposable {
          get colors() {
            return this._colors;
          }
          constructor(x) {
            super(), this._optionsService = x, this._contrastCache = new f.ColorContrastCache(), this._halfContrastCache = new f.ColorContrastCache(), this._onChangeColors = this.register(new g.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: d, background: O, cursor: p, cursorAccent: m, selectionForeground: void 0, selectionBackgroundTransparent: _, selectionBackgroundOpaque: u.color.blend(O, _), selectionInactiveBackgroundTransparent: _, selectionInactiveBackgroundOpaque: u.color.blend(O, _), ansi: a.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
          }
          _setTheme(x = {}) {
            const y = this._colors;
            if (y.foreground = w(x.foreground, d), y.background = w(x.background, O), y.cursor = w(x.cursor, p), y.cursorAccent = w(x.cursorAccent, m), y.selectionBackgroundTransparent = w(x.selectionBackground, _), y.selectionBackgroundOpaque = u.color.blend(y.background, y.selectionBackgroundTransparent), y.selectionInactiveBackgroundTransparent = w(x.selectionInactiveBackground, y.selectionBackgroundTransparent), y.selectionInactiveBackgroundOpaque = u.color.blend(y.background, y.selectionInactiveBackgroundTransparent), y.selectionForeground = x.selectionForeground ? w(x.selectionForeground, u.NULL_COLOR) : void 0, y.selectionForeground === u.NULL_COLOR && (y.selectionForeground = void 0), u.color.isOpaque(y.selectionBackgroundTransparent) && (y.selectionBackgroundTransparent = u.color.opacity(y.selectionBackgroundTransparent, 0.3)), u.color.isOpaque(y.selectionInactiveBackgroundTransparent) && (y.selectionInactiveBackgroundTransparent = u.color.opacity(y.selectionInactiveBackgroundTransparent, 0.3)), y.ansi = a.DEFAULT_ANSI_COLORS.slice(), y.ansi[0] = w(x.black, a.DEFAULT_ANSI_COLORS[0]), y.ansi[1] = w(x.red, a.DEFAULT_ANSI_COLORS[1]), y.ansi[2] = w(x.green, a.DEFAULT_ANSI_COLORS[2]), y.ansi[3] = w(x.yellow, a.DEFAULT_ANSI_COLORS[3]), y.ansi[4] = w(x.blue, a.DEFAULT_ANSI_COLORS[4]), y.ansi[5] = w(x.magenta, a.DEFAULT_ANSI_COLORS[5]), y.ansi[6] = w(x.cyan, a.DEFAULT_ANSI_COLORS[6]), y.ansi[7] = w(x.white, a.DEFAULT_ANSI_COLORS[7]), y.ansi[8] = w(x.brightBlack, a.DEFAULT_ANSI_COLORS[8]), y.ansi[9] = w(x.brightRed, a.DEFAULT_ANSI_COLORS[9]), y.ansi[10] = w(x.brightGreen, a.DEFAULT_ANSI_COLORS[10]), y.ansi[11] = w(x.brightYellow, a.DEFAULT_ANSI_COLORS[11]), y.ansi[12] = w(x.brightBlue, a.DEFAULT_ANSI_COLORS[12]), y.ansi[13] = w(x.brightMagenta, a.DEFAULT_ANSI_COLORS[13]), y.ansi[14] = w(x.brightCyan, a.DEFAULT_ANSI_COLORS[14]), y.ansi[15] = w(x.brightWhite, a.DEFAULT_ANSI_COLORS[15]), x.extendedAnsi) {
              const k = Math.min(y.ansi.length - 16, x.extendedAnsi.length);
              for (let T = 0; T < k; T++) y.ansi[T + 16] = w(x.extendedAnsi[T], a.DEFAULT_ANSI_COLORS[T + 16]);
            }
            this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
          }
          restoreColor(x) {
            this._restoreColor(x), this._onChangeColors.fire(this.colors);
          }
          _restoreColor(x) {
            if (x !== void 0) switch (x) {
              case 256:
                this._colors.foreground = this._restoreColors.foreground;
                break;
              case 257:
                this._colors.background = this._restoreColors.background;
                break;
              case 258:
                this._colors.cursor = this._restoreColors.cursor;
                break;
              default:
                this._colors.ansi[x] = this._restoreColors.ansi[x];
            }
            else for (let y = 0; y < this._restoreColors.ansi.length; ++y) this._colors.ansi[y] = this._restoreColors.ansi[y];
          }
          modifyColors(x) {
            x(this._colors), this._onChangeColors.fire(this.colors);
          }
          _updateRestoreColors() {
            this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
          }
        };
        function w(x, y) {
          if (x !== void 0) try {
            return u.css.toColor(x);
          } catch {
          }
          return y;
        }
        a.ThemeService = b = c([h(0, v.IOptionsService)], b);
      }, 6349: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CircularList = void 0;
        const c = l(8460), h = l(844);
        class f extends h.Disposable {
          constructor(g) {
            super(), this._maxLength = g, this.onDeleteEmitter = this.register(new c.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new c.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new c.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
          }
          get maxLength() {
            return this._maxLength;
          }
          set maxLength(g) {
            if (this._maxLength === g) return;
            const S = new Array(g);
            for (let v = 0; v < Math.min(g, this.length); v++) S[v] = this._array[this._getCyclicIndex(v)];
            this._array = S, this._maxLength = g, this._startIndex = 0;
          }
          get length() {
            return this._length;
          }
          set length(g) {
            if (g > this._length) for (let S = this._length; S < g; S++) this._array[S] = void 0;
            this._length = g;
          }
          get(g) {
            return this._array[this._getCyclicIndex(g)];
          }
          set(g, S) {
            this._array[this._getCyclicIndex(g)] = S;
          }
          push(g) {
            this._array[this._getCyclicIndex(this._length)] = g, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
          }
          recycle() {
            if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
            return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
          }
          get isFull() {
            return this._length === this._maxLength;
          }
          pop() {
            return this._array[this._getCyclicIndex(this._length-- - 1)];
          }
          splice(g, S, ...v) {
            if (S) {
              for (let d = g; d < this._length - S; d++) this._array[this._getCyclicIndex(d)] = this._array[this._getCyclicIndex(d + S)];
              this._length -= S, this.onDeleteEmitter.fire({ index: g, amount: S });
            }
            for (let d = this._length - 1; d >= g; d--) this._array[this._getCyclicIndex(d + v.length)] = this._array[this._getCyclicIndex(d)];
            for (let d = 0; d < v.length; d++) this._array[this._getCyclicIndex(g + d)] = v[d];
            if (v.length && this.onInsertEmitter.fire({ index: g, amount: v.length }), this._length + v.length > this._maxLength) {
              const d = this._length + v.length - this._maxLength;
              this._startIndex += d, this._length = this._maxLength, this.onTrimEmitter.fire(d);
            } else this._length += v.length;
          }
          trimStart(g) {
            g > this._length && (g = this._length), this._startIndex += g, this._length -= g, this.onTrimEmitter.fire(g);
          }
          shiftElements(g, S, v) {
            if (!(S <= 0)) {
              if (g < 0 || g >= this._length) throw new Error("start argument out of range");
              if (g + v < 0) throw new Error("Cannot shift elements in list beyond index 0");
              if (v > 0) {
                for (let O = S - 1; O >= 0; O--) this.set(g + O + v, this.get(g + O));
                const d = g + S + v - this._length;
                if (d > 0) for (this._length += d; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
              } else for (let d = 0; d < S; d++) this.set(g + d + v, this.get(g + d));
            }
          }
          _getCyclicIndex(g) {
            return (this._startIndex + g) % this._maxLength;
          }
        }
        a.CircularList = f;
      }, 1439: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.clone = void 0, a.clone = function l(c, h = 5) {
          if (typeof c != "object") return c;
          const f = Array.isArray(c) ? [] : {};
          for (const u in c) f[u] = h <= 1 ? c[u] : c[u] && l(c[u], h - 1);
          return f;
        };
      }, 8055: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.contrastRatio = a.toPaddedHex = a.rgba = a.rgb = a.css = a.color = a.channels = a.NULL_COLOR = void 0;
        const c = l(6114);
        let h = 0, f = 0, u = 0, g = 0;
        var S, v, d, O, p;
        function m(b) {
          const w = b.toString(16);
          return w.length < 2 ? "0" + w : w;
        }
        function _(b, w) {
          return b < w ? (w + 0.05) / (b + 0.05) : (b + 0.05) / (w + 0.05);
        }
        a.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(b) {
          b.toCss = function(w, x, y, k) {
            return k !== void 0 ? `#${m(w)}${m(x)}${m(y)}${m(k)}` : `#${m(w)}${m(x)}${m(y)}`;
          }, b.toRgba = function(w, x, y, k = 255) {
            return (w << 24 | x << 16 | y << 8 | k) >>> 0;
          };
        }(S || (a.channels = S = {})), function(b) {
          function w(x, y) {
            return g = Math.round(255 * y), [h, f, u] = p.toChannels(x.rgba), { css: S.toCss(h, f, u, g), rgba: S.toRgba(h, f, u, g) };
          }
          b.blend = function(x, y) {
            if (g = (255 & y.rgba) / 255, g === 1) return { css: y.css, rgba: y.rgba };
            const k = y.rgba >> 24 & 255, T = y.rgba >> 16 & 255, R = y.rgba >> 8 & 255, $ = x.rgba >> 24 & 255, E = x.rgba >> 16 & 255, D = x.rgba >> 8 & 255;
            return h = $ + Math.round((k - $) * g), f = E + Math.round((T - E) * g), u = D + Math.round((R - D) * g), { css: S.toCss(h, f, u), rgba: S.toRgba(h, f, u) };
          }, b.isOpaque = function(x) {
            return (255 & x.rgba) == 255;
          }, b.ensureContrastRatio = function(x, y, k) {
            const T = p.ensureContrastRatio(x.rgba, y.rgba, k);
            if (T) return p.toColor(T >> 24 & 255, T >> 16 & 255, T >> 8 & 255);
          }, b.opaque = function(x) {
            const y = (255 | x.rgba) >>> 0;
            return [h, f, u] = p.toChannels(y), { css: S.toCss(h, f, u), rgba: y };
          }, b.opacity = w, b.multiplyOpacity = function(x, y) {
            return g = 255 & x.rgba, w(x, g * y / 255);
          }, b.toColorRGB = function(x) {
            return [x.rgba >> 24 & 255, x.rgba >> 16 & 255, x.rgba >> 8 & 255];
          };
        }(v || (a.color = v = {})), function(b) {
          let w, x;
          if (!c.isNode) {
            const y = document.createElement("canvas");
            y.width = 1, y.height = 1;
            const k = y.getContext("2d", { willReadFrequently: !0 });
            k && (w = k, w.globalCompositeOperation = "copy", x = w.createLinearGradient(0, 0, 1, 1));
          }
          b.toColor = function(y) {
            if (y.match(/#[\da-f]{3,8}/i)) switch (y.length) {
              case 4:
                return h = parseInt(y.slice(1, 2).repeat(2), 16), f = parseInt(y.slice(2, 3).repeat(2), 16), u = parseInt(y.slice(3, 4).repeat(2), 16), p.toColor(h, f, u);
              case 5:
                return h = parseInt(y.slice(1, 2).repeat(2), 16), f = parseInt(y.slice(2, 3).repeat(2), 16), u = parseInt(y.slice(3, 4).repeat(2), 16), g = parseInt(y.slice(4, 5).repeat(2), 16), p.toColor(h, f, u, g);
              case 7:
                return { css: y, rgba: (parseInt(y.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: y, rgba: parseInt(y.slice(1), 16) >>> 0 };
            }
            const k = y.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
            if (k) return h = parseInt(k[1]), f = parseInt(k[2]), u = parseInt(k[3]), g = Math.round(255 * (k[5] === void 0 ? 1 : parseFloat(k[5]))), p.toColor(h, f, u, g);
            if (!w || !x) throw new Error("css.toColor: Unsupported css format");
            if (w.fillStyle = x, w.fillStyle = y, typeof w.fillStyle != "string") throw new Error("css.toColor: Unsupported css format");
            if (w.fillRect(0, 0, 1, 1), [h, f, u, g] = w.getImageData(0, 0, 1, 1).data, g !== 255) throw new Error("css.toColor: Unsupported css format");
            return { rgba: S.toRgba(h, f, u, g), css: y };
          };
        }(d || (a.css = d = {})), function(b) {
          function w(x, y, k) {
            const T = x / 255, R = y / 255, $ = k / 255;
            return 0.2126 * (T <= 0.03928 ? T / 12.92 : Math.pow((T + 0.055) / 1.055, 2.4)) + 0.7152 * (R <= 0.03928 ? R / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4)) + 0.0722 * ($ <= 0.03928 ? $ / 12.92 : Math.pow(($ + 0.055) / 1.055, 2.4));
          }
          b.relativeLuminance = function(x) {
            return w(x >> 16 & 255, x >> 8 & 255, 255 & x);
          }, b.relativeLuminance2 = w;
        }(O || (a.rgb = O = {})), function(b) {
          function w(y, k, T) {
            const R = y >> 24 & 255, $ = y >> 16 & 255, E = y >> 8 & 255;
            let D = k >> 24 & 255, q = k >> 16 & 255, W = k >> 8 & 255, z = _(O.relativeLuminance2(D, q, W), O.relativeLuminance2(R, $, E));
            for (; z < T && (D > 0 || q > 0 || W > 0); ) D -= Math.max(0, Math.ceil(0.1 * D)), q -= Math.max(0, Math.ceil(0.1 * q)), W -= Math.max(0, Math.ceil(0.1 * W)), z = _(O.relativeLuminance2(D, q, W), O.relativeLuminance2(R, $, E));
            return (D << 24 | q << 16 | W << 8 | 255) >>> 0;
          }
          function x(y, k, T) {
            const R = y >> 24 & 255, $ = y >> 16 & 255, E = y >> 8 & 255;
            let D = k >> 24 & 255, q = k >> 16 & 255, W = k >> 8 & 255, z = _(O.relativeLuminance2(D, q, W), O.relativeLuminance2(R, $, E));
            for (; z < T && (D < 255 || q < 255 || W < 255); ) D = Math.min(255, D + Math.ceil(0.1 * (255 - D))), q = Math.min(255, q + Math.ceil(0.1 * (255 - q))), W = Math.min(255, W + Math.ceil(0.1 * (255 - W))), z = _(O.relativeLuminance2(D, q, W), O.relativeLuminance2(R, $, E));
            return (D << 24 | q << 16 | W << 8 | 255) >>> 0;
          }
          b.ensureContrastRatio = function(y, k, T) {
            const R = O.relativeLuminance(y >> 8), $ = O.relativeLuminance(k >> 8);
            if (_(R, $) < T) {
              if ($ < R) {
                const q = w(y, k, T), W = _(R, O.relativeLuminance(q >> 8));
                if (W < T) {
                  const z = x(y, k, T);
                  return W > _(R, O.relativeLuminance(z >> 8)) ? q : z;
                }
                return q;
              }
              const E = x(y, k, T), D = _(R, O.relativeLuminance(E >> 8));
              if (D < T) {
                const q = w(y, k, T);
                return D > _(R, O.relativeLuminance(q >> 8)) ? E : q;
              }
              return E;
            }
          }, b.reduceLuminance = w, b.increaseLuminance = x, b.toChannels = function(y) {
            return [y >> 24 & 255, y >> 16 & 255, y >> 8 & 255, 255 & y];
          }, b.toColor = function(y, k, T, R) {
            return { css: S.toCss(y, k, T, R), rgba: S.toRgba(y, k, T, R) };
          };
        }(p || (a.rgba = p = {})), a.toPaddedHex = m, a.contrastRatio = _;
      }, 8969: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreTerminal = void 0;
        const c = l(844), h = l(2585), f = l(4348), u = l(7866), g = l(744), S = l(7302), v = l(6975), d = l(8460), O = l(1753), p = l(1480), m = l(7994), _ = l(9282), b = l(5435), w = l(5981), x = l(2660);
        let y = !1;
        class k extends c.Disposable {
          get onScroll() {
            return this._onScrollApi || (this._onScrollApi = this.register(new d.EventEmitter()), this._onScroll.event((R) => {
              var $;
              ($ = this._onScrollApi) === null || $ === void 0 || $.fire(R.position);
            })), this._onScrollApi.event;
          }
          get cols() {
            return this._bufferService.cols;
          }
          get rows() {
            return this._bufferService.rows;
          }
          get buffers() {
            return this._bufferService.buffers;
          }
          get options() {
            return this.optionsService.options;
          }
          set options(R) {
            for (const $ in R) this.optionsService.options[$] = R[$];
          }
          constructor(R) {
            super(), this._windowsWrappingHeuristics = this.register(new c.MutableDisposable()), this._onBinary = this.register(new d.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new d.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new d.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new d.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new d.EventEmitter()), this._instantiationService = new f.InstantiationService(), this.optionsService = this.register(new S.OptionsService(R)), this._instantiationService.setService(h.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(g.BufferService)), this._instantiationService.setService(h.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(u.LogService)), this._instantiationService.setService(h.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(v.CoreService)), this._instantiationService.setService(h.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(O.CoreMouseService)), this._instantiationService.setService(h.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(p.UnicodeService)), this._instantiationService.setService(h.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(m.CharsetService), this._instantiationService.setService(h.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(x.OscLinkService), this._instantiationService.setService(h.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new b.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, d.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, d.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, d.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, d.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll(($) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this.register(this._inputHandler.onScroll(($) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this._writeBuffer = this.register(new w.WriteBuffer(($, E) => this._inputHandler.parse($, E))), this.register((0, d.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
          }
          write(R, $) {
            this._writeBuffer.write(R, $);
          }
          writeSync(R, $) {
            this._logService.logLevel <= h.LogLevelEnum.WARN && !y && (this._logService.warn("writeSync is unreliable and will be removed soon."), y = !0), this._writeBuffer.writeSync(R, $);
          }
          resize(R, $) {
            isNaN(R) || isNaN($) || (R = Math.max(R, g.MINIMUM_COLS), $ = Math.max($, g.MINIMUM_ROWS), this._bufferService.resize(R, $));
          }
          scroll(R, $ = !1) {
            this._bufferService.scroll(R, $);
          }
          scrollLines(R, $, E) {
            this._bufferService.scrollLines(R, $, E);
          }
          scrollPages(R) {
            this.scrollLines(R * (this.rows - 1));
          }
          scrollToTop() {
            this.scrollLines(-this._bufferService.buffer.ydisp);
          }
          scrollToBottom() {
            this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          }
          scrollToLine(R) {
            const $ = R - this._bufferService.buffer.ydisp;
            $ !== 0 && this.scrollLines($);
          }
          registerEscHandler(R, $) {
            return this._inputHandler.registerEscHandler(R, $);
          }
          registerDcsHandler(R, $) {
            return this._inputHandler.registerDcsHandler(R, $);
          }
          registerCsiHandler(R, $) {
            return this._inputHandler.registerCsiHandler(R, $);
          }
          registerOscHandler(R, $) {
            return this._inputHandler.registerOscHandler(R, $);
          }
          _setup() {
            this._handleWindowsPtyOptionChange();
          }
          reset() {
            this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
          }
          _handleWindowsPtyOptionChange() {
            let R = !1;
            const $ = this.optionsService.rawOptions.windowsPty;
            $ && $.buildNumber !== void 0 && $.buildNumber !== void 0 ? R = $.backend === "conpty" && $.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (R = !0), R ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
          }
          _enableWindowsWrappingHeuristics() {
            if (!this._windowsWrappingHeuristics.value) {
              const R = [];
              R.push(this.onLineFeed(_.updateWindowsModeWrappedState.bind(null, this._bufferService))), R.push(this.registerCsiHandler({ final: "H" }, () => ((0, _.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics.value = (0, c.toDisposable)(() => {
                for (const $ of R) $.dispose();
              });
            }
          }
        }
        a.CoreTerminal = k;
      }, 8460: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.forwardEvent = a.EventEmitter = void 0, a.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = !1;
          }
          get event() {
            return this._event || (this._event = (l) => (this._listeners.push(l), { dispose: () => {
              if (!this._disposed) {
                for (let c = 0; c < this._listeners.length; c++) if (this._listeners[c] === l) return void this._listeners.splice(c, 1);
              }
            } })), this._event;
          }
          fire(l, c) {
            const h = [];
            for (let f = 0; f < this._listeners.length; f++) h.push(this._listeners[f]);
            for (let f = 0; f < h.length; f++) h[f].call(void 0, l, c);
          }
          dispose() {
            this.clearListeners(), this._disposed = !0;
          }
          clearListeners() {
            this._listeners && (this._listeners.length = 0);
          }
        }, a.forwardEvent = function(l, c) {
          return l((h) => c.fire(h));
        };
      }, 5435: function(o, a, l) {
        var c = this && this.__decorate || function(z, Q, A, L) {
          var M, U = arguments.length, F = U < 3 ? Q : L === null ? L = Object.getOwnPropertyDescriptor(Q, A) : L;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") F = Reflect.decorate(z, Q, A, L);
          else for (var ne = z.length - 1; ne >= 0; ne--) (M = z[ne]) && (F = (U < 3 ? M(F) : U > 3 ? M(Q, A, F) : M(Q, A)) || F);
          return U > 3 && F && Object.defineProperty(Q, A, F), F;
        }, h = this && this.__param || function(z, Q) {
          return function(A, L) {
            Q(A, L, z);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.InputHandler = a.WindowsOptionsReportType = void 0;
        const f = l(2584), u = l(7116), g = l(2015), S = l(844), v = l(482), d = l(8437), O = l(8460), p = l(643), m = l(511), _ = l(3734), b = l(2585), w = l(6242), x = l(6351), y = l(5941), k = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, T = 131072;
        function R(z, Q) {
          if (z > 24) return Q.setWinLines || !1;
          switch (z) {
            case 1:
              return !!Q.restoreWin;
            case 2:
              return !!Q.minimizeWin;
            case 3:
              return !!Q.setWinPosition;
            case 4:
              return !!Q.setWinSizePixels;
            case 5:
              return !!Q.raiseWin;
            case 6:
              return !!Q.lowerWin;
            case 7:
              return !!Q.refreshWin;
            case 8:
              return !!Q.setWinSizeChars;
            case 9:
              return !!Q.maximizeWin;
            case 10:
              return !!Q.fullscreenWin;
            case 11:
              return !!Q.getWinState;
            case 13:
              return !!Q.getWinPosition;
            case 14:
              return !!Q.getWinSizePixels;
            case 15:
              return !!Q.getScreenSizePixels;
            case 16:
              return !!Q.getCellSizePixels;
            case 18:
              return !!Q.getWinSizeChars;
            case 19:
              return !!Q.getScreenSizeChars;
            case 20:
              return !!Q.getIconTitle;
            case 21:
              return !!Q.getWinTitle;
            case 22:
              return !!Q.pushTitle;
            case 23:
              return !!Q.popTitle;
            case 24:
              return !!Q.setWinLines;
          }
          return !1;
        }
        var $;
        (function(z) {
          z[z.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", z[z.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
        })($ || (a.WindowsOptionsReportType = $ = {}));
        let E = 0;
        class D extends S.Disposable {
          getAttrData() {
            return this._curAttrData;
          }
          constructor(Q, A, L, M, U, F, ne, te, de = new g.EscapeSequenceParser()) {
            super(), this._bufferService = Q, this._charsetService = A, this._coreService = L, this._logService = M, this._optionsService = U, this._oscLinkService = F, this._coreMouseService = ne, this._unicodeService = te, this._parser = de, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new v.StringToUtf32(), this._utf8Decoder = new v.Utf8ToUtf32(), this._workCell = new m.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = d.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = d.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new O.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new O.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new O.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new O.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new O.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new O.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new O.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new O.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new O.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new O.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new O.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new O.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new O.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: !1, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new q(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((P) => this._activeBuffer = P.activeBuffer)), this._parser.setCsiHandlerFallback((P, I) => {
              this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(P), params: I.toArray() });
            }), this._parser.setEscHandlerFallback((P) => {
              this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(P) });
            }), this._parser.setExecuteHandlerFallback((P) => {
              this._logService.debug("Unknown EXECUTE code: ", { code: P });
            }), this._parser.setOscHandlerFallback((P, I, N) => {
              this._logService.debug("Unknown OSC code: ", { identifier: P, action: I, data: N });
            }), this._parser.setDcsHandlerFallback((P, I, N) => {
              I === "HOOK" && (N = N.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(P), action: I, payload: N });
            }), this._parser.setPrintHandler((P, I, N) => this.print(P, I, N)), this._parser.registerCsiHandler({ final: "@" }, (P) => this.insertChars(P)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (P) => this.scrollLeft(P)), this._parser.registerCsiHandler({ final: "A" }, (P) => this.cursorUp(P)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (P) => this.scrollRight(P)), this._parser.registerCsiHandler({ final: "B" }, (P) => this.cursorDown(P)), this._parser.registerCsiHandler({ final: "C" }, (P) => this.cursorForward(P)), this._parser.registerCsiHandler({ final: "D" }, (P) => this.cursorBackward(P)), this._parser.registerCsiHandler({ final: "E" }, (P) => this.cursorNextLine(P)), this._parser.registerCsiHandler({ final: "F" }, (P) => this.cursorPrecedingLine(P)), this._parser.registerCsiHandler({ final: "G" }, (P) => this.cursorCharAbsolute(P)), this._parser.registerCsiHandler({ final: "H" }, (P) => this.cursorPosition(P)), this._parser.registerCsiHandler({ final: "I" }, (P) => this.cursorForwardTab(P)), this._parser.registerCsiHandler({ final: "J" }, (P) => this.eraseInDisplay(P, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (P) => this.eraseInDisplay(P, !0)), this._parser.registerCsiHandler({ final: "K" }, (P) => this.eraseInLine(P, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (P) => this.eraseInLine(P, !0)), this._parser.registerCsiHandler({ final: "L" }, (P) => this.insertLines(P)), this._parser.registerCsiHandler({ final: "M" }, (P) => this.deleteLines(P)), this._parser.registerCsiHandler({ final: "P" }, (P) => this.deleteChars(P)), this._parser.registerCsiHandler({ final: "S" }, (P) => this.scrollUp(P)), this._parser.registerCsiHandler({ final: "T" }, (P) => this.scrollDown(P)), this._parser.registerCsiHandler({ final: "X" }, (P) => this.eraseChars(P)), this._parser.registerCsiHandler({ final: "Z" }, (P) => this.cursorBackwardTab(P)), this._parser.registerCsiHandler({ final: "`" }, (P) => this.charPosAbsolute(P)), this._parser.registerCsiHandler({ final: "a" }, (P) => this.hPositionRelative(P)), this._parser.registerCsiHandler({ final: "b" }, (P) => this.repeatPrecedingCharacter(P)), this._parser.registerCsiHandler({ final: "c" }, (P) => this.sendDeviceAttributesPrimary(P)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (P) => this.sendDeviceAttributesSecondary(P)), this._parser.registerCsiHandler({ final: "d" }, (P) => this.linePosAbsolute(P)), this._parser.registerCsiHandler({ final: "e" }, (P) => this.vPositionRelative(P)), this._parser.registerCsiHandler({ final: "f" }, (P) => this.hVPosition(P)), this._parser.registerCsiHandler({ final: "g" }, (P) => this.tabClear(P)), this._parser.registerCsiHandler({ final: "h" }, (P) => this.setMode(P)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (P) => this.setModePrivate(P)), this._parser.registerCsiHandler({ final: "l" }, (P) => this.resetMode(P)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (P) => this.resetModePrivate(P)), this._parser.registerCsiHandler({ final: "m" }, (P) => this.charAttributes(P)), this._parser.registerCsiHandler({ final: "n" }, (P) => this.deviceStatus(P)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (P) => this.deviceStatusPrivate(P)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (P) => this.softReset(P)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (P) => this.setCursorStyle(P)), this._parser.registerCsiHandler({ final: "r" }, (P) => this.setScrollRegion(P)), this._parser.registerCsiHandler({ final: "s" }, (P) => this.saveCursor(P)), this._parser.registerCsiHandler({ final: "t" }, (P) => this.windowOptions(P)), this._parser.registerCsiHandler({ final: "u" }, (P) => this.restoreCursor(P)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (P) => this.insertColumns(P)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (P) => this.deleteColumns(P)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (P) => this.selectProtected(P)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (P) => this.requestMode(P, !0)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (P) => this.requestMode(P, !1)), this._parser.setExecuteHandler(f.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(f.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(f.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(f.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(f.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(f.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(f.C0.HT, () => this.tab()), this._parser.setExecuteHandler(f.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(f.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(f.C1.IND, () => this.index()), this._parser.setExecuteHandler(f.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(f.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new w.OscHandler((P) => (this.setTitle(P), this.setIconName(P), !0))), this._parser.registerOscHandler(1, new w.OscHandler((P) => this.setIconName(P))), this._parser.registerOscHandler(2, new w.OscHandler((P) => this.setTitle(P))), this._parser.registerOscHandler(4, new w.OscHandler((P) => this.setOrReportIndexedColor(P))), this._parser.registerOscHandler(8, new w.OscHandler((P) => this.setHyperlink(P))), this._parser.registerOscHandler(10, new w.OscHandler((P) => this.setOrReportFgColor(P))), this._parser.registerOscHandler(11, new w.OscHandler((P) => this.setOrReportBgColor(P))), this._parser.registerOscHandler(12, new w.OscHandler((P) => this.setOrReportCursorColor(P))), this._parser.registerOscHandler(104, new w.OscHandler((P) => this.restoreIndexedColor(P))), this._parser.registerOscHandler(110, new w.OscHandler((P) => this.restoreFgColor(P))), this._parser.registerOscHandler(111, new w.OscHandler((P) => this.restoreBgColor(P))), this._parser.registerOscHandler(112, new w.OscHandler((P) => this.restoreCursorColor(P))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
            for (const P in u.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: P }, () => this.selectCharset("(" + P)), this._parser.registerEscHandler({ intermediates: ")", final: P }, () => this.selectCharset(")" + P)), this._parser.registerEscHandler({ intermediates: "*", final: P }, () => this.selectCharset("*" + P)), this._parser.registerEscHandler({ intermediates: "+", final: P }, () => this.selectCharset("+" + P)), this._parser.registerEscHandler({ intermediates: "-", final: P }, () => this.selectCharset("-" + P)), this._parser.registerEscHandler({ intermediates: ".", final: P }, () => this.selectCharset("." + P)), this._parser.registerEscHandler({ intermediates: "/", final: P }, () => this.selectCharset("/" + P));
            this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((P) => (this._logService.error("Parsing error: ", P), P)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new x.DcsHandler((P, I) => this.requestStatusString(P, I)));
          }
          _preserveStack(Q, A, L, M) {
            this._parseStack.paused = !0, this._parseStack.cursorStartX = Q, this._parseStack.cursorStartY = A, this._parseStack.decodedLength = L, this._parseStack.position = M;
          }
          _logSlowResolvingAsync(Q) {
            this._logService.logLevel <= b.LogLevelEnum.WARN && Promise.race([Q, new Promise((A, L) => setTimeout(() => L("#SLOW_TIMEOUT"), 5e3))]).catch((A) => {
              if (A !== "#SLOW_TIMEOUT") throw A;
              console.warn("async parser handler taking longer than 5000 ms");
            });
          }
          _getCurrentLinkId() {
            return this._curAttrData.extended.urlId;
          }
          parse(Q, A) {
            let L, M = this._activeBuffer.x, U = this._activeBuffer.y, F = 0;
            const ne = this._parseStack.paused;
            if (ne) {
              if (L = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, A)) return this._logSlowResolvingAsync(L), L;
              M = this._parseStack.cursorStartX, U = this._parseStack.cursorStartY, this._parseStack.paused = !1, Q.length > T && (F = this._parseStack.position + T);
            }
            if (this._logService.logLevel <= b.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof Q == "string" ? ` "${Q}"` : ` "${Array.prototype.map.call(Q, (te) => String.fromCharCode(te)).join("")}"`), typeof Q == "string" ? Q.split("").map((te) => te.charCodeAt(0)) : Q), this._parseBuffer.length < Q.length && this._parseBuffer.length < T && (this._parseBuffer = new Uint32Array(Math.min(Q.length, T))), ne || this._dirtyRowTracker.clearRange(), Q.length > T) for (let te = F; te < Q.length; te += T) {
              const de = te + T < Q.length ? te + T : Q.length, P = typeof Q == "string" ? this._stringDecoder.decode(Q.substring(te, de), this._parseBuffer) : this._utf8Decoder.decode(Q.subarray(te, de), this._parseBuffer);
              if (L = this._parser.parse(this._parseBuffer, P)) return this._preserveStack(M, U, P, te), this._logSlowResolvingAsync(L), L;
            }
            else if (!ne) {
              const te = typeof Q == "string" ? this._stringDecoder.decode(Q, this._parseBuffer) : this._utf8Decoder.decode(Q, this._parseBuffer);
              if (L = this._parser.parse(this._parseBuffer, te)) return this._preserveStack(M, U, te, 0), this._logSlowResolvingAsync(L), L;
            }
            this._activeBuffer.x === M && this._activeBuffer.y === U || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
          }
          print(Q, A, L) {
            let M, U;
            const F = this._charsetService.charset, ne = this._optionsService.rawOptions.screenReaderMode, te = this._bufferService.cols, de = this._coreService.decPrivateModes.wraparound, P = this._coreService.modes.insertMode, I = this._curAttrData;
            let N = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && L - A > 0 && N.getWidth(this._activeBuffer.x - 1) === 2 && N.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, I.fg, I.bg, I.extended);
            for (let j = A; j < L; ++j) {
              if (M = Q[j], U = this._unicodeService.wcwidth(M), M < 127 && F) {
                const ue = F[String.fromCharCode(M)];
                ue && (M = ue.charCodeAt(0));
              }
              if (ne && this._onA11yChar.fire((0, v.stringFromCodePoint)(M)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), U || !this._activeBuffer.x) {
                if (this._activeBuffer.x + U - 1 >= te) {
                  if (de) {
                    for (; this._activeBuffer.x < te; ) N.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, I.fg, I.bg, I.extended);
                    this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), N = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                  } else if (this._activeBuffer.x = te - 1, U === 2) continue;
                }
                if (P && (N.insertCells(this._activeBuffer.x, U, this._activeBuffer.getNullCell(I), I), N.getWidth(te - 1) === 2 && N.setCellFromCodePoint(te - 1, p.NULL_CELL_CODE, p.NULL_CELL_WIDTH, I.fg, I.bg, I.extended)), N.setCellFromCodePoint(this._activeBuffer.x++, M, U, I.fg, I.bg, I.extended), U > 0) for (; --U; ) N.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, I.fg, I.bg, I.extended);
              } else N.getWidth(this._activeBuffer.x - 1) ? N.addCodepointToCell(this._activeBuffer.x - 1, M) : N.addCodepointToCell(this._activeBuffer.x - 2, M);
            }
            L - A > 0 && (N.loadCell(this._activeBuffer.x - 1, this._workCell), this._workCell.getWidth() === 2 || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < te && L - A > 0 && N.getWidth(this._activeBuffer.x) === 0 && !N.hasContent(this._activeBuffer.x) && N.setCellFromCodePoint(this._activeBuffer.x, 0, 1, I.fg, I.bg, I.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          registerCsiHandler(Q, A) {
            return Q.final !== "t" || Q.prefix || Q.intermediates ? this._parser.registerCsiHandler(Q, A) : this._parser.registerCsiHandler(Q, (L) => !R(L.params[0], this._optionsService.rawOptions.windowOptions) || A(L));
          }
          registerDcsHandler(Q, A) {
            return this._parser.registerDcsHandler(Q, new x.DcsHandler(A));
          }
          registerEscHandler(Q, A) {
            return this._parser.registerEscHandler(Q, A);
          }
          registerOscHandler(Q, A) {
            return this._parser.registerOscHandler(Q, new w.OscHandler(A));
          }
          bell() {
            return this._onRequestBell.fire(), !0;
          }
          lineFeed() {
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;
          }
          carriageReturn() {
            return this._activeBuffer.x = 0, !0;
          }
          backspace() {
            var Q;
            if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;
            if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
            else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (!((Q = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) === null || Q === void 0) && Q.isWrapped)) {
              this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
              const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              A.hasWidth(this._activeBuffer.x) && !A.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
            }
            return this._restrictCursor(), !0;
          }
          tab() {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            const Q = this._activeBuffer.x;
            return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - Q), !0;
          }
          shiftOut() {
            return this._charsetService.setgLevel(1), !0;
          }
          shiftIn() {
            return this._charsetService.setgLevel(0), !0;
          }
          _restrictCursor(Q = this._bufferService.cols - 1) {
            this._activeBuffer.x = Math.min(Q, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _setCursor(Q, A) {
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = Q, this._activeBuffer.y = this._activeBuffer.scrollTop + A) : (this._activeBuffer.x = Q, this._activeBuffer.y = A), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _moveCursor(Q, A) {
            this._restrictCursor(), this._setCursor(this._activeBuffer.x + Q, this._activeBuffer.y + A);
          }
          cursorUp(Q) {
            const A = this._activeBuffer.y - this._activeBuffer.scrollTop;
            return A >= 0 ? this._moveCursor(0, -Math.min(A, Q.params[0] || 1)) : this._moveCursor(0, -(Q.params[0] || 1)), !0;
          }
          cursorDown(Q) {
            const A = this._activeBuffer.scrollBottom - this._activeBuffer.y;
            return A >= 0 ? this._moveCursor(0, Math.min(A, Q.params[0] || 1)) : this._moveCursor(0, Q.params[0] || 1), !0;
          }
          cursorForward(Q) {
            return this._moveCursor(Q.params[0] || 1, 0), !0;
          }
          cursorBackward(Q) {
            return this._moveCursor(-(Q.params[0] || 1), 0), !0;
          }
          cursorNextLine(Q) {
            return this.cursorDown(Q), this._activeBuffer.x = 0, !0;
          }
          cursorPrecedingLine(Q) {
            return this.cursorUp(Q), this._activeBuffer.x = 0, !0;
          }
          cursorCharAbsolute(Q) {
            return this._setCursor((Q.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          cursorPosition(Q) {
            return this._setCursor(Q.length >= 2 ? (Q.params[1] || 1) - 1 : 0, (Q.params[0] || 1) - 1), !0;
          }
          charPosAbsolute(Q) {
            return this._setCursor((Q.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          hPositionRelative(Q) {
            return this._moveCursor(Q.params[0] || 1, 0), !0;
          }
          linePosAbsolute(Q) {
            return this._setCursor(this._activeBuffer.x, (Q.params[0] || 1) - 1), !0;
          }
          vPositionRelative(Q) {
            return this._moveCursor(0, Q.params[0] || 1), !0;
          }
          hVPosition(Q) {
            return this.cursorPosition(Q), !0;
          }
          tabClear(Q) {
            const A = Q.params[0];
            return A === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : A === 3 && (this._activeBuffer.tabs = {}), !0;
          }
          cursorForwardTab(Q) {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            let A = Q.params[0] || 1;
            for (; A--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
            return !0;
          }
          cursorBackwardTab(Q) {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            let A = Q.params[0] || 1;
            for (; A--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
            return !0;
          }
          selectProtected(Q) {
            const A = Q.params[0];
            return A === 1 && (this._curAttrData.bg |= 536870912), A !== 2 && A !== 0 || (this._curAttrData.bg &= -536870913), !0;
          }
          _eraseInBufferLine(Q, A, L, M = !1, U = !1) {
            const F = this._activeBuffer.lines.get(this._activeBuffer.ybase + Q);
            F.replaceCells(A, L, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), U), M && (F.isWrapped = !1);
          }
          _resetBufferLine(Q, A = !1) {
            const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + Q);
            L && (L.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), A), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + Q), L.isWrapped = !1);
          }
          eraseInDisplay(Q, A = !1) {
            let L;
            switch (this._restrictCursor(this._bufferService.cols), Q.params[0]) {
              case 0:
                for (L = this._activeBuffer.y, this._dirtyRowTracker.markDirty(L), this._eraseInBufferLine(L++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, A); L < this._bufferService.rows; L++) this._resetBufferLine(L, A);
                this._dirtyRowTracker.markDirty(L);
                break;
              case 1:
                for (L = this._activeBuffer.y, this._dirtyRowTracker.markDirty(L), this._eraseInBufferLine(L, 0, this._activeBuffer.x + 1, !0, A), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(L + 1).isWrapped = !1); L--; ) this._resetBufferLine(L, A);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 2:
                for (L = this._bufferService.rows, this._dirtyRowTracker.markDirty(L - 1); L--; ) this._resetBufferLine(L, A);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 3:
                const M = this._activeBuffer.lines.length - this._bufferService.rows;
                M > 0 && (this._activeBuffer.lines.trimStart(M), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - M, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - M, 0), this._onScroll.fire(0));
            }
            return !0;
          }
          eraseInLine(Q, A = !1) {
            switch (this._restrictCursor(this._bufferService.cols), Q.params[0]) {
              case 0:
                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, A);
                break;
              case 1:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, A);
                break;
              case 2:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, A);
            }
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0;
          }
          insertLines(Q) {
            this._restrictCursor();
            let A = Q.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const L = this._activeBuffer.ybase + this._activeBuffer.y, M = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, U = this._bufferService.rows - 1 + this._activeBuffer.ybase - M + 1;
            for (; A--; ) this._activeBuffer.lines.splice(U - 1, 1), this._activeBuffer.lines.splice(L, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          deleteLines(Q) {
            this._restrictCursor();
            let A = Q.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const L = this._activeBuffer.ybase + this._activeBuffer.y;
            let M;
            for (M = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, M = this._bufferService.rows - 1 + this._activeBuffer.ybase - M; A--; ) this._activeBuffer.lines.splice(L, 1), this._activeBuffer.lines.splice(M, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          insertChars(Q) {
            this._restrictCursor();
            const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return A && (A.insertCells(this._activeBuffer.x, Q.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          deleteChars(Q) {
            this._restrictCursor();
            const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return A && (A.deleteCells(this._activeBuffer.x, Q.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          scrollUp(Q) {
            let A = Q.params[0] || 1;
            for (; A--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollDown(Q) {
            let A = Q.params[0] || 1;
            for (; A--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(d.DEFAULT_ATTR_DATA));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollLeft(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const A = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const M = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              M.deleteCells(0, A, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), M.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollRight(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const A = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const M = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              M.insertCells(0, A, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), M.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          insertColumns(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const A = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const M = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              M.insertCells(this._activeBuffer.x, A, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), M.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          deleteColumns(Q) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const A = Q.params[0] || 1;
            for (let L = this._activeBuffer.scrollTop; L <= this._activeBuffer.scrollBottom; ++L) {
              const M = this._activeBuffer.lines.get(this._activeBuffer.ybase + L);
              M.deleteCells(this._activeBuffer.x, A, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), M.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          eraseChars(Q) {
            this._restrictCursor();
            const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return A && (A.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (Q.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          repeatPrecedingCharacter(Q) {
            if (!this._parser.precedingCodepoint) return !0;
            const A = Q.params[0] || 1, L = new Uint32Array(A);
            for (let M = 0; M < A; ++M) L[M] = this._parser.precedingCodepoint;
            return this.print(L, 0, L.length), !0;
          }
          sendDeviceAttributesPrimary(Q) {
            return Q.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(f.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(f.C0.ESC + "[?6c")), !0;
          }
          sendDeviceAttributesSecondary(Q) {
            return Q.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(f.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(f.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(Q.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(f.C0.ESC + "[>83;40003;0c")), !0;
          }
          _is(Q) {
            return (this._optionsService.rawOptions.termName + "").indexOf(Q) === 0;
          }
          setMode(Q) {
            for (let A = 0; A < Q.length; A++) switch (Q.params[A]) {
              case 4:
                this._coreService.modes.insertMode = !0;
                break;
              case 20:
                this._optionsService.options.convertEol = !0;
            }
            return !0;
          }
          setModePrivate(Q) {
            for (let A = 0; A < Q.length; A++) switch (Q.params[A]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = !0;
                break;
              case 2:
                this._charsetService.setgCharset(0, u.DEFAULT_CHARSET), this._charsetService.setgCharset(1, u.DEFAULT_CHARSET), this._charsetService.setgCharset(2, u.DEFAULT_CHARSET), this._charsetService.setgCharset(3, u.DEFAULT_CHARSET);
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = !0;
                break;
              case 12:
                this._optionsService.options.cursorBlink = !0;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = !0;
                break;
              case 66:
                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
                this._coreMouseService.activeProtocol = "X10";
                break;
              case 1e3:
                this._coreMouseService.activeProtocol = "VT200";
                break;
              case 1002:
                this._coreMouseService.activeProtocol = "DRAG";
                break;
              case 1003:
                this._coreMouseService.activeProtocol = "ANY";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();
                break;
              case 1005:
                this._logService.debug("DECSET 1005 not supported (see #2507)");
                break;
              case 1006:
                this._coreMouseService.activeEncoding = "SGR";
                break;
              case 1015:
                this._logService.debug("DECSET 1015 not supported (see #2507)");
                break;
              case 1016:
                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                break;
              case 25:
                this._coreService.isCursorHidden = !1;
                break;
              case 1048:
                this.saveCursor();
                break;
              case 1049:
                this.saveCursor();
              case 47:
              case 1047:
                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = !0;
            }
            return !0;
          }
          resetMode(Q) {
            for (let A = 0; A < Q.length; A++) switch (Q.params[A]) {
              case 4:
                this._coreService.modes.insertMode = !1;
                break;
              case 20:
                this._optionsService.options.convertEol = !1;
            }
            return !0;
          }
          resetModePrivate(Q) {
            for (let A = 0; A < Q.length; A++) switch (Q.params[A]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = !1;
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = !1;
                break;
              case 12:
                this._optionsService.options.cursorBlink = !1;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = !1;
                break;
              case 66:
                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
              case 1e3:
              case 1002:
              case 1003:
                this._coreMouseService.activeProtocol = "NONE";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = !1;
                break;
              case 1005:
                this._logService.debug("DECRST 1005 not supported (see #2507)");
                break;
              case 1006:
              case 1016:
                this._coreMouseService.activeEncoding = "DEFAULT";
                break;
              case 1015:
                this._logService.debug("DECRST 1015 not supported (see #2507)");
                break;
              case 25:
                this._coreService.isCursorHidden = !0;
                break;
              case 1048:
                this.restoreCursor();
                break;
              case 1049:
              case 47:
              case 1047:
                this._bufferService.buffers.activateNormalBuffer(), Q.params[A] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = !1;
            }
            return !0;
          }
          requestMode(Q, A) {
            const L = this._coreService.decPrivateModes, { activeProtocol: M, activeEncoding: U } = this._coreMouseService, F = this._coreService, { buffers: ne, cols: te } = this._bufferService, { active: de, alt: P } = ne, I = this._optionsService.rawOptions, N = (Ce) => Ce ? 1 : 2, j = Q.params[0];
            return ue = j, se = A ? j === 2 ? 4 : j === 4 ? N(F.modes.insertMode) : j === 12 ? 3 : j === 20 ? N(I.convertEol) : 0 : j === 1 ? N(L.applicationCursorKeys) : j === 3 ? I.windowOptions.setWinLines ? te === 80 ? 2 : te === 132 ? 1 : 0 : 0 : j === 6 ? N(L.origin) : j === 7 ? N(L.wraparound) : j === 8 ? 3 : j === 9 ? N(M === "X10") : j === 12 ? N(I.cursorBlink) : j === 25 ? N(!F.isCursorHidden) : j === 45 ? N(L.reverseWraparound) : j === 66 ? N(L.applicationKeypad) : j === 67 ? 4 : j === 1e3 ? N(M === "VT200") : j === 1002 ? N(M === "DRAG") : j === 1003 ? N(M === "ANY") : j === 1004 ? N(L.sendFocus) : j === 1005 ? 4 : j === 1006 ? N(U === "SGR") : j === 1015 ? 4 : j === 1016 ? N(U === "SGR_PIXELS") : j === 1048 ? 1 : j === 47 || j === 1047 || j === 1049 ? N(de === P) : j === 2004 ? N(L.bracketedPasteMode) : 0, F.triggerDataEvent(`${f.C0.ESC}[${A ? "" : "?"}${ue};${se}$y`), !0;
            var ue, se;
          }
          _updateAttrColor(Q, A, L, M, U) {
            return A === 2 ? (Q |= 50331648, Q &= -16777216, Q |= _.AttributeData.fromColorRGB([L, M, U])) : A === 5 && (Q &= -50331904, Q |= 33554432 | 255 & L), Q;
          }
          _extractColor(Q, A, L) {
            const M = [0, 0, -1, 0, 0, 0];
            let U = 0, F = 0;
            do {
              if (M[F + U] = Q.params[A + F], Q.hasSubParams(A + F)) {
                const ne = Q.getSubParams(A + F);
                let te = 0;
                do
                  M[1] === 5 && (U = 1), M[F + te + 1 + U] = ne[te];
                while (++te < ne.length && te + F + 1 + U < M.length);
                break;
              }
              if (M[1] === 5 && F + U >= 2 || M[1] === 2 && F + U >= 5) break;
              M[1] && (U = 1);
            } while (++F + A < Q.length && F + U < M.length);
            for (let ne = 2; ne < M.length; ++ne) M[ne] === -1 && (M[ne] = 0);
            switch (M[0]) {
              case 38:
                L.fg = this._updateAttrColor(L.fg, M[1], M[3], M[4], M[5]);
                break;
              case 48:
                L.bg = this._updateAttrColor(L.bg, M[1], M[3], M[4], M[5]);
                break;
              case 58:
                L.extended = L.extended.clone(), L.extended.underlineColor = this._updateAttrColor(L.extended.underlineColor, M[1], M[3], M[4], M[5]);
            }
            return F;
          }
          _processUnderline(Q, A) {
            A.extended = A.extended.clone(), (!~Q || Q > 5) && (Q = 1), A.extended.underlineStyle = Q, A.fg |= 268435456, Q === 0 && (A.fg &= -268435457), A.updateExtended();
          }
          _processSGR0(Q) {
            Q.fg = d.DEFAULT_ATTR_DATA.fg, Q.bg = d.DEFAULT_ATTR_DATA.bg, Q.extended = Q.extended.clone(), Q.extended.underlineStyle = 0, Q.extended.underlineColor &= -67108864, Q.updateExtended();
          }
          charAttributes(Q) {
            if (Q.length === 1 && Q.params[0] === 0) return this._processSGR0(this._curAttrData), !0;
            const A = Q.length;
            let L;
            const M = this._curAttrData;
            for (let U = 0; U < A; U++) L = Q.params[U], L >= 30 && L <= 37 ? (M.fg &= -50331904, M.fg |= 16777216 | L - 30) : L >= 40 && L <= 47 ? (M.bg &= -50331904, M.bg |= 16777216 | L - 40) : L >= 90 && L <= 97 ? (M.fg &= -50331904, M.fg |= 16777224 | L - 90) : L >= 100 && L <= 107 ? (M.bg &= -50331904, M.bg |= 16777224 | L - 100) : L === 0 ? this._processSGR0(M) : L === 1 ? M.fg |= 134217728 : L === 3 ? M.bg |= 67108864 : L === 4 ? (M.fg |= 268435456, this._processUnderline(Q.hasSubParams(U) ? Q.getSubParams(U)[0] : 1, M)) : L === 5 ? M.fg |= 536870912 : L === 7 ? M.fg |= 67108864 : L === 8 ? M.fg |= 1073741824 : L === 9 ? M.fg |= 2147483648 : L === 2 ? M.bg |= 134217728 : L === 21 ? this._processUnderline(2, M) : L === 22 ? (M.fg &= -134217729, M.bg &= -134217729) : L === 23 ? M.bg &= -67108865 : L === 24 ? (M.fg &= -268435457, this._processUnderline(0, M)) : L === 25 ? M.fg &= -536870913 : L === 27 ? M.fg &= -67108865 : L === 28 ? M.fg &= -1073741825 : L === 29 ? M.fg &= 2147483647 : L === 39 ? (M.fg &= -67108864, M.fg |= 16777215 & d.DEFAULT_ATTR_DATA.fg) : L === 49 ? (M.bg &= -67108864, M.bg |= 16777215 & d.DEFAULT_ATTR_DATA.bg) : L === 38 || L === 48 || L === 58 ? U += this._extractColor(Q, U, M) : L === 53 ? M.bg |= 1073741824 : L === 55 ? M.bg &= -1073741825 : L === 59 ? (M.extended = M.extended.clone(), M.extended.underlineColor = -1, M.updateExtended()) : L === 100 ? (M.fg &= -67108864, M.fg |= 16777215 & d.DEFAULT_ATTR_DATA.fg, M.bg &= -67108864, M.bg |= 16777215 & d.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", L);
            return !0;
          }
          deviceStatus(Q) {
            switch (Q.params[0]) {
              case 5:
                this._coreService.triggerDataEvent(`${f.C0.ESC}[0n`);
                break;
              case 6:
                const A = this._activeBuffer.y + 1, L = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${f.C0.ESC}[${A};${L}R`);
            }
            return !0;
          }
          deviceStatusPrivate(Q) {
            if (Q.params[0] === 6) {
              const A = this._activeBuffer.y + 1, L = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${f.C0.ESC}[?${A};${L}R`);
            }
            return !0;
          }
          softReset(Q) {
            return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = d.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;
          }
          setCursorStyle(Q) {
            const A = Q.params[0] || 1;
            switch (A) {
              case 1:
              case 2:
                this._optionsService.options.cursorStyle = "block";
                break;
              case 3:
              case 4:
                this._optionsService.options.cursorStyle = "underline";
                break;
              case 5:
              case 6:
                this._optionsService.options.cursorStyle = "bar";
            }
            const L = A % 2 == 1;
            return this._optionsService.options.cursorBlink = L, !0;
          }
          setScrollRegion(Q) {
            const A = Q.params[0] || 1;
            let L;
            return (Q.length < 2 || (L = Q.params[1]) > this._bufferService.rows || L === 0) && (L = this._bufferService.rows), L > A && (this._activeBuffer.scrollTop = A - 1, this._activeBuffer.scrollBottom = L - 1, this._setCursor(0, 0)), !0;
          }
          windowOptions(Q) {
            if (!R(Q.params[0], this._optionsService.rawOptions.windowOptions)) return !0;
            const A = Q.length > 1 ? Q.params[1] : 0;
            switch (Q.params[0]) {
              case 14:
                A !== 2 && this._onRequestWindowsOptionsReport.fire($.GET_WIN_SIZE_PIXELS);
                break;
              case 16:
                this._onRequestWindowsOptionsReport.fire($.GET_CELL_SIZE_PIXELS);
                break;
              case 18:
                this._bufferService && this._coreService.triggerDataEvent(`${f.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                break;
              case 22:
                A !== 0 && A !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), A !== 0 && A !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                break;
              case 23:
                A !== 0 && A !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), A !== 0 && A !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
            }
            return !0;
          }
          saveCursor(Q) {
            return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;
          }
          restoreCursor(Q) {
            return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;
          }
          setTitle(Q) {
            return this._windowTitle = Q, this._onTitleChange.fire(Q), !0;
          }
          setIconName(Q) {
            return this._iconName = Q, !0;
          }
          setOrReportIndexedColor(Q) {
            const A = [], L = Q.split(";");
            for (; L.length > 1; ) {
              const M = L.shift(), U = L.shift();
              if (/^\d+$/.exec(M)) {
                const F = parseInt(M);
                if (W(F)) if (U === "?") A.push({ type: 0, index: F });
                else {
                  const ne = (0, y.parseColor)(U);
                  ne && A.push({ type: 1, index: F, color: ne });
                }
              }
            }
            return A.length && this._onColor.fire(A), !0;
          }
          setHyperlink(Q) {
            const A = Q.split(";");
            return !(A.length < 2) && (A[1] ? this._createHyperlink(A[0], A[1]) : !A[0] && this._finishHyperlink());
          }
          _createHyperlink(Q, A) {
            this._getCurrentLinkId() && this._finishHyperlink();
            const L = Q.split(":");
            let M;
            const U = L.findIndex((F) => F.startsWith("id="));
            return U !== -1 && (M = L[U].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: M, uri: A }), this._curAttrData.updateExtended(), !0;
          }
          _finishHyperlink() {
            return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0;
          }
          _setOrReportSpecialColor(Q, A) {
            const L = Q.split(";");
            for (let M = 0; M < L.length && !(A >= this._specialColors.length); ++M, ++A) if (L[M] === "?") this._onColor.fire([{ type: 0, index: this._specialColors[A] }]);
            else {
              const U = (0, y.parseColor)(L[M]);
              U && this._onColor.fire([{ type: 1, index: this._specialColors[A], color: U }]);
            }
            return !0;
          }
          setOrReportFgColor(Q) {
            return this._setOrReportSpecialColor(Q, 0);
          }
          setOrReportBgColor(Q) {
            return this._setOrReportSpecialColor(Q, 1);
          }
          setOrReportCursorColor(Q) {
            return this._setOrReportSpecialColor(Q, 2);
          }
          restoreIndexedColor(Q) {
            if (!Q) return this._onColor.fire([{ type: 2 }]), !0;
            const A = [], L = Q.split(";");
            for (let M = 0; M < L.length; ++M) if (/^\d+$/.exec(L[M])) {
              const U = parseInt(L[M]);
              W(U) && A.push({ type: 2, index: U });
            }
            return A.length && this._onColor.fire(A), !0;
          }
          restoreFgColor(Q) {
            return this._onColor.fire([{ type: 2, index: 256 }]), !0;
          }
          restoreBgColor(Q) {
            return this._onColor.fire([{ type: 2, index: 257 }]), !0;
          }
          restoreCursorColor(Q) {
            return this._onColor.fire([{ type: 2, index: 258 }]), !0;
          }
          nextLine() {
            return this._activeBuffer.x = 0, this.index(), !0;
          }
          keypadApplicationMode() {
            return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;
          }
          keypadNumericMode() {
            return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;
          }
          selectDefaultCharset() {
            return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, u.DEFAULT_CHARSET), !0;
          }
          selectCharset(Q) {
            return Q.length !== 2 ? (this.selectDefaultCharset(), !0) : (Q[0] === "/" || this._charsetService.setgCharset(k[Q[0]], u.CHARSETS[Q[1]] || u.DEFAULT_CHARSET), !0);
          }
          index() {
            return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;
          }
          tabSet() {
            return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;
          }
          reverseIndex() {
            if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
              const Q = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
              this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, Q, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
            } else this._activeBuffer.y--, this._restrictCursor();
            return !0;
          }
          fullReset() {
            return this._parser.reset(), this._onRequestReset.fire(), !0;
          }
          reset() {
            this._curAttrData = d.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = d.DEFAULT_ATTR_DATA.clone();
          }
          _eraseAttrData() {
            return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
          }
          setgLevel(Q) {
            return this._charsetService.setgLevel(Q), !0;
          }
          screenAlignmentPattern() {
            const Q = new m.CellData();
            Q.content = 4194373, Q.fg = this._curAttrData.fg, Q.bg = this._curAttrData.bg, this._setCursor(0, 0);
            for (let A = 0; A < this._bufferService.rows; ++A) {
              const L = this._activeBuffer.ybase + this._activeBuffer.y + A, M = this._activeBuffer.lines.get(L);
              M && (M.fill(Q), M.isWrapped = !1);
            }
            return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0;
          }
          requestStatusString(Q, A) {
            const L = this._bufferService.buffer, M = this._optionsService.rawOptions;
            return ((U) => (this._coreService.triggerDataEvent(`${f.C0.ESC}${U}${f.C0.ESC}\\`), !0))(Q === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : Q === '"p' ? 'P1$r61;1"p' : Q === "r" ? `P1$r${L.scrollTop + 1};${L.scrollBottom + 1}r` : Q === "m" ? "P1$r0m" : Q === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[M.cursorStyle] - (M.cursorBlink ? 1 : 0)} q` : "P0$r");
          }
          markRangeDirty(Q, A) {
            this._dirtyRowTracker.markRangeDirty(Q, A);
          }
        }
        a.InputHandler = D;
        let q = class {
          constructor(z) {
            this._bufferService = z, this.clearRange();
          }
          clearRange() {
            this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
          }
          markDirty(z) {
            z < this.start ? this.start = z : z > this.end && (this.end = z);
          }
          markRangeDirty(z, Q) {
            z > Q && (E = z, z = Q, Q = E), z < this.start && (this.start = z), Q > this.end && (this.end = Q);
          }
          markAllDirty() {
            this.markRangeDirty(0, this._bufferService.rows - 1);
          }
        };
        function W(z) {
          return 0 <= z && z < 256;
        }
        q = c([h(0, b.IBufferService)], q);
      }, 844: (o, a) => {
        function l(c) {
          for (const h of c) h.dispose();
          c.length = 0;
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getDisposeArrayDisposable = a.disposeArray = a.toDisposable = a.MutableDisposable = a.Disposable = void 0, a.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = !1;
          }
          dispose() {
            this._isDisposed = !0;
            for (const c of this._disposables) c.dispose();
            this._disposables.length = 0;
          }
          register(c) {
            return this._disposables.push(c), c;
          }
          unregister(c) {
            const h = this._disposables.indexOf(c);
            h !== -1 && this._disposables.splice(h, 1);
          }
        }, a.MutableDisposable = class {
          constructor() {
            this._isDisposed = !1;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(c) {
            var h;
            this._isDisposed || c === this._value || ((h = this._value) === null || h === void 0 || h.dispose(), this._value = c);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            var c;
            this._isDisposed = !0, (c = this._value) === null || c === void 0 || c.dispose(), this._value = void 0;
          }
        }, a.toDisposable = function(c) {
          return { dispose: c };
        }, a.disposeArray = l, a.getDisposeArrayDisposable = function(c) {
          return { dispose: () => l(c) };
        };
      }, 1505: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.FourKeyMap = a.TwoKeyMap = void 0;
        class l {
          constructor() {
            this._data = {};
          }
          set(h, f, u) {
            this._data[h] || (this._data[h] = {}), this._data[h][f] = u;
          }
          get(h, f) {
            return this._data[h] ? this._data[h][f] : void 0;
          }
          clear() {
            this._data = {};
          }
        }
        a.TwoKeyMap = l, a.FourKeyMap = class {
          constructor() {
            this._data = new l();
          }
          set(c, h, f, u, g) {
            this._data.get(c, h) || this._data.set(c, h, new l()), this._data.get(c, h).set(f, u, g);
          }
          get(c, h, f, u) {
            var g;
            return (g = this._data.get(c, h)) === null || g === void 0 ? void 0 : g.get(f, u);
          }
          clear() {
            this._data.clear();
          }
        };
      }, 6114: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.isChromeOS = a.isLinux = a.isWindows = a.isIphone = a.isIpad = a.isMac = a.getSafariVersion = a.isSafari = a.isLegacyEdge = a.isFirefox = a.isNode = void 0, a.isNode = typeof navigator > "u";
        const l = a.isNode ? "node" : navigator.userAgent, c = a.isNode ? "node" : navigator.platform;
        a.isFirefox = l.includes("Firefox"), a.isLegacyEdge = l.includes("Edge"), a.isSafari = /^((?!chrome|android).)*safari/i.test(l), a.getSafariVersion = function() {
          if (!a.isSafari) return 0;
          const h = l.match(/Version\/(\d+)/);
          return h === null || h.length < 2 ? 0 : parseInt(h[1]);
        }, a.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(c), a.isIpad = c === "iPad", a.isIphone = c === "iPhone", a.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(c), a.isLinux = c.indexOf("Linux") >= 0, a.isChromeOS = /\bCrOS\b/.test(l);
      }, 6106: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.SortedList = void 0;
        let l = 0;
        a.SortedList = class {
          constructor(c) {
            this._getKey = c, this._array = [];
          }
          clear() {
            this._array.length = 0;
          }
          insert(c) {
            this._array.length !== 0 ? (l = this._search(this._getKey(c)), this._array.splice(l, 0, c)) : this._array.push(c);
          }
          delete(c) {
            if (this._array.length === 0) return !1;
            const h = this._getKey(c);
            if (h === void 0 || (l = this._search(h), l === -1) || this._getKey(this._array[l]) !== h) return !1;
            do
              if (this._array[l] === c) return this._array.splice(l, 1), !0;
            while (++l < this._array.length && this._getKey(this._array[l]) === h);
            return !1;
          }
          *getKeyIterator(c) {
            if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
              yield this._array[l];
            while (++l < this._array.length && this._getKey(this._array[l]) === c);
          }
          forEachByKey(c, h) {
            if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
              h(this._array[l]);
            while (++l < this._array.length && this._getKey(this._array[l]) === c);
          }
          values() {
            return [...this._array].values();
          }
          _search(c) {
            let h = 0, f = this._array.length - 1;
            for (; f >= h; ) {
              let u = h + f >> 1;
              const g = this._getKey(this._array[u]);
              if (g > c) f = u - 1;
              else {
                if (!(g < c)) {
                  for (; u > 0 && this._getKey(this._array[u - 1]) === c; ) u--;
                  return u;
                }
                h = u + 1;
              }
            }
            return h;
          }
        };
      }, 7226: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DebouncedIdleTask = a.IdleTaskQueue = a.PriorityTaskQueue = void 0;
        const c = l(6114);
        class h {
          constructor() {
            this._tasks = [], this._i = 0;
          }
          enqueue(g) {
            this._tasks.push(g), this._start();
          }
          flush() {
            for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
            this.clear();
          }
          clear() {
            this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
          }
          _start() {
            this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
          }
          _process(g) {
            this._idleCallback = void 0;
            let S = 0, v = 0, d = g.timeRemaining(), O = 0;
            for (; this._i < this._tasks.length; ) {
              if (S = Date.now(), this._tasks[this._i]() || this._i++, S = Math.max(1, Date.now() - S), v = Math.max(S, v), O = g.timeRemaining(), 1.5 * v > O) return d - S < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(d - S))}ms`), void this._start();
              d = O;
            }
            this.clear();
          }
        }
        class f extends h {
          _requestCallback(g) {
            return setTimeout(() => g(this._createDeadline(16)));
          }
          _cancelCallback(g) {
            clearTimeout(g);
          }
          _createDeadline(g) {
            const S = Date.now() + g;
            return { timeRemaining: () => Math.max(0, S - Date.now()) };
          }
        }
        a.PriorityTaskQueue = f, a.IdleTaskQueue = !c.isNode && "requestIdleCallback" in window ? class extends h {
          _requestCallback(u) {
            return requestIdleCallback(u);
          }
          _cancelCallback(u) {
            cancelIdleCallback(u);
          }
        } : f, a.DebouncedIdleTask = class {
          constructor() {
            this._queue = new a.IdleTaskQueue();
          }
          set(u) {
            this._queue.clear(), this._queue.enqueue(u);
          }
          flush() {
            this._queue.flush();
          }
        };
      }, 9282: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.updateWindowsModeWrappedState = void 0;
        const c = l(643);
        a.updateWindowsModeWrappedState = function(h) {
          const f = h.buffer.lines.get(h.buffer.ybase + h.buffer.y - 1), u = f?.get(h.cols - 1), g = h.buffer.lines.get(h.buffer.ybase + h.buffer.y);
          g && u && (g.isWrapped = u[c.CHAR_DATA_CODE_INDEX] !== c.NULL_CELL_CODE && u[c.CHAR_DATA_CODE_INDEX] !== c.WHITESPACE_CELL_CODE);
        };
      }, 3734: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ExtendedAttrs = a.AttributeData = void 0;
        class l {
          constructor() {
            this.fg = 0, this.bg = 0, this.extended = new c();
          }
          static toColorRGB(f) {
            return [f >>> 16 & 255, f >>> 8 & 255, 255 & f];
          }
          static fromColorRGB(f) {
            return (255 & f[0]) << 16 | (255 & f[1]) << 8 | 255 & f[2];
          }
          clone() {
            const f = new l();
            return f.fg = this.fg, f.bg = this.bg, f.extended = this.extended.clone(), f;
          }
          isInverse() {
            return 67108864 & this.fg;
          }
          isBold() {
            return 134217728 & this.fg;
          }
          isUnderline() {
            return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
          }
          isBlink() {
            return 536870912 & this.fg;
          }
          isInvisible() {
            return 1073741824 & this.fg;
          }
          isItalic() {
            return 67108864 & this.bg;
          }
          isDim() {
            return 134217728 & this.bg;
          }
          isStrikethrough() {
            return 2147483648 & this.fg;
          }
          isProtected() {
            return 536870912 & this.bg;
          }
          isOverline() {
            return 1073741824 & this.bg;
          }
          getFgColorMode() {
            return 50331648 & this.fg;
          }
          getBgColorMode() {
            return 50331648 & this.bg;
          }
          isFgRGB() {
            return (50331648 & this.fg) == 50331648;
          }
          isBgRGB() {
            return (50331648 & this.bg) == 50331648;
          }
          isFgPalette() {
            return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
          }
          isBgPalette() {
            return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
          }
          isFgDefault() {
            return (50331648 & this.fg) == 0;
          }
          isBgDefault() {
            return (50331648 & this.bg) == 0;
          }
          isAttributeDefault() {
            return this.fg === 0 && this.bg === 0;
          }
          getFgColor() {
            switch (50331648 & this.fg) {
              case 16777216:
              case 33554432:
                return 255 & this.fg;
              case 50331648:
                return 16777215 & this.fg;
              default:
                return -1;
            }
          }
          getBgColor() {
            switch (50331648 & this.bg) {
              case 16777216:
              case 33554432:
                return 255 & this.bg;
              case 50331648:
                return 16777215 & this.bg;
              default:
                return -1;
            }
          }
          hasExtendedAttrs() {
            return 268435456 & this.bg;
          }
          updateExtended() {
            this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
          }
          getUnderlineColor() {
            if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
            return this.getFgColor();
          }
          getUnderlineColorMode() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
          }
          isUnderlineColorRGB() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
          }
          isUnderlineColorPalette() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
          }
          isUnderlineColorDefault() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
          }
          getUnderlineStyle() {
            return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
          }
        }
        a.AttributeData = l;
        class c {
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(f) {
            this._ext = f;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(f) {
            this._ext &= -469762049, this._ext |= f << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(f) {
            this._ext &= -67108864, this._ext |= 67108863 & f;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(f) {
            this._urlId = f;
          }
          constructor(f = 0, u = 0) {
            this._ext = 0, this._urlId = 0, this._ext = f, this._urlId = u;
          }
          clone() {
            return new c(this._ext, this._urlId);
          }
          isEmpty() {
            return this.underlineStyle === 0 && this._urlId === 0;
          }
        }
        a.ExtendedAttrs = c;
      }, 9092: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Buffer = a.MAX_BUFFER_SIZE = void 0;
        const c = l(6349), h = l(7226), f = l(3734), u = l(8437), g = l(4634), S = l(511), v = l(643), d = l(4863), O = l(7116);
        a.MAX_BUFFER_SIZE = 4294967295, a.Buffer = class {
          constructor(p, m, _) {
            this._hasScrollback = p, this._optionsService = m, this._bufferService = _, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = u.DEFAULT_ATTR_DATA.clone(), this.savedCharset = O.DEFAULT_CHARSET, this.markers = [], this._nullCell = S.CellData.fromCharData([0, v.NULL_CELL_CHAR, v.NULL_CELL_WIDTH, v.NULL_CELL_CODE]), this._whitespaceCell = S.CellData.fromCharData([0, v.WHITESPACE_CELL_CHAR, v.WHITESPACE_CELL_WIDTH, v.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._memoryCleanupQueue = new h.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          getNullCell(p) {
            return p ? (this._nullCell.fg = p.fg, this._nullCell.bg = p.bg, this._nullCell.extended = p.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new f.ExtendedAttrs()), this._nullCell;
          }
          getWhitespaceCell(p) {
            return p ? (this._whitespaceCell.fg = p.fg, this._whitespaceCell.bg = p.bg, this._whitespaceCell.extended = p.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new f.ExtendedAttrs()), this._whitespaceCell;
          }
          getBlankLine(p, m) {
            return new u.BufferLine(this._bufferService.cols, this.getNullCell(p), m);
          }
          get hasScrollback() {
            return this._hasScrollback && this.lines.maxLength > this._rows;
          }
          get isCursorInViewport() {
            const p = this.ybase + this.y - this.ydisp;
            return p >= 0 && p < this._rows;
          }
          _getCorrectBufferLength(p) {
            if (!this._hasScrollback) return p;
            const m = p + this._optionsService.rawOptions.scrollback;
            return m > a.MAX_BUFFER_SIZE ? a.MAX_BUFFER_SIZE : m;
          }
          fillViewportRows(p) {
            if (this.lines.length === 0) {
              p === void 0 && (p = u.DEFAULT_ATTR_DATA);
              let m = this._rows;
              for (; m--; ) this.lines.push(this.getBlankLine(p));
            }
          }
          clear() {
            this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          resize(p, m) {
            const _ = this.getNullCell(u.DEFAULT_ATTR_DATA);
            let b = 0;
            const w = this._getCorrectBufferLength(m);
            if (w > this.lines.maxLength && (this.lines.maxLength = w), this.lines.length > 0) {
              if (this._cols < p) for (let y = 0; y < this.lines.length; y++) b += +this.lines.get(y).resize(p, _);
              let x = 0;
              if (this._rows < m) for (let y = this._rows; y < m; y++) this.lines.length < m + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new u.BufferLine(p, _)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + x + 1 ? (this.ybase--, x++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new u.BufferLine(p, _)));
              else for (let y = this._rows; y > m; y--) this.lines.length > m + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
              if (w < this.lines.maxLength) {
                const y = this.lines.length - w;
                y > 0 && (this.lines.trimStart(y), this.ybase = Math.max(this.ybase - y, 0), this.ydisp = Math.max(this.ydisp - y, 0), this.savedY = Math.max(this.savedY - y, 0)), this.lines.maxLength = w;
              }
              this.x = Math.min(this.x, p - 1), this.y = Math.min(this.y, m - 1), x && (this.y += x), this.savedX = Math.min(this.savedX, p - 1), this.scrollTop = 0;
            }
            if (this.scrollBottom = m - 1, this._isReflowEnabled && (this._reflow(p, m), this._cols > p)) for (let x = 0; x < this.lines.length; x++) b += +this.lines.get(x).resize(p, _);
            this._cols = p, this._rows = m, this._memoryCleanupQueue.clear(), b > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
          }
          _batchedMemoryCleanup() {
            let p = !0;
            this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, p = !1);
            let m = 0;
            for (; this._memoryCleanupPosition < this.lines.length; ) if (m += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), m > 100) return !0;
            return p;
          }
          get _isReflowEnabled() {
            const p = this._optionsService.rawOptions.windowsPty;
            return p && p.buildNumber ? this._hasScrollback && p.backend === "conpty" && p.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
          }
          _reflow(p, m) {
            this._cols !== p && (p > this._cols ? this._reflowLarger(p, m) : this._reflowSmaller(p, m));
          }
          _reflowLarger(p, m) {
            const _ = (0, g.reflowLargerGetLinesToRemove)(this.lines, this._cols, p, this.ybase + this.y, this.getNullCell(u.DEFAULT_ATTR_DATA));
            if (_.length > 0) {
              const b = (0, g.reflowLargerCreateNewLayout)(this.lines, _);
              (0, g.reflowLargerApplyNewLayout)(this.lines, b.layout), this._reflowLargerAdjustViewport(p, m, b.countRemoved);
            }
          }
          _reflowLargerAdjustViewport(p, m, _) {
            const b = this.getNullCell(u.DEFAULT_ATTR_DATA);
            let w = _;
            for (; w-- > 0; ) this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < m && this.lines.push(new u.BufferLine(p, b))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
            this.savedY = Math.max(this.savedY - _, 0);
          }
          _reflowSmaller(p, m) {
            const _ = this.getNullCell(u.DEFAULT_ATTR_DATA), b = [];
            let w = 0;
            for (let x = this.lines.length - 1; x >= 0; x--) {
              let y = this.lines.get(x);
              if (!y || !y.isWrapped && y.getTrimmedLength() <= p) continue;
              const k = [y];
              for (; y.isWrapped && x > 0; ) y = this.lines.get(--x), k.unshift(y);
              const T = this.ybase + this.y;
              if (T >= x && T < x + k.length) continue;
              const R = k[k.length - 1].getTrimmedLength(), $ = (0, g.reflowSmallerGetNewLineLengths)(k, this._cols, p), E = $.length - k.length;
              let D;
              D = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + E) : Math.max(0, this.lines.length - this.lines.maxLength + E);
              const q = [];
              for (let M = 0; M < E; M++) {
                const U = this.getBlankLine(u.DEFAULT_ATTR_DATA, !0);
                q.push(U);
              }
              q.length > 0 && (b.push({ start: x + k.length + w, newLines: q }), w += q.length), k.push(...q);
              let W = $.length - 1, z = $[W];
              z === 0 && (W--, z = $[W]);
              let Q = k.length - E - 1, A = R;
              for (; Q >= 0; ) {
                const M = Math.min(A, z);
                if (k[W] === void 0) break;
                if (k[W].copyCellsFrom(k[Q], A - M, z - M, M, !0), z -= M, z === 0 && (W--, z = $[W]), A -= M, A === 0) {
                  Q--;
                  const U = Math.max(Q, 0);
                  A = (0, g.getWrappedLineTrimmedLength)(k, U, this._cols);
                }
              }
              for (let M = 0; M < k.length; M++) $[M] < p && k[M].setCell($[M], _);
              let L = E - D;
              for (; L-- > 0; ) this.ybase === 0 ? this.y < m - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + w) - m && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
              this.savedY = Math.min(this.savedY + E, this.ybase + m - 1);
            }
            if (b.length > 0) {
              const x = [], y = [];
              for (let W = 0; W < this.lines.length; W++) y.push(this.lines.get(W));
              const k = this.lines.length;
              let T = k - 1, R = 0, $ = b[R];
              this.lines.length = Math.min(this.lines.maxLength, this.lines.length + w);
              let E = 0;
              for (let W = Math.min(this.lines.maxLength - 1, k + w - 1); W >= 0; W--) if ($ && $.start > T + E) {
                for (let z = $.newLines.length - 1; z >= 0; z--) this.lines.set(W--, $.newLines[z]);
                W++, x.push({ index: T + 1, amount: $.newLines.length }), E += $.newLines.length, $ = b[++R];
              } else this.lines.set(W, y[T--]);
              let D = 0;
              for (let W = x.length - 1; W >= 0; W--) x[W].index += D, this.lines.onInsertEmitter.fire(x[W]), D += x[W].amount;
              const q = Math.max(0, k + w - this.lines.maxLength);
              q > 0 && this.lines.onTrimEmitter.fire(q);
            }
          }
          translateBufferLineToString(p, m, _ = 0, b) {
            const w = this.lines.get(p);
            return w ? w.translateToString(m, _, b) : "";
          }
          getWrappedRangeForLine(p) {
            let m = p, _ = p;
            for (; m > 0 && this.lines.get(m).isWrapped; ) m--;
            for (; _ + 1 < this.lines.length && this.lines.get(_ + 1).isWrapped; ) _++;
            return { first: m, last: _ };
          }
          setupTabStops(p) {
            for (p != null ? this.tabs[p] || (p = this.prevStop(p)) : (this.tabs = {}, p = 0); p < this._cols; p += this._optionsService.rawOptions.tabStopWidth) this.tabs[p] = !0;
          }
          prevStop(p) {
            for (p == null && (p = this.x); !this.tabs[--p] && p > 0; ) ;
            return p >= this._cols ? this._cols - 1 : p < 0 ? 0 : p;
          }
          nextStop(p) {
            for (p == null && (p = this.x); !this.tabs[++p] && p < this._cols; ) ;
            return p >= this._cols ? this._cols - 1 : p < 0 ? 0 : p;
          }
          clearMarkers(p) {
            this._isClearing = !0;
            for (let m = 0; m < this.markers.length; m++) this.markers[m].line === p && (this.markers[m].dispose(), this.markers.splice(m--, 1));
            this._isClearing = !1;
          }
          clearAllMarkers() {
            this._isClearing = !0;
            for (let p = 0; p < this.markers.length; p++) this.markers[p].dispose(), this.markers.splice(p--, 1);
            this._isClearing = !1;
          }
          addMarker(p) {
            const m = new d.Marker(p);
            return this.markers.push(m), m.register(this.lines.onTrim((_) => {
              m.line -= _, m.line < 0 && m.dispose();
            })), m.register(this.lines.onInsert((_) => {
              m.line >= _.index && (m.line += _.amount);
            })), m.register(this.lines.onDelete((_) => {
              m.line >= _.index && m.line < _.index + _.amount && m.dispose(), m.line > _.index && (m.line -= _.amount);
            })), m.register(m.onDispose(() => this._removeMarker(m))), m;
          }
          _removeMarker(p) {
            this._isClearing || this.markers.splice(this.markers.indexOf(p), 1);
          }
        };
      }, 8437: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLine = a.DEFAULT_ATTR_DATA = void 0;
        const c = l(3734), h = l(511), f = l(643), u = l(482);
        a.DEFAULT_ATTR_DATA = Object.freeze(new c.AttributeData());
        let g = 0;
        class S {
          constructor(d, O, p = !1) {
            this.isWrapped = p, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * d);
            const m = O || h.CellData.fromCharData([0, f.NULL_CELL_CHAR, f.NULL_CELL_WIDTH, f.NULL_CELL_CODE]);
            for (let _ = 0; _ < d; ++_) this.setCell(_, m);
            this.length = d;
          }
          get(d) {
            const O = this._data[3 * d + 0], p = 2097151 & O;
            return [this._data[3 * d + 1], 2097152 & O ? this._combined[d] : p ? (0, u.stringFromCodePoint)(p) : "", O >> 22, 2097152 & O ? this._combined[d].charCodeAt(this._combined[d].length - 1) : p];
          }
          set(d, O) {
            this._data[3 * d + 1] = O[f.CHAR_DATA_ATTR_INDEX], O[f.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[d] = O[1], this._data[3 * d + 0] = 2097152 | d | O[f.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * d + 0] = O[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | O[f.CHAR_DATA_WIDTH_INDEX] << 22;
          }
          getWidth(d) {
            return this._data[3 * d + 0] >> 22;
          }
          hasWidth(d) {
            return 12582912 & this._data[3 * d + 0];
          }
          getFg(d) {
            return this._data[3 * d + 1];
          }
          getBg(d) {
            return this._data[3 * d + 2];
          }
          hasContent(d) {
            return 4194303 & this._data[3 * d + 0];
          }
          getCodePoint(d) {
            const O = this._data[3 * d + 0];
            return 2097152 & O ? this._combined[d].charCodeAt(this._combined[d].length - 1) : 2097151 & O;
          }
          isCombined(d) {
            return 2097152 & this._data[3 * d + 0];
          }
          getString(d) {
            const O = this._data[3 * d + 0];
            return 2097152 & O ? this._combined[d] : 2097151 & O ? (0, u.stringFromCodePoint)(2097151 & O) : "";
          }
          isProtected(d) {
            return 536870912 & this._data[3 * d + 2];
          }
          loadCell(d, O) {
            return g = 3 * d, O.content = this._data[g + 0], O.fg = this._data[g + 1], O.bg = this._data[g + 2], 2097152 & O.content && (O.combinedData = this._combined[d]), 268435456 & O.bg && (O.extended = this._extendedAttrs[d]), O;
          }
          setCell(d, O) {
            2097152 & O.content && (this._combined[d] = O.combinedData), 268435456 & O.bg && (this._extendedAttrs[d] = O.extended), this._data[3 * d + 0] = O.content, this._data[3 * d + 1] = O.fg, this._data[3 * d + 2] = O.bg;
          }
          setCellFromCodePoint(d, O, p, m, _, b) {
            268435456 & _ && (this._extendedAttrs[d] = b), this._data[3 * d + 0] = O | p << 22, this._data[3 * d + 1] = m, this._data[3 * d + 2] = _;
          }
          addCodepointToCell(d, O) {
            let p = this._data[3 * d + 0];
            2097152 & p ? this._combined[d] += (0, u.stringFromCodePoint)(O) : (2097151 & p ? (this._combined[d] = (0, u.stringFromCodePoint)(2097151 & p) + (0, u.stringFromCodePoint)(O), p &= -2097152, p |= 2097152) : p = O | 4194304, this._data[3 * d + 0] = p);
          }
          insertCells(d, O, p, m) {
            if ((d %= this.length) && this.getWidth(d - 1) === 2 && this.setCellFromCodePoint(d - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), O < this.length - d) {
              const _ = new h.CellData();
              for (let b = this.length - d - O - 1; b >= 0; --b) this.setCell(d + O + b, this.loadCell(d + b, _));
              for (let b = 0; b < O; ++b) this.setCell(d + b, p);
            } else for (let _ = d; _ < this.length; ++_) this.setCell(_, p);
            this.getWidth(this.length - 1) === 2 && this.setCellFromCodePoint(this.length - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs());
          }
          deleteCells(d, O, p, m) {
            if (d %= this.length, O < this.length - d) {
              const _ = new h.CellData();
              for (let b = 0; b < this.length - d - O; ++b) this.setCell(d + b, this.loadCell(d + O + b, _));
              for (let b = this.length - O; b < this.length; ++b) this.setCell(b, p);
            } else for (let _ = d; _ < this.length; ++_) this.setCell(_, p);
            d && this.getWidth(d - 1) === 2 && this.setCellFromCodePoint(d - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), this.getWidth(d) !== 0 || this.hasContent(d) || this.setCellFromCodePoint(d, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs());
          }
          replaceCells(d, O, p, m, _ = !1) {
            if (_) for (d && this.getWidth(d - 1) === 2 && !this.isProtected(d - 1) && this.setCellFromCodePoint(d - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), O < this.length && this.getWidth(O - 1) === 2 && !this.isProtected(O) && this.setCellFromCodePoint(O, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()); d < O && d < this.length; ) this.isProtected(d) || this.setCell(d, p), d++;
            else for (d && this.getWidth(d - 1) === 2 && this.setCellFromCodePoint(d - 1, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()), O < this.length && this.getWidth(O - 1) === 2 && this.setCellFromCodePoint(O, 0, 1, m?.fg || 0, m?.bg || 0, m?.extended || new c.ExtendedAttrs()); d < O && d < this.length; ) this.setCell(d++, p);
          }
          resize(d, O) {
            if (d === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
            const p = 3 * d;
            if (d > this.length) {
              if (this._data.buffer.byteLength >= 4 * p) this._data = new Uint32Array(this._data.buffer, 0, p);
              else {
                const m = new Uint32Array(p);
                m.set(this._data), this._data = m;
              }
              for (let m = this.length; m < d; ++m) this.setCell(m, O);
            } else {
              this._data = this._data.subarray(0, p);
              const m = Object.keys(this._combined);
              for (let b = 0; b < m.length; b++) {
                const w = parseInt(m[b], 10);
                w >= d && delete this._combined[w];
              }
              const _ = Object.keys(this._extendedAttrs);
              for (let b = 0; b < _.length; b++) {
                const w = parseInt(_[b], 10);
                w >= d && delete this._extendedAttrs[w];
              }
            }
            return this.length = d, 4 * p * 2 < this._data.buffer.byteLength;
          }
          cleanupMemory() {
            if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
              const d = new Uint32Array(this._data.length);
              return d.set(this._data), this._data = d, 1;
            }
            return 0;
          }
          fill(d, O = !1) {
            if (O) for (let p = 0; p < this.length; ++p) this.isProtected(p) || this.setCell(p, d);
            else {
              this._combined = {}, this._extendedAttrs = {};
              for (let p = 0; p < this.length; ++p) this.setCell(p, d);
            }
          }
          copyFrom(d) {
            this.length !== d.length ? this._data = new Uint32Array(d._data) : this._data.set(d._data), this.length = d.length, this._combined = {};
            for (const O in d._combined) this._combined[O] = d._combined[O];
            this._extendedAttrs = {};
            for (const O in d._extendedAttrs) this._extendedAttrs[O] = d._extendedAttrs[O];
            this.isWrapped = d.isWrapped;
          }
          clone() {
            const d = new S(0);
            d._data = new Uint32Array(this._data), d.length = this.length;
            for (const O in this._combined) d._combined[O] = this._combined[O];
            for (const O in this._extendedAttrs) d._extendedAttrs[O] = this._extendedAttrs[O];
            return d.isWrapped = this.isWrapped, d;
          }
          getTrimmedLength() {
            for (let d = this.length - 1; d >= 0; --d) if (4194303 & this._data[3 * d + 0]) return d + (this._data[3 * d + 0] >> 22);
            return 0;
          }
          getNoBgTrimmedLength() {
            for (let d = this.length - 1; d >= 0; --d) if (4194303 & this._data[3 * d + 0] || 50331648 & this._data[3 * d + 2]) return d + (this._data[3 * d + 0] >> 22);
            return 0;
          }
          copyCellsFrom(d, O, p, m, _) {
            const b = d._data;
            if (_) for (let x = m - 1; x >= 0; x--) {
              for (let y = 0; y < 3; y++) this._data[3 * (p + x) + y] = b[3 * (O + x) + y];
              268435456 & b[3 * (O + x) + 2] && (this._extendedAttrs[p + x] = d._extendedAttrs[O + x]);
            }
            else for (let x = 0; x < m; x++) {
              for (let y = 0; y < 3; y++) this._data[3 * (p + x) + y] = b[3 * (O + x) + y];
              268435456 & b[3 * (O + x) + 2] && (this._extendedAttrs[p + x] = d._extendedAttrs[O + x]);
            }
            const w = Object.keys(d._combined);
            for (let x = 0; x < w.length; x++) {
              const y = parseInt(w[x], 10);
              y >= O && (this._combined[y - O + p] = d._combined[y]);
            }
          }
          translateToString(d = !1, O = 0, p = this.length) {
            d && (p = Math.min(p, this.getTrimmedLength()));
            let m = "";
            for (; O < p; ) {
              const _ = this._data[3 * O + 0], b = 2097151 & _;
              m += 2097152 & _ ? this._combined[O] : b ? (0, u.stringFromCodePoint)(b) : f.WHITESPACE_CELL_CHAR, O += _ >> 22 || 1;
            }
            return m;
          }
        }
        a.BufferLine = S;
      }, 4841: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getRangeLength = void 0, a.getRangeLength = function(l, c) {
          if (l.start.y > l.end.y) throw new Error(`Buffer range end (${l.end.x}, ${l.end.y}) cannot be before start (${l.start.x}, ${l.start.y})`);
          return c * (l.end.y - l.start.y) + (l.end.x - l.start.x + 1);
        };
      }, 4634: (o, a) => {
        function l(c, h, f) {
          if (h === c.length - 1) return c[h].getTrimmedLength();
          const u = !c[h].hasContent(f - 1) && c[h].getWidth(f - 1) === 1, g = c[h + 1].getWidth(0) === 2;
          return u && g ? f - 1 : f;
        }
        Object.defineProperty(a, "__esModule", { value: !0 }), a.getWrappedLineTrimmedLength = a.reflowSmallerGetNewLineLengths = a.reflowLargerApplyNewLayout = a.reflowLargerCreateNewLayout = a.reflowLargerGetLinesToRemove = void 0, a.reflowLargerGetLinesToRemove = function(c, h, f, u, g) {
          const S = [];
          for (let v = 0; v < c.length - 1; v++) {
            let d = v, O = c.get(++d);
            if (!O.isWrapped) continue;
            const p = [c.get(v)];
            for (; d < c.length && O.isWrapped; ) p.push(O), O = c.get(++d);
            if (u >= v && u < d) {
              v += p.length - 1;
              continue;
            }
            let m = 0, _ = l(p, m, h), b = 1, w = 0;
            for (; b < p.length; ) {
              const y = l(p, b, h), k = y - w, T = f - _, R = Math.min(k, T);
              p[m].copyCellsFrom(p[b], w, _, R, !1), _ += R, _ === f && (m++, _ = 0), w += R, w === y && (b++, w = 0), _ === 0 && m !== 0 && p[m - 1].getWidth(f - 1) === 2 && (p[m].copyCellsFrom(p[m - 1], f - 1, _++, 1, !1), p[m - 1].setCell(f - 1, g));
            }
            p[m].replaceCells(_, f, g);
            let x = 0;
            for (let y = p.length - 1; y > 0 && (y > m || p[y].getTrimmedLength() === 0); y--) x++;
            x > 0 && (S.push(v + p.length - x), S.push(x)), v += p.length - 1;
          }
          return S;
        }, a.reflowLargerCreateNewLayout = function(c, h) {
          const f = [];
          let u = 0, g = h[u], S = 0;
          for (let v = 0; v < c.length; v++) if (g === v) {
            const d = h[++u];
            c.onDeleteEmitter.fire({ index: v - S, amount: d }), v += d - 1, S += d, g = h[++u];
          } else f.push(v);
          return { layout: f, countRemoved: S };
        }, a.reflowLargerApplyNewLayout = function(c, h) {
          const f = [];
          for (let u = 0; u < h.length; u++) f.push(c.get(h[u]));
          for (let u = 0; u < f.length; u++) c.set(u, f[u]);
          c.length = h.length;
        }, a.reflowSmallerGetNewLineLengths = function(c, h, f) {
          const u = [], g = c.map((O, p) => l(c, p, h)).reduce((O, p) => O + p);
          let S = 0, v = 0, d = 0;
          for (; d < g; ) {
            if (g - d < f) {
              u.push(g - d);
              break;
            }
            S += f;
            const O = l(c, v, h);
            S > O && (S -= O, v++);
            const p = c[v].getWidth(S - 1) === 2;
            p && S--;
            const m = p ? f - 1 : f;
            u.push(m), d += m;
          }
          return u;
        }, a.getWrappedLineTrimmedLength = l;
      }, 5295: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferSet = void 0;
        const c = l(8460), h = l(844), f = l(9092);
        class u extends h.Disposable {
          constructor(S, v) {
            super(), this._optionsService = S, this._bufferService = v, this._onBufferActivate = this.register(new c.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
          }
          reset() {
            this._normal = new f.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new f.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
          }
          get alt() {
            return this._alt;
          }
          get active() {
            return this._activeBuffer;
          }
          get normal() {
            return this._normal;
          }
          activateNormalBuffer() {
            this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
          }
          activateAltBuffer(S) {
            this._activeBuffer !== this._alt && (this._alt.fillViewportRows(S), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
          }
          resize(S, v) {
            this._normal.resize(S, v), this._alt.resize(S, v), this.setupTabStops(S);
          }
          setupTabStops(S) {
            this._normal.setupTabStops(S), this._alt.setupTabStops(S);
          }
        }
        a.BufferSet = u;
      }, 511: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CellData = void 0;
        const c = l(482), h = l(643), f = l(3734);
        class u extends f.AttributeData {
          constructor() {
            super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new f.ExtendedAttrs(), this.combinedData = "";
          }
          static fromCharData(S) {
            const v = new u();
            return v.setFromCharData(S), v;
          }
          isCombined() {
            return 2097152 & this.content;
          }
          getWidth() {
            return this.content >> 22;
          }
          getChars() {
            return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, c.stringFromCodePoint)(2097151 & this.content) : "";
          }
          getCode() {
            return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
          }
          setFromCharData(S) {
            this.fg = S[h.CHAR_DATA_ATTR_INDEX], this.bg = 0;
            let v = !1;
            if (S[h.CHAR_DATA_CHAR_INDEX].length > 2) v = !0;
            else if (S[h.CHAR_DATA_CHAR_INDEX].length === 2) {
              const d = S[h.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
              if (55296 <= d && d <= 56319) {
                const O = S[h.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                56320 <= O && O <= 57343 ? this.content = 1024 * (d - 55296) + O - 56320 + 65536 | S[h.CHAR_DATA_WIDTH_INDEX] << 22 : v = !0;
              } else v = !0;
            } else this.content = S[h.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | S[h.CHAR_DATA_WIDTH_INDEX] << 22;
            v && (this.combinedData = S[h.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | S[h.CHAR_DATA_WIDTH_INDEX] << 22);
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        a.CellData = u;
      }, 643: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.WHITESPACE_CELL_CODE = a.WHITESPACE_CELL_WIDTH = a.WHITESPACE_CELL_CHAR = a.NULL_CELL_CODE = a.NULL_CELL_WIDTH = a.NULL_CELL_CHAR = a.CHAR_DATA_CODE_INDEX = a.CHAR_DATA_WIDTH_INDEX = a.CHAR_DATA_CHAR_INDEX = a.CHAR_DATA_ATTR_INDEX = a.DEFAULT_EXT = a.DEFAULT_ATTR = a.DEFAULT_COLOR = void 0, a.DEFAULT_COLOR = 0, a.DEFAULT_ATTR = 256 | a.DEFAULT_COLOR << 9, a.DEFAULT_EXT = 0, a.CHAR_DATA_ATTR_INDEX = 0, a.CHAR_DATA_CHAR_INDEX = 1, a.CHAR_DATA_WIDTH_INDEX = 2, a.CHAR_DATA_CODE_INDEX = 3, a.NULL_CELL_CHAR = "", a.NULL_CELL_WIDTH = 1, a.NULL_CELL_CODE = 0, a.WHITESPACE_CELL_CHAR = " ", a.WHITESPACE_CELL_WIDTH = 1, a.WHITESPACE_CELL_CODE = 32;
      }, 4863: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Marker = void 0;
        const c = l(8460), h = l(844);
        class f {
          get id() {
            return this._id;
          }
          constructor(g) {
            this.line = g, this.isDisposed = !1, this._disposables = [], this._id = f._nextId++, this._onDispose = this.register(new c.EventEmitter()), this.onDispose = this._onDispose.event;
          }
          dispose() {
            this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, h.disposeArray)(this._disposables), this._disposables.length = 0);
          }
          register(g) {
            return this._disposables.push(g), g;
          }
        }
        a.Marker = f, f._nextId = 1;
      }, 7116: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DEFAULT_CHARSET = a.CHARSETS = void 0, a.CHARSETS = {}, a.DEFAULT_CHARSET = a.CHARSETS.B, a.CHARSETS[0] = { "`": "◆", a: "▒", b: "␉", c: "␌", d: "␍", e: "␊", f: "°", g: "±", h: "␤", i: "␋", j: "┘", k: "┐", l: "┌", m: "└", n: "┼", o: "⎺", p: "⎻", q: "─", r: "⎼", s: "⎽", t: "├", u: "┤", v: "┴", w: "┬", x: "│", y: "≤", z: "≥", "{": "π", "|": "≠", "}": "£", "~": "·" }, a.CHARSETS.A = { "#": "£" }, a.CHARSETS.B = void 0, a.CHARSETS[4] = { "#": "£", "@": "¾", "[": "ij", "\\": "½", "]": "|", "{": "¨", "|": "f", "}": "¼", "~": "´" }, a.CHARSETS.C = a.CHARSETS[5] = { "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, a.CHARSETS.R = { "#": "£", "@": "à", "[": "°", "\\": "ç", "]": "§", "{": "é", "|": "ù", "}": "è", "~": "¨" }, a.CHARSETS.Q = { "@": "à", "[": "â", "\\": "ç", "]": "ê", "^": "î", "`": "ô", "{": "é", "|": "ù", "}": "è", "~": "û" }, a.CHARSETS.K = { "@": "§", "[": "Ä", "\\": "Ö", "]": "Ü", "{": "ä", "|": "ö", "}": "ü", "~": "ß" }, a.CHARSETS.Y = { "#": "£", "@": "§", "[": "°", "\\": "ç", "]": "é", "`": "ù", "{": "à", "|": "ò", "}": "è", "~": "ì" }, a.CHARSETS.E = a.CHARSETS[6] = { "@": "Ä", "[": "Æ", "\\": "Ø", "]": "Å", "^": "Ü", "`": "ä", "{": "æ", "|": "ø", "}": "å", "~": "ü" }, a.CHARSETS.Z = { "#": "£", "@": "§", "[": "¡", "\\": "Ñ", "]": "¿", "{": "°", "|": "ñ", "}": "ç" }, a.CHARSETS.H = a.CHARSETS[7] = { "@": "É", "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, a.CHARSETS["="] = { "#": "ù", "@": "à", "[": "é", "\\": "ç", "]": "ê", "^": "î", _: "è", "`": "ô", "{": "ä", "|": "ö", "}": "ü", "~": "û" };
      }, 2584: (o, a) => {
        var l, c, h;
        Object.defineProperty(a, "__esModule", { value: !0 }), a.C1_ESCAPED = a.C1 = a.C0 = void 0, function(f) {
          f.NUL = "\0", f.SOH = "", f.STX = "", f.ETX = "", f.EOT = "", f.ENQ = "", f.ACK = "", f.BEL = "\x07", f.BS = "\b", f.HT = "	", f.LF = `
`, f.VT = "\v", f.FF = "\f", f.CR = "\r", f.SO = "", f.SI = "", f.DLE = "", f.DC1 = "", f.DC2 = "", f.DC3 = "", f.DC4 = "", f.NAK = "", f.SYN = "", f.ETB = "", f.CAN = "", f.EM = "", f.SUB = "", f.ESC = "\x1B", f.FS = "", f.GS = "", f.RS = "", f.US = "", f.SP = " ", f.DEL = "";
        }(l || (a.C0 = l = {})), function(f) {
          f.PAD = "", f.HOP = "", f.BPH = "", f.NBH = "", f.IND = "", f.NEL = "", f.SSA = "", f.ESA = "", f.HTS = "", f.HTJ = "", f.VTS = "", f.PLD = "", f.PLU = "", f.RI = "", f.SS2 = "", f.SS3 = "", f.DCS = "", f.PU1 = "", f.PU2 = "", f.STS = "", f.CCH = "", f.MW = "", f.SPA = "", f.EPA = "", f.SOS = "", f.SGCI = "", f.SCI = "", f.CSI = "", f.ST = "", f.OSC = "", f.PM = "", f.APC = "";
        }(c || (a.C1 = c = {})), function(f) {
          f.ST = `${l.ESC}\\`;
        }(h || (a.C1_ESCAPED = h = {}));
      }, 7399: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.evaluateKeyboardEvent = void 0;
        const c = l(2584), h = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
        a.evaluateKeyboardEvent = function(f, u, g, S) {
          const v = { type: 0, cancel: !1, key: void 0 }, d = (f.shiftKey ? 1 : 0) | (f.altKey ? 2 : 0) | (f.ctrlKey ? 4 : 0) | (f.metaKey ? 8 : 0);
          switch (f.keyCode) {
            case 0:
              f.key === "UIKeyInputUpArrow" ? v.key = u ? c.C0.ESC + "OA" : c.C0.ESC + "[A" : f.key === "UIKeyInputLeftArrow" ? v.key = u ? c.C0.ESC + "OD" : c.C0.ESC + "[D" : f.key === "UIKeyInputRightArrow" ? v.key = u ? c.C0.ESC + "OC" : c.C0.ESC + "[C" : f.key === "UIKeyInputDownArrow" && (v.key = u ? c.C0.ESC + "OB" : c.C0.ESC + "[B");
              break;
            case 8:
              if (f.altKey) {
                v.key = c.C0.ESC + c.C0.DEL;
                break;
              }
              v.key = c.C0.DEL;
              break;
            case 9:
              if (f.shiftKey) {
                v.key = c.C0.ESC + "[Z";
                break;
              }
              v.key = c.C0.HT, v.cancel = !0;
              break;
            case 13:
              v.key = f.altKey ? c.C0.ESC + c.C0.CR : c.C0.CR, v.cancel = !0;
              break;
            case 27:
              v.key = c.C0.ESC, f.altKey && (v.key = c.C0.ESC + c.C0.ESC), v.cancel = !0;
              break;
            case 37:
              if (f.metaKey) break;
              d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "D", v.key === c.C0.ESC + "[1;3D" && (v.key = c.C0.ESC + (g ? "b" : "[1;5D"))) : v.key = u ? c.C0.ESC + "OD" : c.C0.ESC + "[D";
              break;
            case 39:
              if (f.metaKey) break;
              d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "C", v.key === c.C0.ESC + "[1;3C" && (v.key = c.C0.ESC + (g ? "f" : "[1;5C"))) : v.key = u ? c.C0.ESC + "OC" : c.C0.ESC + "[C";
              break;
            case 38:
              if (f.metaKey) break;
              d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "A", g || v.key !== c.C0.ESC + "[1;3A" || (v.key = c.C0.ESC + "[1;5A")) : v.key = u ? c.C0.ESC + "OA" : c.C0.ESC + "[A";
              break;
            case 40:
              if (f.metaKey) break;
              d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "B", g || v.key !== c.C0.ESC + "[1;3B" || (v.key = c.C0.ESC + "[1;5B")) : v.key = u ? c.C0.ESC + "OB" : c.C0.ESC + "[B";
              break;
            case 45:
              f.shiftKey || f.ctrlKey || (v.key = c.C0.ESC + "[2~");
              break;
            case 46:
              v.key = d ? c.C0.ESC + "[3;" + (d + 1) + "~" : c.C0.ESC + "[3~";
              break;
            case 36:
              v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "H" : u ? c.C0.ESC + "OH" : c.C0.ESC + "[H";
              break;
            case 35:
              v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "F" : u ? c.C0.ESC + "OF" : c.C0.ESC + "[F";
              break;
            case 33:
              f.shiftKey ? v.type = 2 : f.ctrlKey ? v.key = c.C0.ESC + "[5;" + (d + 1) + "~" : v.key = c.C0.ESC + "[5~";
              break;
            case 34:
              f.shiftKey ? v.type = 3 : f.ctrlKey ? v.key = c.C0.ESC + "[6;" + (d + 1) + "~" : v.key = c.C0.ESC + "[6~";
              break;
            case 112:
              v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "P" : c.C0.ESC + "OP";
              break;
            case 113:
              v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "Q" : c.C0.ESC + "OQ";
              break;
            case 114:
              v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "R" : c.C0.ESC + "OR";
              break;
            case 115:
              v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "S" : c.C0.ESC + "OS";
              break;
            case 116:
              v.key = d ? c.C0.ESC + "[15;" + (d + 1) + "~" : c.C0.ESC + "[15~";
              break;
            case 117:
              v.key = d ? c.C0.ESC + "[17;" + (d + 1) + "~" : c.C0.ESC + "[17~";
              break;
            case 118:
              v.key = d ? c.C0.ESC + "[18;" + (d + 1) + "~" : c.C0.ESC + "[18~";
              break;
            case 119:
              v.key = d ? c.C0.ESC + "[19;" + (d + 1) + "~" : c.C0.ESC + "[19~";
              break;
            case 120:
              v.key = d ? c.C0.ESC + "[20;" + (d + 1) + "~" : c.C0.ESC + "[20~";
              break;
            case 121:
              v.key = d ? c.C0.ESC + "[21;" + (d + 1) + "~" : c.C0.ESC + "[21~";
              break;
            case 122:
              v.key = d ? c.C0.ESC + "[23;" + (d + 1) + "~" : c.C0.ESC + "[23~";
              break;
            case 123:
              v.key = d ? c.C0.ESC + "[24;" + (d + 1) + "~" : c.C0.ESC + "[24~";
              break;
            default:
              if (!f.ctrlKey || f.shiftKey || f.altKey || f.metaKey) if (g && !S || !f.altKey || f.metaKey) !g || f.altKey || f.ctrlKey || f.shiftKey || !f.metaKey ? f.key && !f.ctrlKey && !f.altKey && !f.metaKey && f.keyCode >= 48 && f.key.length === 1 ? v.key = f.key : f.key && f.ctrlKey && (f.key === "_" && (v.key = c.C0.US), f.key === "@" && (v.key = c.C0.NUL)) : f.keyCode === 65 && (v.type = 1);
              else {
                const O = h[f.keyCode], p = O?.[f.shiftKey ? 1 : 0];
                if (p) v.key = c.C0.ESC + p;
                else if (f.keyCode >= 65 && f.keyCode <= 90) {
                  const m = f.ctrlKey ? f.keyCode - 64 : f.keyCode + 32;
                  let _ = String.fromCharCode(m);
                  f.shiftKey && (_ = _.toUpperCase()), v.key = c.C0.ESC + _;
                } else if (f.keyCode === 32) v.key = c.C0.ESC + (f.ctrlKey ? c.C0.NUL : " ");
                else if (f.key === "Dead" && f.code.startsWith("Key")) {
                  let m = f.code.slice(3, 4);
                  f.shiftKey || (m = m.toLowerCase()), v.key = c.C0.ESC + m, v.cancel = !0;
                }
              }
              else f.keyCode >= 65 && f.keyCode <= 90 ? v.key = String.fromCharCode(f.keyCode - 64) : f.keyCode === 32 ? v.key = c.C0.NUL : f.keyCode >= 51 && f.keyCode <= 55 ? v.key = String.fromCharCode(f.keyCode - 51 + 27) : f.keyCode === 56 ? v.key = c.C0.DEL : f.keyCode === 219 ? v.key = c.C0.ESC : f.keyCode === 220 ? v.key = c.C0.FS : f.keyCode === 221 && (v.key = c.C0.GS);
          }
          return v;
        };
      }, 482: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Utf8ToUtf32 = a.StringToUtf32 = a.utf32ToString = a.stringFromCodePoint = void 0, a.stringFromCodePoint = function(l) {
          return l > 65535 ? (l -= 65536, String.fromCharCode(55296 + (l >> 10)) + String.fromCharCode(l % 1024 + 56320)) : String.fromCharCode(l);
        }, a.utf32ToString = function(l, c = 0, h = l.length) {
          let f = "";
          for (let u = c; u < h; ++u) {
            let g = l[u];
            g > 65535 ? (g -= 65536, f += String.fromCharCode(55296 + (g >> 10)) + String.fromCharCode(g % 1024 + 56320)) : f += String.fromCharCode(g);
          }
          return f;
        }, a.StringToUtf32 = class {
          constructor() {
            this._interim = 0;
          }
          clear() {
            this._interim = 0;
          }
          decode(l, c) {
            const h = l.length;
            if (!h) return 0;
            let f = 0, u = 0;
            if (this._interim) {
              const g = l.charCodeAt(u++);
              56320 <= g && g <= 57343 ? c[f++] = 1024 * (this._interim - 55296) + g - 56320 + 65536 : (c[f++] = this._interim, c[f++] = g), this._interim = 0;
            }
            for (let g = u; g < h; ++g) {
              const S = l.charCodeAt(g);
              if (55296 <= S && S <= 56319) {
                if (++g >= h) return this._interim = S, f;
                const v = l.charCodeAt(g);
                56320 <= v && v <= 57343 ? c[f++] = 1024 * (S - 55296) + v - 56320 + 65536 : (c[f++] = S, c[f++] = v);
              } else S !== 65279 && (c[f++] = S);
            }
            return f;
          }
        }, a.Utf8ToUtf32 = class {
          constructor() {
            this.interim = new Uint8Array(3);
          }
          clear() {
            this.interim.fill(0);
          }
          decode(l, c) {
            const h = l.length;
            if (!h) return 0;
            let f, u, g, S, v = 0, d = 0, O = 0;
            if (this.interim[0]) {
              let _ = !1, b = this.interim[0];
              b &= (224 & b) == 192 ? 31 : (240 & b) == 224 ? 15 : 7;
              let w, x = 0;
              for (; (w = 63 & this.interim[++x]) && x < 4; ) b <<= 6, b |= w;
              const y = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, k = y - x;
              for (; O < k; ) {
                if (O >= h) return 0;
                if (w = l[O++], (192 & w) != 128) {
                  O--, _ = !0;
                  break;
                }
                this.interim[x++] = w, b <<= 6, b |= 63 & w;
              }
              _ || (y === 2 ? b < 128 ? O-- : c[v++] = b : y === 3 ? b < 2048 || b >= 55296 && b <= 57343 || b === 65279 || (c[v++] = b) : b < 65536 || b > 1114111 || (c[v++] = b)), this.interim.fill(0);
            }
            const p = h - 4;
            let m = O;
            for (; m < h; ) {
              for (; !(!(m < p) || 128 & (f = l[m]) || 128 & (u = l[m + 1]) || 128 & (g = l[m + 2]) || 128 & (S = l[m + 3])); ) c[v++] = f, c[v++] = u, c[v++] = g, c[v++] = S, m += 4;
              if (f = l[m++], f < 128) c[v++] = f;
              else if ((224 & f) == 192) {
                if (m >= h) return this.interim[0] = f, v;
                if (u = l[m++], (192 & u) != 128) {
                  m--;
                  continue;
                }
                if (d = (31 & f) << 6 | 63 & u, d < 128) {
                  m--;
                  continue;
                }
                c[v++] = d;
              } else if ((240 & f) == 224) {
                if (m >= h) return this.interim[0] = f, v;
                if (u = l[m++], (192 & u) != 128) {
                  m--;
                  continue;
                }
                if (m >= h) return this.interim[0] = f, this.interim[1] = u, v;
                if (g = l[m++], (192 & g) != 128) {
                  m--;
                  continue;
                }
                if (d = (15 & f) << 12 | (63 & u) << 6 | 63 & g, d < 2048 || d >= 55296 && d <= 57343 || d === 65279) continue;
                c[v++] = d;
              } else if ((248 & f) == 240) {
                if (m >= h) return this.interim[0] = f, v;
                if (u = l[m++], (192 & u) != 128) {
                  m--;
                  continue;
                }
                if (m >= h) return this.interim[0] = f, this.interim[1] = u, v;
                if (g = l[m++], (192 & g) != 128) {
                  m--;
                  continue;
                }
                if (m >= h) return this.interim[0] = f, this.interim[1] = u, this.interim[2] = g, v;
                if (S = l[m++], (192 & S) != 128) {
                  m--;
                  continue;
                }
                if (d = (7 & f) << 18 | (63 & u) << 12 | (63 & g) << 6 | 63 & S, d < 65536 || d > 1114111) continue;
                c[v++] = d;
              }
            }
            return v;
          }
        };
      }, 225: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeV6 = void 0;
        const l = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], c = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
        let h;
        a.UnicodeV6 = class {
          constructor() {
            if (this.version = "6", !h) {
              h = new Uint8Array(65536), h.fill(1), h[0] = 0, h.fill(0, 1, 32), h.fill(0, 127, 160), h.fill(2, 4352, 4448), h[9001] = 2, h[9002] = 2, h.fill(2, 11904, 42192), h[12351] = 1, h.fill(2, 44032, 55204), h.fill(2, 63744, 64256), h.fill(2, 65040, 65050), h.fill(2, 65072, 65136), h.fill(2, 65280, 65377), h.fill(2, 65504, 65511);
              for (let f = 0; f < l.length; ++f) h.fill(0, l[f][0], l[f][1] + 1);
            }
          }
          wcwidth(f) {
            return f < 32 ? 0 : f < 127 ? 1 : f < 65536 ? h[f] : function(u, g) {
              let S, v = 0, d = g.length - 1;
              if (u < g[0][0] || u > g[d][1]) return !1;
              for (; d >= v; ) if (S = v + d >> 1, u > g[S][1]) v = S + 1;
              else {
                if (!(u < g[S][0])) return !0;
                d = S - 1;
              }
              return !1;
            }(f, c) ? 0 : f >= 131072 && f <= 196605 || f >= 196608 && f <= 262141 ? 2 : 1;
          }
        };
      }, 5981: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.WriteBuffer = void 0;
        const c = l(8460), h = l(844);
        class f extends h.Disposable {
          constructor(g) {
            super(), this._action = g, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new c.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
          }
          handleUserInput() {
            this._didUserInput = !0;
          }
          writeSync(g, S) {
            if (S !== void 0 && this._syncCalls > S) return void (this._syncCalls = 0);
            if (this._pendingData += g.length, this._writeBuffer.push(g), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
            let v;
            for (this._isSyncWriting = !0; v = this._writeBuffer.shift(); ) {
              this._action(v);
              const d = this._callbacks.shift();
              d && d();
            }
            this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;
          }
          write(g, S) {
            if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
            if (!this._writeBuffer.length) {
              if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = !1, this._pendingData += g.length, this._writeBuffer.push(g), this._callbacks.push(S), void this._innerWrite();
              setTimeout(() => this._innerWrite());
            }
            this._pendingData += g.length, this._writeBuffer.push(g), this._callbacks.push(S);
          }
          _innerWrite(g = 0, S = !0) {
            const v = g || Date.now();
            for (; this._writeBuffer.length > this._bufferOffset; ) {
              const d = this._writeBuffer[this._bufferOffset], O = this._action(d, S);
              if (O) {
                const m = (_) => Date.now() - v >= 12 ? setTimeout(() => this._innerWrite(0, _)) : this._innerWrite(v, _);
                return void O.catch((_) => (queueMicrotask(() => {
                  throw _;
                }), Promise.resolve(!1))).then(m);
              }
              const p = this._callbacks[this._bufferOffset];
              if (p && p(), this._bufferOffset++, this._pendingData -= d.length, Date.now() - v >= 12) break;
            }
            this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
          }
        }
        a.WriteBuffer = f;
      }, 5941: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.toRgbString = a.parseColor = void 0;
        const l = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, c = /^[\da-f]+$/;
        function h(f, u) {
          const g = f.toString(16), S = g.length < 2 ? "0" + g : g;
          switch (u) {
            case 4:
              return g[0];
            case 8:
              return S;
            case 12:
              return (S + S).slice(0, 3);
            default:
              return S + S;
          }
        }
        a.parseColor = function(f) {
          if (!f) return;
          let u = f.toLowerCase();
          if (u.indexOf("rgb:") === 0) {
            u = u.slice(4);
            const g = l.exec(u);
            if (g) {
              const S = g[1] ? 15 : g[4] ? 255 : g[7] ? 4095 : 65535;
              return [Math.round(parseInt(g[1] || g[4] || g[7] || g[10], 16) / S * 255), Math.round(parseInt(g[2] || g[5] || g[8] || g[11], 16) / S * 255), Math.round(parseInt(g[3] || g[6] || g[9] || g[12], 16) / S * 255)];
            }
          } else if (u.indexOf("#") === 0 && (u = u.slice(1), c.exec(u) && [3, 6, 9, 12].includes(u.length))) {
            const g = u.length / 3, S = [0, 0, 0];
            for (let v = 0; v < 3; ++v) {
              const d = parseInt(u.slice(g * v, g * v + g), 16);
              S[v] = g === 1 ? d << 4 : g === 2 ? d : g === 3 ? d >> 4 : d >> 8;
            }
            return S;
          }
        }, a.toRgbString = function(f, u = 16) {
          const [g, S, v] = f;
          return `rgb:${h(g, u)}/${h(S, u)}/${h(v, u)}`;
        };
      }, 5770: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.PAYLOAD_LIMIT = void 0, a.PAYLOAD_LIMIT = 1e7;
      }, 6351: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DcsHandler = a.DcsParser = void 0;
        const c = l(482), h = l(8742), f = l(5770), u = [];
        a.DcsParser = class {
          constructor() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._active = u, this._ident = 0, this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = u;
          }
          registerHandler(S, v) {
            this._handlers[S] === void 0 && (this._handlers[S] = []);
            const d = this._handlers[S];
            return d.push(v), { dispose: () => {
              const O = d.indexOf(v);
              O !== -1 && d.splice(O, 1);
            } };
          }
          clearHandler(S) {
            this._handlers[S] && delete this._handlers[S];
          }
          setHandlerFallback(S) {
            this._handlerFb = S;
          }
          reset() {
            if (this._active.length) for (let S = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; S >= 0; --S) this._active[S].unhook(!1);
            this._stack.paused = !1, this._active = u, this._ident = 0;
          }
          hook(S, v) {
            if (this.reset(), this._ident = S, this._active = this._handlers[S] || u, this._active.length) for (let d = this._active.length - 1; d >= 0; d--) this._active[d].hook(v);
            else this._handlerFb(this._ident, "HOOK", v);
          }
          put(S, v, d) {
            if (this._active.length) for (let O = this._active.length - 1; O >= 0; O--) this._active[O].put(S, v, d);
            else this._handlerFb(this._ident, "PUT", (0, c.utf32ToString)(S, v, d));
          }
          unhook(S, v = !0) {
            if (this._active.length) {
              let d = !1, O = this._active.length - 1, p = !1;
              if (this._stack.paused && (O = this._stack.loopPosition - 1, d = v, p = this._stack.fallThrough, this._stack.paused = !1), !p && d === !1) {
                for (; O >= 0 && (d = this._active[O].unhook(S), d !== !0); O--) if (d instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = O, this._stack.fallThrough = !1, d;
                O--;
              }
              for (; O >= 0; O--) if (d = this._active[O].unhook(!1), d instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = O, this._stack.fallThrough = !0, d;
            } else this._handlerFb(this._ident, "UNHOOK", S);
            this._active = u, this._ident = 0;
          }
        };
        const g = new h.Params();
        g.addParam(0), a.DcsHandler = class {
          constructor(S) {
            this._handler = S, this._data = "", this._params = g, this._hitLimit = !1;
          }
          hook(S) {
            this._params = S.length > 1 || S.params[0] ? S.clone() : g, this._data = "", this._hitLimit = !1;
          }
          put(S, v, d) {
            this._hitLimit || (this._data += (0, c.utf32ToString)(S, v, d), this._data.length > f.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          unhook(S) {
            let v = !1;
            if (this._hitLimit) v = !1;
            else if (S && (v = this._handler(this._data, this._params), v instanceof Promise)) return v.then((d) => (this._params = g, this._data = "", this._hitLimit = !1, d));
            return this._params = g, this._data = "", this._hitLimit = !1, v;
          }
        };
      }, 2015: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.EscapeSequenceParser = a.VT500_TRANSITION_TABLE = a.TransitionTable = void 0;
        const c = l(844), h = l(8742), f = l(6242), u = l(6351);
        class g {
          constructor(O) {
            this.table = new Uint8Array(O);
          }
          setDefault(O, p) {
            this.table.fill(O << 4 | p);
          }
          add(O, p, m, _) {
            this.table[p << 8 | O] = m << 4 | _;
          }
          addMany(O, p, m, _) {
            for (let b = 0; b < O.length; b++) this.table[p << 8 | O[b]] = m << 4 | _;
          }
        }
        a.TransitionTable = g;
        const S = 160;
        a.VT500_TRANSITION_TABLE = function() {
          const d = new g(4095), O = Array.apply(null, Array(256)).map((x, y) => y), p = (x, y) => O.slice(x, y), m = p(32, 127), _ = p(0, 24);
          _.push(25), _.push.apply(_, p(28, 32));
          const b = p(0, 14);
          let w;
          for (w in d.setDefault(1, 0), d.addMany(m, 0, 2, 0), b) d.addMany([24, 26, 153, 154], w, 3, 0), d.addMany(p(128, 144), w, 3, 0), d.addMany(p(144, 152), w, 3, 0), d.add(156, w, 0, 0), d.add(27, w, 11, 1), d.add(157, w, 4, 8), d.addMany([152, 158, 159], w, 0, 7), d.add(155, w, 11, 3), d.add(144, w, 11, 9);
          return d.addMany(_, 0, 3, 0), d.addMany(_, 1, 3, 1), d.add(127, 1, 0, 1), d.addMany(_, 8, 0, 8), d.addMany(_, 3, 3, 3), d.add(127, 3, 0, 3), d.addMany(_, 4, 3, 4), d.add(127, 4, 0, 4), d.addMany(_, 6, 3, 6), d.addMany(_, 5, 3, 5), d.add(127, 5, 0, 5), d.addMany(_, 2, 3, 2), d.add(127, 2, 0, 2), d.add(93, 1, 4, 8), d.addMany(m, 8, 5, 8), d.add(127, 8, 5, 8), d.addMany([156, 27, 24, 26, 7], 8, 6, 0), d.addMany(p(28, 32), 8, 0, 8), d.addMany([88, 94, 95], 1, 0, 7), d.addMany(m, 7, 0, 7), d.addMany(_, 7, 0, 7), d.add(156, 7, 0, 0), d.add(127, 7, 0, 7), d.add(91, 1, 11, 3), d.addMany(p(64, 127), 3, 7, 0), d.addMany(p(48, 60), 3, 8, 4), d.addMany([60, 61, 62, 63], 3, 9, 4), d.addMany(p(48, 60), 4, 8, 4), d.addMany(p(64, 127), 4, 7, 0), d.addMany([60, 61, 62, 63], 4, 0, 6), d.addMany(p(32, 64), 6, 0, 6), d.add(127, 6, 0, 6), d.addMany(p(64, 127), 6, 0, 0), d.addMany(p(32, 48), 3, 9, 5), d.addMany(p(32, 48), 5, 9, 5), d.addMany(p(48, 64), 5, 0, 6), d.addMany(p(64, 127), 5, 7, 0), d.addMany(p(32, 48), 4, 9, 5), d.addMany(p(32, 48), 1, 9, 2), d.addMany(p(32, 48), 2, 9, 2), d.addMany(p(48, 127), 2, 10, 0), d.addMany(p(48, 80), 1, 10, 0), d.addMany(p(81, 88), 1, 10, 0), d.addMany([89, 90, 92], 1, 10, 0), d.addMany(p(96, 127), 1, 10, 0), d.add(80, 1, 11, 9), d.addMany(_, 9, 0, 9), d.add(127, 9, 0, 9), d.addMany(p(28, 32), 9, 0, 9), d.addMany(p(32, 48), 9, 9, 12), d.addMany(p(48, 60), 9, 8, 10), d.addMany([60, 61, 62, 63], 9, 9, 10), d.addMany(_, 11, 0, 11), d.addMany(p(32, 128), 11, 0, 11), d.addMany(p(28, 32), 11, 0, 11), d.addMany(_, 10, 0, 10), d.add(127, 10, 0, 10), d.addMany(p(28, 32), 10, 0, 10), d.addMany(p(48, 60), 10, 8, 10), d.addMany([60, 61, 62, 63], 10, 0, 11), d.addMany(p(32, 48), 10, 9, 12), d.addMany(_, 12, 0, 12), d.add(127, 12, 0, 12), d.addMany(p(28, 32), 12, 0, 12), d.addMany(p(32, 48), 12, 9, 12), d.addMany(p(48, 64), 12, 0, 11), d.addMany(p(64, 127), 12, 12, 13), d.addMany(p(64, 127), 10, 12, 13), d.addMany(p(64, 127), 9, 12, 13), d.addMany(_, 13, 13, 13), d.addMany(m, 13, 13, 13), d.add(127, 13, 0, 13), d.addMany([27, 156, 24, 26], 13, 14, 0), d.add(S, 0, 2, 0), d.add(S, 8, 5, 8), d.add(S, 6, 0, 6), d.add(S, 11, 0, 11), d.add(S, 13, 13, 13), d;
        }();
        class v extends c.Disposable {
          constructor(O = a.VT500_TRANSITION_TABLE) {
            super(), this._transitions = O, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new h.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (p, m, _) => {
            }, this._executeHandlerFb = (p) => {
            }, this._csiHandlerFb = (p, m) => {
            }, this._escHandlerFb = (p) => {
            }, this._errorHandlerFb = (p) => p, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, c.toDisposable)(() => {
              this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
            })), this._oscParser = this.register(new f.OscParser()), this._dcsParser = this.register(new u.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => !0);
          }
          _identifier(O, p = [64, 126]) {
            let m = 0;
            if (O.prefix) {
              if (O.prefix.length > 1) throw new Error("only one byte as prefix supported");
              if (m = O.prefix.charCodeAt(0), m && 60 > m || m > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
            }
            if (O.intermediates) {
              if (O.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
              for (let b = 0; b < O.intermediates.length; ++b) {
                const w = O.intermediates.charCodeAt(b);
                if (32 > w || w > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
                m <<= 8, m |= w;
              }
            }
            if (O.final.length !== 1) throw new Error("final must be a single byte");
            const _ = O.final.charCodeAt(0);
            if (p[0] > _ || _ > p[1]) throw new Error(`final must be in range ${p[0]} .. ${p[1]}`);
            return m <<= 8, m |= _, m;
          }
          identToString(O) {
            const p = [];
            for (; O; ) p.push(String.fromCharCode(255 & O)), O >>= 8;
            return p.reverse().join("");
          }
          setPrintHandler(O) {
            this._printHandler = O;
          }
          clearPrintHandler() {
            this._printHandler = this._printHandlerFb;
          }
          registerEscHandler(O, p) {
            const m = this._identifier(O, [48, 126]);
            this._escHandlers[m] === void 0 && (this._escHandlers[m] = []);
            const _ = this._escHandlers[m];
            return _.push(p), { dispose: () => {
              const b = _.indexOf(p);
              b !== -1 && _.splice(b, 1);
            } };
          }
          clearEscHandler(O) {
            this._escHandlers[this._identifier(O, [48, 126])] && delete this._escHandlers[this._identifier(O, [48, 126])];
          }
          setEscHandlerFallback(O) {
            this._escHandlerFb = O;
          }
          setExecuteHandler(O, p) {
            this._executeHandlers[O.charCodeAt(0)] = p;
          }
          clearExecuteHandler(O) {
            this._executeHandlers[O.charCodeAt(0)] && delete this._executeHandlers[O.charCodeAt(0)];
          }
          setExecuteHandlerFallback(O) {
            this._executeHandlerFb = O;
          }
          registerCsiHandler(O, p) {
            const m = this._identifier(O);
            this._csiHandlers[m] === void 0 && (this._csiHandlers[m] = []);
            const _ = this._csiHandlers[m];
            return _.push(p), { dispose: () => {
              const b = _.indexOf(p);
              b !== -1 && _.splice(b, 1);
            } };
          }
          clearCsiHandler(O) {
            this._csiHandlers[this._identifier(O)] && delete this._csiHandlers[this._identifier(O)];
          }
          setCsiHandlerFallback(O) {
            this._csiHandlerFb = O;
          }
          registerDcsHandler(O, p) {
            return this._dcsParser.registerHandler(this._identifier(O), p);
          }
          clearDcsHandler(O) {
            this._dcsParser.clearHandler(this._identifier(O));
          }
          setDcsHandlerFallback(O) {
            this._dcsParser.setHandlerFallback(O);
          }
          registerOscHandler(O, p) {
            return this._oscParser.registerHandler(O, p);
          }
          clearOscHandler(O) {
            this._oscParser.clearHandler(O);
          }
          setOscHandlerFallback(O) {
            this._oscParser.setHandlerFallback(O);
          }
          setErrorHandler(O) {
            this._errorHandler = O;
          }
          clearErrorHandler() {
            this._errorHandler = this._errorHandlerFb;
          }
          reset() {
            this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
          }
          _preserveStack(O, p, m, _, b) {
            this._parseStack.state = O, this._parseStack.handlers = p, this._parseStack.handlerPos = m, this._parseStack.transition = _, this._parseStack.chunkPos = b;
          }
          parse(O, p, m) {
            let _, b = 0, w = 0, x = 0;
            if (this._parseStack.state) if (this._parseStack.state === 2) this._parseStack.state = 0, x = this._parseStack.chunkPos + 1;
            else {
              if (m === void 0 || this._parseStack.state === 1) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
              const y = this._parseStack.handlers;
              let k = this._parseStack.handlerPos - 1;
              switch (this._parseStack.state) {
                case 3:
                  if (m === !1 && k > -1) {
                    for (; k >= 0 && (_ = y[k](this._params), _ !== !0); k--) if (_ instanceof Promise) return this._parseStack.handlerPos = k, _;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 4:
                  if (m === !1 && k > -1) {
                    for (; k >= 0 && (_ = y[k](), _ !== !0); k--) if (_ instanceof Promise) return this._parseStack.handlerPos = k, _;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 6:
                  if (b = O[this._parseStack.chunkPos], _ = this._dcsParser.unhook(b !== 24 && b !== 26, m), _) return _;
                  b === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 5:
                  if (b = O[this._parseStack.chunkPos], _ = this._oscParser.end(b !== 24 && b !== 26, m), _) return _;
                  b === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
              }
              this._parseStack.state = 0, x = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
            }
            for (let y = x; y < p; ++y) {
              switch (b = O[y], w = this._transitions.table[this.currentState << 8 | (b < 160 ? b : S)], w >> 4) {
                case 2:
                  for (let E = y + 1; ; ++E) {
                    if (E >= p || (b = O[E]) < 32 || b > 126 && b < S) {
                      this._printHandler(O, y, E), y = E - 1;
                      break;
                    }
                    if (++E >= p || (b = O[E]) < 32 || b > 126 && b < S) {
                      this._printHandler(O, y, E), y = E - 1;
                      break;
                    }
                    if (++E >= p || (b = O[E]) < 32 || b > 126 && b < S) {
                      this._printHandler(O, y, E), y = E - 1;
                      break;
                    }
                    if (++E >= p || (b = O[E]) < 32 || b > 126 && b < S) {
                      this._printHandler(O, y, E), y = E - 1;
                      break;
                    }
                  }
                  break;
                case 3:
                  this._executeHandlers[b] ? this._executeHandlers[b]() : this._executeHandlerFb(b), this.precedingCodepoint = 0;
                  break;
                case 0:
                  break;
                case 1:
                  if (this._errorHandler({ position: y, code: b, currentState: this.currentState, collect: this._collect, params: this._params, abort: !1 }).abort) return;
                  break;
                case 7:
                  const k = this._csiHandlers[this._collect << 8 | b];
                  let T = k ? k.length - 1 : -1;
                  for (; T >= 0 && (_ = k[T](this._params), _ !== !0); T--) if (_ instanceof Promise) return this._preserveStack(3, k, T, w, y), _;
                  T < 0 && this._csiHandlerFb(this._collect << 8 | b, this._params), this.precedingCodepoint = 0;
                  break;
                case 8:
                  do
                    switch (b) {
                      case 59:
                        this._params.addParam(0);
                        break;
                      case 58:
                        this._params.addSubParam(-1);
                        break;
                      default:
                        this._params.addDigit(b - 48);
                    }
                  while (++y < p && (b = O[y]) > 47 && b < 60);
                  y--;
                  break;
                case 9:
                  this._collect <<= 8, this._collect |= b;
                  break;
                case 10:
                  const R = this._escHandlers[this._collect << 8 | b];
                  let $ = R ? R.length - 1 : -1;
                  for (; $ >= 0 && (_ = R[$](), _ !== !0); $--) if (_ instanceof Promise) return this._preserveStack(4, R, $, w, y), _;
                  $ < 0 && this._escHandlerFb(this._collect << 8 | b), this.precedingCodepoint = 0;
                  break;
                case 11:
                  this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 12:
                  this._dcsParser.hook(this._collect << 8 | b, this._params);
                  break;
                case 13:
                  for (let E = y + 1; ; ++E) if (E >= p || (b = O[E]) === 24 || b === 26 || b === 27 || b > 127 && b < S) {
                    this._dcsParser.put(O, y, E), y = E - 1;
                    break;
                  }
                  break;
                case 14:
                  if (_ = this._dcsParser.unhook(b !== 24 && b !== 26), _) return this._preserveStack(6, [], 0, w, y), _;
                  b === 27 && (w |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                  break;
                case 4:
                  this._oscParser.start();
                  break;
                case 5:
                  for (let E = y + 1; ; E++) if (E >= p || (b = O[E]) < 32 || b > 127 && b < S) {
                    this._oscParser.put(O, y, E), y = E - 1;
                    break;
                  }
                  break;
                case 6:
                  if (_ = this._oscParser.end(b !== 24 && b !== 26), _) return this._preserveStack(5, [], 0, w, y), _;
                  b === 27 && (w |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
              }
              this.currentState = 15 & w;
            }
          }
        }
        a.EscapeSequenceParser = v;
      }, 6242: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OscHandler = a.OscParser = void 0;
        const c = l(5770), h = l(482), f = [];
        a.OscParser = class {
          constructor() {
            this._state = 0, this._active = f, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          registerHandler(u, g) {
            this._handlers[u] === void 0 && (this._handlers[u] = []);
            const S = this._handlers[u];
            return S.push(g), { dispose: () => {
              const v = S.indexOf(g);
              v !== -1 && S.splice(v, 1);
            } };
          }
          clearHandler(u) {
            this._handlers[u] && delete this._handlers[u];
          }
          setHandlerFallback(u) {
            this._handlerFb = u;
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = f;
          }
          reset() {
            if (this._state === 2) for (let u = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; u >= 0; --u) this._active[u].end(!1);
            this._stack.paused = !1, this._active = f, this._id = -1, this._state = 0;
          }
          _start() {
            if (this._active = this._handlers[this._id] || f, this._active.length) for (let u = this._active.length - 1; u >= 0; u--) this._active[u].start();
            else this._handlerFb(this._id, "START");
          }
          _put(u, g, S) {
            if (this._active.length) for (let v = this._active.length - 1; v >= 0; v--) this._active[v].put(u, g, S);
            else this._handlerFb(this._id, "PUT", (0, h.utf32ToString)(u, g, S));
          }
          start() {
            this.reset(), this._state = 1;
          }
          put(u, g, S) {
            if (this._state !== 3) {
              if (this._state === 1) for (; g < S; ) {
                const v = u[g++];
                if (v === 59) {
                  this._state = 2, this._start();
                  break;
                }
                if (v < 48 || 57 < v) return void (this._state = 3);
                this._id === -1 && (this._id = 0), this._id = 10 * this._id + v - 48;
              }
              this._state === 2 && S - g > 0 && this._put(u, g, S);
            }
          }
          end(u, g = !0) {
            if (this._state !== 0) {
              if (this._state !== 3) if (this._state === 1 && this._start(), this._active.length) {
                let S = !1, v = this._active.length - 1, d = !1;
                if (this._stack.paused && (v = this._stack.loopPosition - 1, S = g, d = this._stack.fallThrough, this._stack.paused = !1), !d && S === !1) {
                  for (; v >= 0 && (S = this._active[v].end(u), S !== !0); v--) if (S instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = v, this._stack.fallThrough = !1, S;
                  v--;
                }
                for (; v >= 0; v--) if (S = this._active[v].end(!1), S instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = v, this._stack.fallThrough = !0, S;
              } else this._handlerFb(this._id, "END", u);
              this._active = f, this._id = -1, this._state = 0;
            }
          }
        }, a.OscHandler = class {
          constructor(u) {
            this._handler = u, this._data = "", this._hitLimit = !1;
          }
          start() {
            this._data = "", this._hitLimit = !1;
          }
          put(u, g, S) {
            this._hitLimit || (this._data += (0, h.utf32ToString)(u, g, S), this._data.length > c.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          end(u) {
            let g = !1;
            if (this._hitLimit) g = !1;
            else if (u && (g = this._handler(this._data), g instanceof Promise)) return g.then((S) => (this._data = "", this._hitLimit = !1, S));
            return this._data = "", this._hitLimit = !1, g;
          }
        };
      }, 8742: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.Params = void 0;
        const l = 2147483647;
        class c {
          static fromArray(f) {
            const u = new c();
            if (!f.length) return u;
            for (let g = Array.isArray(f[0]) ? 1 : 0; g < f.length; ++g) {
              const S = f[g];
              if (Array.isArray(S)) for (let v = 0; v < S.length; ++v) u.addSubParam(S[v]);
              else u.addParam(S);
            }
            return u;
          }
          constructor(f = 32, u = 32) {
            if (this.maxLength = f, this.maxSubParamsLength = u, u > 256) throw new Error("maxSubParamsLength must not be greater than 256");
            this.params = new Int32Array(f), this.length = 0, this._subParams = new Int32Array(u), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(f), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          clone() {
            const f = new c(this.maxLength, this.maxSubParamsLength);
            return f.params.set(this.params), f.length = this.length, f._subParams.set(this._subParams), f._subParamsLength = this._subParamsLength, f._subParamsIdx.set(this._subParamsIdx), f._rejectDigits = this._rejectDigits, f._rejectSubDigits = this._rejectSubDigits, f._digitIsSub = this._digitIsSub, f;
          }
          toArray() {
            const f = [];
            for (let u = 0; u < this.length; ++u) {
              f.push(this.params[u]);
              const g = this._subParamsIdx[u] >> 8, S = 255 & this._subParamsIdx[u];
              S - g > 0 && f.push(Array.prototype.slice.call(this._subParams, g, S));
            }
            return f;
          }
          reset() {
            this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          addParam(f) {
            if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0;
            else {
              if (f < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = f > l ? l : f;
            }
          }
          addSubParam(f) {
            if (this._digitIsSub = !0, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0;
            else {
              if (f < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParams[this._subParamsLength++] = f > l ? l : f, this._subParamsIdx[this.length - 1]++;
            }
          }
          hasSubParams(f) {
            return (255 & this._subParamsIdx[f]) - (this._subParamsIdx[f] >> 8) > 0;
          }
          getSubParams(f) {
            const u = this._subParamsIdx[f] >> 8, g = 255 & this._subParamsIdx[f];
            return g - u > 0 ? this._subParams.subarray(u, g) : null;
          }
          getSubParamsAll() {
            const f = {};
            for (let u = 0; u < this.length; ++u) {
              const g = this._subParamsIdx[u] >> 8, S = 255 & this._subParamsIdx[u];
              S - g > 0 && (f[u] = this._subParams.slice(g, S));
            }
            return f;
          }
          addDigit(f) {
            let u;
            if (this._rejectDigits || !(u = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
            const g = this._digitIsSub ? this._subParams : this.params, S = g[u - 1];
            g[u - 1] = ~S ? Math.min(10 * S + f, l) : f;
          }
        }
        a.Params = c;
      }, 5741: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.AddonManager = void 0, a.AddonManager = class {
          constructor() {
            this._addons = [];
          }
          dispose() {
            for (let l = this._addons.length - 1; l >= 0; l--) this._addons[l].instance.dispose();
          }
          loadAddon(l, c) {
            const h = { instance: c, dispose: c.dispose, isDisposed: !1 };
            this._addons.push(h), c.dispose = () => this._wrappedAddonDispose(h), c.activate(l);
          }
          _wrappedAddonDispose(l) {
            if (l.isDisposed) return;
            let c = -1;
            for (let h = 0; h < this._addons.length; h++) if (this._addons[h] === l) {
              c = h;
              break;
            }
            if (c === -1) throw new Error("Could not dispose an addon that has not been loaded");
            l.isDisposed = !0, l.dispose.apply(l.instance), this._addons.splice(c, 1);
          }
        };
      }, 8771: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferApiView = void 0;
        const c = l(3785), h = l(511);
        a.BufferApiView = class {
          constructor(f, u) {
            this._buffer = f, this.type = u;
          }
          init(f) {
            return this._buffer = f, this;
          }
          get cursorY() {
            return this._buffer.y;
          }
          get cursorX() {
            return this._buffer.x;
          }
          get viewportY() {
            return this._buffer.ydisp;
          }
          get baseY() {
            return this._buffer.ybase;
          }
          get length() {
            return this._buffer.lines.length;
          }
          getLine(f) {
            const u = this._buffer.lines.get(f);
            if (u) return new c.BufferLineApiView(u);
          }
          getNullCell() {
            return new h.CellData();
          }
        };
      }, 3785: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLineApiView = void 0;
        const c = l(511);
        a.BufferLineApiView = class {
          constructor(h) {
            this._line = h;
          }
          get isWrapped() {
            return this._line.isWrapped;
          }
          get length() {
            return this._line.length;
          }
          getCell(h, f) {
            if (!(h < 0 || h >= this._line.length)) return f ? (this._line.loadCell(h, f), f) : this._line.loadCell(h, new c.CellData());
          }
          translateToString(h, f, u) {
            return this._line.translateToString(h, f, u);
          }
        };
      }, 8285: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferNamespaceApi = void 0;
        const c = l(8771), h = l(8460), f = l(844);
        class u extends f.Disposable {
          constructor(S) {
            super(), this._core = S, this._onBufferChange = this.register(new h.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new c.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new c.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
          }
          get active() {
            if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
            if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
            throw new Error("Active buffer is neither normal nor alternate");
          }
          get normal() {
            return this._normal.init(this._core.buffers.normal);
          }
          get alternate() {
            return this._alternate.init(this._core.buffers.alt);
          }
        }
        a.BufferNamespaceApi = u;
      }, 7975: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.ParserApi = void 0, a.ParserApi = class {
          constructor(l) {
            this._core = l;
          }
          registerCsiHandler(l, c) {
            return this._core.registerCsiHandler(l, (h) => c(h.toArray()));
          }
          addCsiHandler(l, c) {
            return this.registerCsiHandler(l, c);
          }
          registerDcsHandler(l, c) {
            return this._core.registerDcsHandler(l, (h, f) => c(h, f.toArray()));
          }
          addDcsHandler(l, c) {
            return this.registerDcsHandler(l, c);
          }
          registerEscHandler(l, c) {
            return this._core.registerEscHandler(l, c);
          }
          addEscHandler(l, c) {
            return this.registerEscHandler(l, c);
          }
          registerOscHandler(l, c) {
            return this._core.registerOscHandler(l, c);
          }
          addOscHandler(l, c) {
            return this.registerOscHandler(l, c);
          }
        };
      }, 7090: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeApi = void 0, a.UnicodeApi = class {
          constructor(l) {
            this._core = l;
          }
          register(l) {
            this._core.unicodeService.register(l);
          }
          get versions() {
            return this._core.unicodeService.versions;
          }
          get activeVersion() {
            return this._core.unicodeService.activeVersion;
          }
          set activeVersion(l) {
            this._core.unicodeService.activeVersion = l;
          }
        };
      }, 744: function(o, a, l) {
        var c = this && this.__decorate || function(d, O, p, m) {
          var _, b = arguments.length, w = b < 3 ? O : m === null ? m = Object.getOwnPropertyDescriptor(O, p) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(d, O, p, m);
          else for (var x = d.length - 1; x >= 0; x--) (_ = d[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(O, p, w) : _(O, p)) || w);
          return b > 3 && w && Object.defineProperty(O, p, w), w;
        }, h = this && this.__param || function(d, O) {
          return function(p, m) {
            O(p, m, d);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferService = a.MINIMUM_ROWS = a.MINIMUM_COLS = void 0;
        const f = l(8460), u = l(844), g = l(5295), S = l(2585);
        a.MINIMUM_COLS = 2, a.MINIMUM_ROWS = 1;
        let v = a.BufferService = class extends u.Disposable {
          get buffer() {
            return this.buffers.active;
          }
          constructor(d) {
            super(), this.isUserScrolling = !1, this._onResize = this.register(new f.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new f.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(d.rawOptions.cols || 0, a.MINIMUM_COLS), this.rows = Math.max(d.rawOptions.rows || 0, a.MINIMUM_ROWS), this.buffers = this.register(new g.BufferSet(d, this));
          }
          resize(d, O) {
            this.cols = d, this.rows = O, this.buffers.resize(d, O), this._onResize.fire({ cols: d, rows: O });
          }
          reset() {
            this.buffers.reset(), this.isUserScrolling = !1;
          }
          scroll(d, O = !1) {
            const p = this.buffer;
            let m;
            m = this._cachedBlankLine, m && m.length === this.cols && m.getFg(0) === d.fg && m.getBg(0) === d.bg || (m = p.getBlankLine(d, O), this._cachedBlankLine = m), m.isWrapped = O;
            const _ = p.ybase + p.scrollTop, b = p.ybase + p.scrollBottom;
            if (p.scrollTop === 0) {
              const w = p.lines.isFull;
              b === p.lines.length - 1 ? w ? p.lines.recycle().copyFrom(m) : p.lines.push(m.clone()) : p.lines.splice(b + 1, 0, m.clone()), w ? this.isUserScrolling && (p.ydisp = Math.max(p.ydisp - 1, 0)) : (p.ybase++, this.isUserScrolling || p.ydisp++);
            } else {
              const w = b - _ + 1;
              p.lines.shiftElements(_ + 1, w - 1, -1), p.lines.set(b, m.clone());
            }
            this.isUserScrolling || (p.ydisp = p.ybase), this._onScroll.fire(p.ydisp);
          }
          scrollLines(d, O, p) {
            const m = this.buffer;
            if (d < 0) {
              if (m.ydisp === 0) return;
              this.isUserScrolling = !0;
            } else d + m.ydisp >= m.ybase && (this.isUserScrolling = !1);
            const _ = m.ydisp;
            m.ydisp = Math.max(Math.min(m.ydisp + d, m.ybase), 0), _ !== m.ydisp && (O || this._onScroll.fire(m.ydisp));
          }
        };
        a.BufferService = v = c([h(0, S.IOptionsService)], v);
      }, 7994: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CharsetService = void 0, a.CharsetService = class {
          constructor() {
            this.glevel = 0, this._charsets = [];
          }
          reset() {
            this.charset = void 0, this._charsets = [], this.glevel = 0;
          }
          setgLevel(l) {
            this.glevel = l, this.charset = this._charsets[l];
          }
          setgCharset(l, c) {
            this._charsets[l] = c, this.glevel === l && (this.charset = c);
          }
        };
      }, 1753: function(o, a, l) {
        var c = this && this.__decorate || function(m, _, b, w) {
          var x, y = arguments.length, k = y < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, b) : w;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(m, _, b, w);
          else for (var T = m.length - 1; T >= 0; T--) (x = m[T]) && (k = (y < 3 ? x(k) : y > 3 ? x(_, b, k) : x(_, b)) || k);
          return y > 3 && k && Object.defineProperty(_, b, k), k;
        }, h = this && this.__param || function(m, _) {
          return function(b, w) {
            _(b, w, m);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreMouseService = void 0;
        const f = l(2585), u = l(8460), g = l(844), S = { NONE: { events: 0, restrict: () => !1 }, X10: { events: 1, restrict: (m) => m.button !== 4 && m.action === 1 && (m.ctrl = !1, m.alt = !1, m.shift = !1, !0) }, VT200: { events: 19, restrict: (m) => m.action !== 32 }, DRAG: { events: 23, restrict: (m) => m.action !== 32 || m.button !== 3 }, ANY: { events: 31, restrict: (m) => !0 } };
        function v(m, _) {
          let b = (m.ctrl ? 16 : 0) | (m.shift ? 4 : 0) | (m.alt ? 8 : 0);
          return m.button === 4 ? (b |= 64, b |= m.action) : (b |= 3 & m.button, 4 & m.button && (b |= 64), 8 & m.button && (b |= 128), m.action === 32 ? b |= 32 : m.action !== 0 || _ || (b |= 3)), b;
        }
        const d = String.fromCharCode, O = { DEFAULT: (m) => {
          const _ = [v(m, !1) + 32, m.col + 32, m.row + 32];
          return _[0] > 255 || _[1] > 255 || _[2] > 255 ? "" : `\x1B[M${d(_[0])}${d(_[1])}${d(_[2])}`;
        }, SGR: (m) => {
          const _ = m.action === 0 && m.button !== 4 ? "m" : "M";
          return `\x1B[<${v(m, !0)};${m.col};${m.row}${_}`;
        }, SGR_PIXELS: (m) => {
          const _ = m.action === 0 && m.button !== 4 ? "m" : "M";
          return `\x1B[<${v(m, !0)};${m.x};${m.y}${_}`;
        } };
        let p = a.CoreMouseService = class extends g.Disposable {
          constructor(m, _) {
            super(), this._bufferService = m, this._coreService = _, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new u.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
            for (const b of Object.keys(S)) this.addProtocol(b, S[b]);
            for (const b of Object.keys(O)) this.addEncoding(b, O[b]);
            this.reset();
          }
          addProtocol(m, _) {
            this._protocols[m] = _;
          }
          addEncoding(m, _) {
            this._encodings[m] = _;
          }
          get activeProtocol() {
            return this._activeProtocol;
          }
          get areMouseEventsActive() {
            return this._protocols[this._activeProtocol].events !== 0;
          }
          set activeProtocol(m) {
            if (!this._protocols[m]) throw new Error(`unknown protocol "${m}"`);
            this._activeProtocol = m, this._onProtocolChange.fire(this._protocols[m].events);
          }
          get activeEncoding() {
            return this._activeEncoding;
          }
          set activeEncoding(m) {
            if (!this._encodings[m]) throw new Error(`unknown encoding "${m}"`);
            this._activeEncoding = m;
          }
          reset() {
            this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
          }
          triggerMouseEvent(m) {
            if (m.col < 0 || m.col >= this._bufferService.cols || m.row < 0 || m.row >= this._bufferService.rows || m.button === 4 && m.action === 32 || m.button === 3 && m.action !== 32 || m.button !== 4 && (m.action === 2 || m.action === 3) || (m.col++, m.row++, m.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, m, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(m)) return !1;
            const _ = this._encodings[this._activeEncoding](m);
            return _ && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(_) : this._coreService.triggerDataEvent(_, !0)), this._lastEvent = m, !0;
          }
          explainEvents(m) {
            return { down: !!(1 & m), up: !!(2 & m), drag: !!(4 & m), move: !!(8 & m), wheel: !!(16 & m) };
          }
          _equalEvents(m, _, b) {
            if (b) {
              if (m.x !== _.x || m.y !== _.y) return !1;
            } else if (m.col !== _.col || m.row !== _.row) return !1;
            return m.button === _.button && m.action === _.action && m.ctrl === _.ctrl && m.alt === _.alt && m.shift === _.shift;
          }
        };
        a.CoreMouseService = p = c([h(0, f.IBufferService), h(1, f.ICoreService)], p);
      }, 6975: function(o, a, l) {
        var c = this && this.__decorate || function(p, m, _, b) {
          var w, x = arguments.length, y = x < 3 ? m : b === null ? b = Object.getOwnPropertyDescriptor(m, _) : b;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") y = Reflect.decorate(p, m, _, b);
          else for (var k = p.length - 1; k >= 0; k--) (w = p[k]) && (y = (x < 3 ? w(y) : x > 3 ? w(m, _, y) : w(m, _)) || y);
          return x > 3 && y && Object.defineProperty(m, _, y), y;
        }, h = this && this.__param || function(p, m) {
          return function(_, b) {
            m(_, b, p);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreService = void 0;
        const f = l(1439), u = l(8460), g = l(844), S = l(2585), v = Object.freeze({ insertMode: !1 }), d = Object.freeze({ applicationCursorKeys: !1, applicationKeypad: !1, bracketedPasteMode: !1, origin: !1, reverseWraparound: !1, sendFocus: !1, wraparound: !0 });
        let O = a.CoreService = class extends g.Disposable {
          constructor(p, m, _) {
            super(), this._bufferService = p, this._logService = m, this._optionsService = _, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new u.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new u.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new u.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new u.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, f.clone)(v), this.decPrivateModes = (0, f.clone)(d);
          }
          reset() {
            this.modes = (0, f.clone)(v), this.decPrivateModes = (0, f.clone)(d);
          }
          triggerDataEvent(p, m = !1) {
            if (this._optionsService.rawOptions.disableStdin) return;
            const _ = this._bufferService.buffer;
            m && this._optionsService.rawOptions.scrollOnUserInput && _.ybase !== _.ydisp && this._onRequestScrollToBottom.fire(), m && this._onUserInput.fire(), this._logService.debug(`sending data "${p}"`, () => p.split("").map((b) => b.charCodeAt(0))), this._onData.fire(p);
          }
          triggerBinaryEvent(p) {
            this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${p}"`, () => p.split("").map((m) => m.charCodeAt(0))), this._onBinary.fire(p));
          }
        };
        a.CoreService = O = c([h(0, S.IBufferService), h(1, S.ILogService), h(2, S.IOptionsService)], O);
      }, 9074: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.DecorationService = void 0;
        const c = l(8055), h = l(8460), f = l(844), u = l(6106);
        let g = 0, S = 0;
        class v extends f.Disposable {
          get decorations() {
            return this._decorations.values();
          }
          constructor() {
            super(), this._decorations = new u.SortedList((p) => p?.marker.line), this._onDecorationRegistered = this.register(new h.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new h.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, f.toDisposable)(() => this.reset()));
          }
          registerDecoration(p) {
            if (p.marker.isDisposed) return;
            const m = new d(p);
            if (m) {
              const _ = m.marker.onDispose(() => m.dispose());
              m.onDispose(() => {
                m && (this._decorations.delete(m) && this._onDecorationRemoved.fire(m), _.dispose());
              }), this._decorations.insert(m), this._onDecorationRegistered.fire(m);
            }
            return m;
          }
          reset() {
            for (const p of this._decorations.values()) p.dispose();
            this._decorations.clear();
          }
          *getDecorationsAtCell(p, m, _) {
            var b, w, x;
            let y = 0, k = 0;
            for (const T of this._decorations.getKeyIterator(m)) y = (b = T.options.x) !== null && b !== void 0 ? b : 0, k = y + ((w = T.options.width) !== null && w !== void 0 ? w : 1), p >= y && p < k && (!_ || ((x = T.options.layer) !== null && x !== void 0 ? x : "bottom") === _) && (yield T);
          }
          forEachDecorationAtCell(p, m, _, b) {
            this._decorations.forEachByKey(m, (w) => {
              var x, y, k;
              g = (x = w.options.x) !== null && x !== void 0 ? x : 0, S = g + ((y = w.options.width) !== null && y !== void 0 ? y : 1), p >= g && p < S && (!_ || ((k = w.options.layer) !== null && k !== void 0 ? k : "bottom") === _) && b(w);
            });
          }
        }
        a.DecorationService = v;
        class d extends f.Disposable {
          get isDisposed() {
            return this._isDisposed;
          }
          get backgroundColorRGB() {
            return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = c.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
          }
          get foregroundColorRGB() {
            return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = c.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
          }
          constructor(p) {
            super(), this.options = p, this.onRenderEmitter = this.register(new h.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new h.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = p.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
          }
          dispose() {
            this._onDispose.fire(), super.dispose();
          }
        }
      }, 4348: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.InstantiationService = a.ServiceCollection = void 0;
        const c = l(2585), h = l(8343);
        class f {
          constructor(...g) {
            this._entries = /* @__PURE__ */ new Map();
            for (const [S, v] of g) this.set(S, v);
          }
          set(g, S) {
            const v = this._entries.get(g);
            return this._entries.set(g, S), v;
          }
          forEach(g) {
            for (const [S, v] of this._entries.entries()) g(S, v);
          }
          has(g) {
            return this._entries.has(g);
          }
          get(g) {
            return this._entries.get(g);
          }
        }
        a.ServiceCollection = f, a.InstantiationService = class {
          constructor() {
            this._services = new f(), this._services.set(c.IInstantiationService, this);
          }
          setService(u, g) {
            this._services.set(u, g);
          }
          getService(u) {
            return this._services.get(u);
          }
          createInstance(u, ...g) {
            const S = (0, h.getServiceDependencies)(u).sort((O, p) => O.index - p.index), v = [];
            for (const O of S) {
              const p = this._services.get(O.id);
              if (!p) throw new Error(`[createInstance] ${u.name} depends on UNKNOWN service ${O.id}.`);
              v.push(p);
            }
            const d = S.length > 0 ? S[0].index : g.length;
            if (g.length !== d) throw new Error(`[createInstance] First service dependency of ${u.name} at position ${d + 1} conflicts with ${g.length} static arguments`);
            return new u(...g, ...v);
          }
        };
      }, 7866: function(o, a, l) {
        var c = this && this.__decorate || function(d, O, p, m) {
          var _, b = arguments.length, w = b < 3 ? O : m === null ? m = Object.getOwnPropertyDescriptor(O, p) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(d, O, p, m);
          else for (var x = d.length - 1; x >= 0; x--) (_ = d[x]) && (w = (b < 3 ? _(w) : b > 3 ? _(O, p, w) : _(O, p)) || w);
          return b > 3 && w && Object.defineProperty(O, p, w), w;
        }, h = this && this.__param || function(d, O) {
          return function(p, m) {
            O(p, m, d);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.traceCall = a.setTraceLogger = a.LogService = void 0;
        const f = l(844), u = l(2585), g = { trace: u.LogLevelEnum.TRACE, debug: u.LogLevelEnum.DEBUG, info: u.LogLevelEnum.INFO, warn: u.LogLevelEnum.WARN, error: u.LogLevelEnum.ERROR, off: u.LogLevelEnum.OFF };
        let S, v = a.LogService = class extends f.Disposable {
          get logLevel() {
            return this._logLevel;
          }
          constructor(d) {
            super(), this._optionsService = d, this._logLevel = u.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), S = this;
          }
          _updateLogLevel() {
            this._logLevel = g[this._optionsService.rawOptions.logLevel];
          }
          _evalLazyOptionalParams(d) {
            for (let O = 0; O < d.length; O++) typeof d[O] == "function" && (d[O] = d[O]());
          }
          _log(d, O, p) {
            this._evalLazyOptionalParams(p), d.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + O, ...p);
          }
          trace(d, ...O) {
            var p, m;
            this._logLevel <= u.LogLevelEnum.TRACE && this._log((m = (p = this._optionsService.options.logger) === null || p === void 0 ? void 0 : p.trace.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.log, d, O);
          }
          debug(d, ...O) {
            var p, m;
            this._logLevel <= u.LogLevelEnum.DEBUG && this._log((m = (p = this._optionsService.options.logger) === null || p === void 0 ? void 0 : p.debug.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.log, d, O);
          }
          info(d, ...O) {
            var p, m;
            this._logLevel <= u.LogLevelEnum.INFO && this._log((m = (p = this._optionsService.options.logger) === null || p === void 0 ? void 0 : p.info.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.info, d, O);
          }
          warn(d, ...O) {
            var p, m;
            this._logLevel <= u.LogLevelEnum.WARN && this._log((m = (p = this._optionsService.options.logger) === null || p === void 0 ? void 0 : p.warn.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.warn, d, O);
          }
          error(d, ...O) {
            var p, m;
            this._logLevel <= u.LogLevelEnum.ERROR && this._log((m = (p = this._optionsService.options.logger) === null || p === void 0 ? void 0 : p.error.bind(this._optionsService.options.logger)) !== null && m !== void 0 ? m : console.error, d, O);
          }
        };
        a.LogService = v = c([h(0, u.IOptionsService)], v), a.setTraceLogger = function(d) {
          S = d;
        }, a.traceCall = function(d, O, p) {
          if (typeof p.value != "function") throw new Error("not supported");
          const m = p.value;
          p.value = function(..._) {
            if (S.logLevel !== u.LogLevelEnum.TRACE) return m.apply(this, _);
            S.trace(`GlyphRenderer#${m.name}(${_.map((w) => JSON.stringify(w)).join(", ")})`);
            const b = m.apply(this, _);
            return S.trace(`GlyphRenderer#${m.name} return`, b), b;
          };
        };
      }, 7302: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OptionsService = a.DEFAULT_OPTIONS = void 0;
        const c = l(8460), h = l(844), f = l(6114);
        a.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: !1, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: !0, drawBoldTextInBrightColors: !0, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: !1, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: !0, scrollSensitivity: 1, screenReaderMode: !1, smoothScrollDuration: 0, macOptionIsMeta: !1, macOptionClickForcesSelection: !1, minimumContrastRatio: 1, disableStdin: !1, allowProposedApi: !1, allowTransparency: !1, tabStopWidth: 8, theme: {}, rightClickSelectsWord: f.isMac, windowOptions: {}, windowsMode: !1, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: !0, convertEol: !1, termName: "xterm", cancelEvents: !1, overviewRulerWidth: 0 };
        const u = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
        class g extends h.Disposable {
          constructor(v) {
            super(), this._onOptionChange = this.register(new c.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
            const d = Object.assign({}, a.DEFAULT_OPTIONS);
            for (const O in v) if (O in d) try {
              const p = v[O];
              d[O] = this._sanitizeAndValidateOption(O, p);
            } catch (p) {
              console.error(p);
            }
            this.rawOptions = d, this.options = Object.assign({}, d), this._setupOptions();
          }
          onSpecificOptionChange(v, d) {
            return this.onOptionChange((O) => {
              O === v && d(this.rawOptions[v]);
            });
          }
          onMultipleOptionChange(v, d) {
            return this.onOptionChange((O) => {
              v.indexOf(O) !== -1 && d();
            });
          }
          _setupOptions() {
            const v = (O) => {
              if (!(O in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${O}"`);
              return this.rawOptions[O];
            }, d = (O, p) => {
              if (!(O in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${O}"`);
              p = this._sanitizeAndValidateOption(O, p), this.rawOptions[O] !== p && (this.rawOptions[O] = p, this._onOptionChange.fire(O));
            };
            for (const O in this.rawOptions) {
              const p = { get: v.bind(this, O), set: d.bind(this, O) };
              Object.defineProperty(this.options, O, p);
            }
          }
          _sanitizeAndValidateOption(v, d) {
            switch (v) {
              case "cursorStyle":
                if (d || (d = a.DEFAULT_OPTIONS[v]), !/* @__PURE__ */ function(O) {
                  return O === "block" || O === "underline" || O === "bar";
                }(d)) throw new Error(`"${d}" is not a valid value for ${v}`);
                break;
              case "wordSeparator":
                d || (d = a.DEFAULT_OPTIONS[v]);
                break;
              case "fontWeight":
              case "fontWeightBold":
                if (typeof d == "number" && 1 <= d && d <= 1e3) break;
                d = u.includes(d) ? d : a.DEFAULT_OPTIONS[v];
                break;
              case "cursorWidth":
                d = Math.floor(d);
              case "lineHeight":
              case "tabStopWidth":
                if (d < 1) throw new Error(`${v} cannot be less than 1, value: ${d}`);
                break;
              case "minimumContrastRatio":
                d = Math.max(1, Math.min(21, Math.round(10 * d) / 10));
                break;
              case "scrollback":
                if ((d = Math.min(d, 4294967295)) < 0) throw new Error(`${v} cannot be less than 0, value: ${d}`);
                break;
              case "fastScrollSensitivity":
              case "scrollSensitivity":
                if (d <= 0) throw new Error(`${v} cannot be less than or equal to 0, value: ${d}`);
                break;
              case "rows":
              case "cols":
                if (!d && d !== 0) throw new Error(`${v} must be numeric, value: ${d}`);
                break;
              case "windowsPty":
                d = d ?? {};
            }
            return d;
          }
        }
        a.OptionsService = g;
      }, 2660: function(o, a, l) {
        var c = this && this.__decorate || function(g, S, v, d) {
          var O, p = arguments.length, m = p < 3 ? S : d === null ? d = Object.getOwnPropertyDescriptor(S, v) : d;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") m = Reflect.decorate(g, S, v, d);
          else for (var _ = g.length - 1; _ >= 0; _--) (O = g[_]) && (m = (p < 3 ? O(m) : p > 3 ? O(S, v, m) : O(S, v)) || m);
          return p > 3 && m && Object.defineProperty(S, v, m), m;
        }, h = this && this.__param || function(g, S) {
          return function(v, d) {
            S(v, d, g);
          };
        };
        Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkService = void 0;
        const f = l(2585);
        let u = a.OscLinkService = class {
          constructor(g) {
            this._bufferService = g, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
          }
          registerLink(g) {
            const S = this._bufferService.buffer;
            if (g.id === void 0) {
              const _ = S.addMarker(S.ybase + S.y), b = { data: g, id: this._nextId++, lines: [_] };
              return _.onDispose(() => this._removeMarkerFromLink(b, _)), this._dataByLinkId.set(b.id, b), b.id;
            }
            const v = g, d = this._getEntryIdKey(v), O = this._entriesWithId.get(d);
            if (O) return this.addLineToLink(O.id, S.ybase + S.y), O.id;
            const p = S.addMarker(S.ybase + S.y), m = { id: this._nextId++, key: this._getEntryIdKey(v), data: v, lines: [p] };
            return p.onDispose(() => this._removeMarkerFromLink(m, p)), this._entriesWithId.set(m.key, m), this._dataByLinkId.set(m.id, m), m.id;
          }
          addLineToLink(g, S) {
            const v = this._dataByLinkId.get(g);
            if (v && v.lines.every((d) => d.line !== S)) {
              const d = this._bufferService.buffer.addMarker(S);
              v.lines.push(d), d.onDispose(() => this._removeMarkerFromLink(v, d));
            }
          }
          getLinkData(g) {
            var S;
            return (S = this._dataByLinkId.get(g)) === null || S === void 0 ? void 0 : S.data;
          }
          _getEntryIdKey(g) {
            return `${g.id};;${g.uri}`;
          }
          _removeMarkerFromLink(g, S) {
            const v = g.lines.indexOf(S);
            v !== -1 && (g.lines.splice(v, 1), g.lines.length === 0 && (g.data.id !== void 0 && this._entriesWithId.delete(g.key), this._dataByLinkId.delete(g.id)));
          }
        };
        a.OscLinkService = u = c([h(0, f.IBufferService)], u);
      }, 8343: (o, a) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.createDecorator = a.getServiceDependencies = a.serviceRegistry = void 0;
        const l = "di$target", c = "di$dependencies";
        a.serviceRegistry = /* @__PURE__ */ new Map(), a.getServiceDependencies = function(h) {
          return h[c] || [];
        }, a.createDecorator = function(h) {
          if (a.serviceRegistry.has(h)) return a.serviceRegistry.get(h);
          const f = function(u, g, S) {
            if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            (function(v, d, O) {
              d[l] === d ? d[c].push({ id: v, index: O }) : (d[c] = [{ id: v, index: O }], d[l] = d);
            })(f, u, S);
          };
          return f.toString = () => h, a.serviceRegistry.set(h, f), f;
        };
      }, 2585: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.IDecorationService = a.IUnicodeService = a.IOscLinkService = a.IOptionsService = a.ILogService = a.LogLevelEnum = a.IInstantiationService = a.ICharsetService = a.ICoreService = a.ICoreMouseService = a.IBufferService = void 0;
        const c = l(8343);
        var h;
        a.IBufferService = (0, c.createDecorator)("BufferService"), a.ICoreMouseService = (0, c.createDecorator)("CoreMouseService"), a.ICoreService = (0, c.createDecorator)("CoreService"), a.ICharsetService = (0, c.createDecorator)("CharsetService"), a.IInstantiationService = (0, c.createDecorator)("InstantiationService"), function(f) {
          f[f.TRACE = 0] = "TRACE", f[f.DEBUG = 1] = "DEBUG", f[f.INFO = 2] = "INFO", f[f.WARN = 3] = "WARN", f[f.ERROR = 4] = "ERROR", f[f.OFF = 5] = "OFF";
        }(h || (a.LogLevelEnum = h = {})), a.ILogService = (0, c.createDecorator)("LogService"), a.IOptionsService = (0, c.createDecorator)("OptionsService"), a.IOscLinkService = (0, c.createDecorator)("OscLinkService"), a.IUnicodeService = (0, c.createDecorator)("UnicodeService"), a.IDecorationService = (0, c.createDecorator)("DecorationService");
      }, 1480: (o, a, l) => {
        Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeService = void 0;
        const c = l(8460), h = l(225);
        a.UnicodeService = class {
          constructor() {
            this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new c.EventEmitter(), this.onChange = this._onChange.event;
            const f = new h.UnicodeV6();
            this.register(f), this._active = f.version, this._activeProvider = f;
          }
          dispose() {
            this._onChange.dispose();
          }
          get versions() {
            return Object.keys(this._providers);
          }
          get activeVersion() {
            return this._active;
          }
          set activeVersion(f) {
            if (!this._providers[f]) throw new Error(`unknown Unicode version "${f}"`);
            this._active = f, this._activeProvider = this._providers[f], this._onChange.fire(f);
          }
          register(f) {
            this._providers[f.version] = f;
          }
          wcwidth(f) {
            return this._activeProvider.wcwidth(f);
          }
          getStringCellWidth(f) {
            let u = 0;
            const g = f.length;
            for (let S = 0; S < g; ++S) {
              let v = f.charCodeAt(S);
              if (55296 <= v && v <= 56319) {
                if (++S >= g) return u + this.wcwidth(v);
                const d = f.charCodeAt(S);
                56320 <= d && d <= 57343 ? v = 1024 * (v - 55296) + d - 56320 + 65536 : u += this.wcwidth(d);
              }
              u += this.wcwidth(v);
            }
            return u;
          }
        };
      } }, r = {};
      function s(o) {
        var a = r[o];
        if (a !== void 0) return a.exports;
        var l = r[o] = { exports: {} };
        return t[o].call(l.exports, l, l.exports, s), l.exports;
      }
      var n = {};
      return (() => {
        var o = n;
        Object.defineProperty(o, "__esModule", { value: !0 }), o.Terminal = void 0;
        const a = s(9042), l = s(3236), c = s(844), h = s(5741), f = s(8285), u = s(7975), g = s(7090), S = ["cols", "rows"];
        class v extends c.Disposable {
          constructor(O) {
            super(), this._core = this.register(new l.Terminal(O)), this._addonManager = this.register(new h.AddonManager()), this._publicOptions = Object.assign({}, this._core.options);
            const p = (_) => this._core.options[_], m = (_, b) => {
              this._checkReadonlyOptions(_), this._core.options[_] = b;
            };
            for (const _ in this._core.options) {
              const b = { get: p.bind(this, _), set: m.bind(this, _) };
              Object.defineProperty(this._publicOptions, _, b);
            }
          }
          _checkReadonlyOptions(O) {
            if (S.includes(O)) throw new Error(`Option "${O}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onKey() {
            return this._core.onKey;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onRender() {
            return this._core.onRender;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onSelectionChange() {
            return this._core.onSelectionChange;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get onWriteParsed() {
            return this._core.onWriteParsed;
          }
          get element() {
            return this._core.element;
          }
          get parser() {
            return this._parser || (this._parser = new u.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new g.UnicodeApi(this._core);
          }
          get textarea() {
            return this._core.textarea;
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._buffer || (this._buffer = this.register(new f.BufferNamespaceApi(this._core))), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const O = this._core.coreService.decPrivateModes;
            let p = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                p = "x10";
                break;
              case "VT200":
                p = "vt200";
                break;
              case "DRAG":
                p = "drag";
                break;
              case "ANY":
                p = "any";
            }
            return { applicationCursorKeysMode: O.applicationCursorKeys, applicationKeypadMode: O.applicationKeypad, bracketedPasteMode: O.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: p, originMode: O.origin, reverseWraparoundMode: O.reverseWraparound, sendFocusMode: O.sendFocus, wraparoundMode: O.wraparound };
          }
          get options() {
            return this._publicOptions;
          }
          set options(O) {
            for (const p in O) this._publicOptions[p] = O[p];
          }
          blur() {
            this._core.blur();
          }
          focus() {
            this._core.focus();
          }
          resize(O, p) {
            this._verifyIntegers(O, p), this._core.resize(O, p);
          }
          open(O) {
            this._core.open(O);
          }
          attachCustomKeyEventHandler(O) {
            this._core.attachCustomKeyEventHandler(O);
          }
          registerLinkProvider(O) {
            return this._core.registerLinkProvider(O);
          }
          registerCharacterJoiner(O) {
            return this._checkProposedApi(), this._core.registerCharacterJoiner(O);
          }
          deregisterCharacterJoiner(O) {
            this._checkProposedApi(), this._core.deregisterCharacterJoiner(O);
          }
          registerMarker(O = 0) {
            return this._verifyIntegers(O), this._core.registerMarker(O);
          }
          registerDecoration(O) {
            var p, m, _;
            return this._checkProposedApi(), this._verifyPositiveIntegers((p = O.x) !== null && p !== void 0 ? p : 0, (m = O.width) !== null && m !== void 0 ? m : 0, (_ = O.height) !== null && _ !== void 0 ? _ : 0), this._core.registerDecoration(O);
          }
          hasSelection() {
            return this._core.hasSelection();
          }
          select(O, p, m) {
            this._verifyIntegers(O, p, m), this._core.select(O, p, m);
          }
          getSelection() {
            return this._core.getSelection();
          }
          getSelectionPosition() {
            return this._core.getSelectionPosition();
          }
          clearSelection() {
            this._core.clearSelection();
          }
          selectAll() {
            this._core.selectAll();
          }
          selectLines(O, p) {
            this._verifyIntegers(O, p), this._core.selectLines(O, p);
          }
          dispose() {
            super.dispose();
          }
          scrollLines(O) {
            this._verifyIntegers(O), this._core.scrollLines(O);
          }
          scrollPages(O) {
            this._verifyIntegers(O), this._core.scrollPages(O);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(O) {
            this._verifyIntegers(O), this._core.scrollToLine(O);
          }
          clear() {
            this._core.clear();
          }
          write(O, p) {
            this._core.write(O, p);
          }
          writeln(O, p) {
            this._core.write(O), this._core.write(`\r
`, p);
          }
          paste(O) {
            this._core.paste(O);
          }
          refresh(O, p) {
            this._verifyIntegers(O, p), this._core.refresh(O, p);
          }
          reset() {
            this._core.reset();
          }
          clearTextureAtlas() {
            this._core.clearTextureAtlas();
          }
          loadAddon(O) {
            this._addonManager.loadAddon(this, O);
          }
          static get strings() {
            return a;
          }
          _verifyIntegers(...O) {
            for (const p of O) if (p === 1 / 0 || isNaN(p) || p % 1 != 0) throw new Error("This API only accepts integers");
          }
          _verifyPositiveIntegers(...O) {
            for (const p of O) if (p && (p === 1 / 0 || isNaN(p) || p % 1 != 0 || p < 0)) throw new Error("This API only accepts positive integers");
          }
        }
        o.Terminal = v;
      })(), n;
    })());
  }(lh)), lh.exports;
}
var jq = Uq(), ch = { exports: {} }, km;
function Nq() {
  return km || (km = 1, function(i, e) {
    (function(t, r) {
      i.exports = r();
    })(self, () => (() => {
      var t = {};
      return (() => {
        var r = t;
        Object.defineProperty(r, "__esModule", { value: !0 }), r.FitAddon = void 0, r.FitAddon = class {
          activate(s) {
            this._terminal = s;
          }
          dispose() {
          }
          fit() {
            const s = this.proposeDimensions();
            if (!s || !this._terminal || isNaN(s.cols) || isNaN(s.rows)) return;
            const n = this._terminal._core;
            this._terminal.rows === s.rows && this._terminal.cols === s.cols || (n._renderService.clear(), this._terminal.resize(s.cols, s.rows));
          }
          proposeDimensions() {
            if (!this._terminal || !this._terminal.element || !this._terminal.element.parentElement) return;
            const s = this._terminal._core, n = s._renderService.dimensions;
            if (n.css.cell.width === 0 || n.css.cell.height === 0) return;
            const o = this._terminal.options.scrollback === 0 ? 0 : s.viewport.scrollBarWidth, a = window.getComputedStyle(this._terminal.element.parentElement), l = parseInt(a.getPropertyValue("height")), c = Math.max(0, parseInt(a.getPropertyValue("width"))), h = window.getComputedStyle(this._terminal.element), f = l - (parseInt(h.getPropertyValue("padding-top")) + parseInt(h.getPropertyValue("padding-bottom"))), u = c - (parseInt(h.getPropertyValue("padding-right")) + parseInt(h.getPropertyValue("padding-left"))) - o;
            return { cols: Math.max(2, Math.floor(u / n.css.cell.width)), rows: Math.max(1, Math.floor(f / n.css.cell.height)) };
          }
        };
      })(), t;
    })());
  }(ch)), ch.exports;
}
var Yq = Nq();
const yi = /* @__PURE__ */ Object.create(null);
yi.open = "0";
yi.close = "1";
yi.ping = "2";
yi.pong = "3";
yi.message = "4";
yi.upgrade = "5";
yi.noop = "6";
const ka = /* @__PURE__ */ Object.create(null);
Object.keys(yi).forEach((i) => {
  ka[yi[i]] = i;
});
const Kf = { type: "error", data: "parser error" }, $y = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Ty = typeof ArrayBuffer == "function", Ry = (i) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i && i.buffer instanceof ArrayBuffer, xd = ({ type: i, data: e }, t, r) => $y && e instanceof Blob ? t ? r(e) : Cm(e, r) : Ty && (e instanceof ArrayBuffer || Ry(e)) ? t ? r(e) : Cm(new Blob([e]), r) : r(yi[i] + (e || "")), Cm = (i, e) => {
  const t = new FileReader();
  return t.onload = function() {
    const r = t.result.split(",")[1];
    e("b" + (r || ""));
  }, t.readAsDataURL(i);
};
function Qm(i) {
  return i instanceof Uint8Array ? i : i instanceof ArrayBuffer ? new Uint8Array(i) : new Uint8Array(i.buffer, i.byteOffset, i.byteLength);
}
let hh;
function Fq(i, e) {
  if ($y && i.data instanceof Blob)
    return i.data.arrayBuffer().then(Qm).then(e);
  if (Ty && (i.data instanceof ArrayBuffer || Ry(i.data)))
    return e(Qm(i.data));
  xd(i, !1, (t) => {
    hh || (hh = new TextEncoder()), e(hh.encode(t));
  });
}
const Pm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", rn = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let i = 0; i < Pm.length; i++)
  rn[Pm.charCodeAt(i)] = i;
const Hq = (i) => {
  let e = i.length * 0.75, t = i.length, r, s = 0, n, o, a, l;
  i[i.length - 1] === "=" && (e--, i[i.length - 2] === "=" && e--);
  const c = new ArrayBuffer(e), h = new Uint8Array(c);
  for (r = 0; r < t; r += 4)
    n = rn[i.charCodeAt(r)], o = rn[i.charCodeAt(r + 1)], a = rn[i.charCodeAt(r + 2)], l = rn[i.charCodeAt(r + 3)], h[s++] = n << 2 | o >> 4, h[s++] = (o & 15) << 4 | a >> 2, h[s++] = (a & 3) << 6 | l & 63;
  return c;
}, Gq = typeof ArrayBuffer == "function", kd = (i, e) => {
  if (typeof i != "string")
    return {
      type: "message",
      data: Ey(i, e)
    };
  const t = i.charAt(0);
  return t === "b" ? {
    type: "message",
    data: Kq(i.substring(1), e)
  } : ka[t] ? i.length > 1 ? {
    type: ka[t],
    data: i.substring(1)
  } : {
    type: ka[t]
  } : Kf;
}, Kq = (i, e) => {
  if (Gq) {
    const t = Hq(i);
    return Ey(t, e);
  } else
    return { base64: !0, data: i };
}, Ey = (i, e) => {
  switch (e) {
    case "blob":
      return i instanceof Blob ? i : new Blob([i]);
    case "arraybuffer":
    default:
      return i instanceof ArrayBuffer ? i : i.buffer;
  }
}, Ay = "", Jq = (i, e) => {
  const t = i.length, r = new Array(t);
  let s = 0;
  i.forEach((n, o) => {
    xd(n, !1, (a) => {
      r[o] = a, ++s === t && e(r.join(Ay));
    });
  });
}, eB = (i, e) => {
  const t = i.split(Ay), r = [];
  for (let s = 0; s < t.length; s++) {
    const n = kd(t[s], e);
    if (r.push(n), n.type === "error")
      break;
  }
  return r;
};
function tB() {
  return new TransformStream({
    transform(i, e) {
      Fq(i, (t) => {
        const r = t.length;
        let s;
        if (r < 126)
          s = new Uint8Array(1), new DataView(s.buffer).setUint8(0, r);
        else if (r < 65536) {
          s = new Uint8Array(3);
          const n = new DataView(s.buffer);
          n.setUint8(0, 126), n.setUint16(1, r);
        } else {
          s = new Uint8Array(9);
          const n = new DataView(s.buffer);
          n.setUint8(0, 127), n.setBigUint64(1, BigInt(r));
        }
        i.data && typeof i.data != "string" && (s[0] |= 128), e.enqueue(s), e.enqueue(t);
      });
    }
  });
}
let fh;
function Jo(i) {
  return i.reduce((e, t) => e + t.length, 0);
}
function ea(i, e) {
  if (i[0].length === e)
    return i.shift();
  const t = new Uint8Array(e);
  let r = 0;
  for (let s = 0; s < e; s++)
    t[s] = i[0][r++], r === i[0].length && (i.shift(), r = 0);
  return i.length && r < i[0].length && (i[0] = i[0].slice(r)), t;
}
function iB(i, e) {
  fh || (fh = new TextDecoder());
  const t = [];
  let r = 0, s = -1, n = !1;
  return new TransformStream({
    transform(o, a) {
      for (t.push(o); ; ) {
        if (r === 0) {
          if (Jo(t) < 1)
            break;
          const l = ea(t, 1);
          n = (l[0] & 128) === 128, s = l[0] & 127, s < 126 ? r = 3 : s === 126 ? r = 1 : r = 2;
        } else if (r === 1) {
          if (Jo(t) < 2)
            break;
          const l = ea(t, 2);
          s = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), r = 3;
        } else if (r === 2) {
          if (Jo(t) < 8)
            break;
          const l = ea(t, 8), c = new DataView(l.buffer, l.byteOffset, l.length), h = c.getUint32(0);
          if (h > Math.pow(2, 21) - 1) {
            a.enqueue(Kf);
            break;
          }
          s = h * Math.pow(2, 32) + c.getUint32(4), r = 3;
        } else {
          if (Jo(t) < s)
            break;
          const l = ea(t, s);
          a.enqueue(kd(n ? l : fh.decode(l), e)), r = 0;
        }
        if (s === 0 || s > i) {
          a.enqueue(Kf);
          break;
        }
      }
    }
  });
}
const Ly = 4;
function Ve(i) {
  if (i) return rB(i);
}
function rB(i) {
  for (var e in Ve.prototype)
    i[e] = Ve.prototype[e];
  return i;
}
Ve.prototype.on = Ve.prototype.addEventListener = function(i, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + i] = this._callbacks["$" + i] || []).push(e), this;
};
Ve.prototype.once = function(i, e) {
  function t() {
    this.off(i, t), e.apply(this, arguments);
  }
  return t.fn = e, this.on(i, t), this;
};
Ve.prototype.off = Ve.prototype.removeListener = Ve.prototype.removeAllListeners = Ve.prototype.removeEventListener = function(i, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var t = this._callbacks["$" + i];
  if (!t) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + i], this;
  for (var r, s = 0; s < t.length; s++)
    if (r = t[s], r === e || r.fn === e) {
      t.splice(s, 1);
      break;
    }
  return t.length === 0 && delete this._callbacks["$" + i], this;
};
Ve.prototype.emit = function(i) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + i], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  if (t) {
    t = t.slice(0);
    for (var r = 0, s = t.length; r < s; ++r)
      t[r].apply(this, e);
  }
  return this;
};
Ve.prototype.emitReserved = Ve.prototype.emit;
Ve.prototype.listeners = function(i) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + i] || [];
};
Ve.prototype.hasListeners = function(i) {
  return !!this.listeners(i).length;
};
const jl = typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0), Lt = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), sB = "arraybuffer";
function My(i, ...e) {
  return e.reduce((t, r) => (i.hasOwnProperty(r) && (t[r] = i[r]), t), {});
}
const nB = Lt.setTimeout, oB = Lt.clearTimeout;
function Nl(i, e) {
  e.useNativeTimers ? (i.setTimeoutFn = nB.bind(Lt), i.clearTimeoutFn = oB.bind(Lt)) : (i.setTimeoutFn = Lt.setTimeout.bind(Lt), i.clearTimeoutFn = Lt.clearTimeout.bind(Lt));
}
const aB = 1.33;
function lB(i) {
  return typeof i == "string" ? cB(i) : Math.ceil((i.byteLength || i.size) * aB);
}
function cB(i) {
  let e = 0, t = 0;
  for (let r = 0, s = i.length; r < s; r++)
    e = i.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4);
  return t;
}
function Dy() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function hB(i) {
  let e = "";
  for (let t in i)
    i.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(i[t]));
  return e;
}
function fB(i) {
  let e = {}, t = i.split("&");
  for (let r = 0, s = t.length; r < s; r++) {
    let n = t[r].split("=");
    e[decodeURIComponent(n[0])] = decodeURIComponent(n[1]);
  }
  return e;
}
class uB extends Error {
  constructor(e, t, r) {
    super(e), this.description = t, this.context = r, this.type = "TransportError";
  }
}
class Cd extends Ve {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(e) {
    super(), this.writable = !1, Nl(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(e, t, r) {
    return super.emitReserved("error", new uB(e, t, r)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(e) {
    const t = kd(e, this.socket.binaryType);
    this.onPacket(t);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(e) {
  }
  createUri(e, t = {}) {
    return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t);
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e) {
    const t = hB(e);
    return t.length ? "?" + t : "";
  }
}
class dB extends Cd {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(e) {
    this.readyState = "pausing";
    const t = () => {
      this.readyState = "paused", e();
    };
    if (this._polling || !this.writable) {
      let r = 0;
      this._polling && (r++, this.once("pollComplete", function() {
        --r || t();
      })), this.writable || (r++, this.once("drain", function() {
        --r || t();
      }));
    } else
      t();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(e) {
    const t = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    eB(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(e) {
    this.writable = !1, Jq(e, (t) => {
      this.doWrite(t, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "https" : "http", t = this.query || {};
    return this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = Dy()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.createUri(e, t);
  }
}
let qy = !1;
try {
  qy = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const OB = qy;
function pB() {
}
class gB extends dB {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(e) {
    if (super(e), typeof location < "u") {
      const t = location.protocol === "https:";
      let r = location.port;
      r || (r = t ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || r !== e.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(e, t) {
    const r = this.request({
      method: "POST",
      data: e
    });
    r.on("success", t), r.on("error", (s, n) => {
      this.onError("xhr post error", s, n);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (t, r) => {
      this.onError("xhr poll error", t, r);
    }), this.pollXhr = e;
  }
}
let hs = class Ca extends Ve {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(e, t, r) {
    super(), this.createRequest = e, Nl(this, r), this._opts = r, this._method = r.method || "GET", this._uri = t, this._data = r.data !== void 0 ? r.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var e;
    const t = My(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this._opts.xd;
    const r = this._xhr = this.createRequest(t);
    try {
      r.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
          for (let s in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(s) && r.setRequestHeader(s, this._opts.extraHeaders[s]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(r), "withCredentials" in r && (r.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (r.timeout = this._opts.requestTimeout), r.onreadystatechange = () => {
        var s;
        r.readyState === 3 && ((s = this._opts.cookieJar) === null || s === void 0 || s.parseCookies(
          // @ts-ignore
          r.getResponseHeader("set-cookie")
        )), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof r.status == "number" ? r.status : 0);
        }, 0));
      }, r.send(this._data);
    } catch (s) {
      this.setTimeoutFn(() => {
        this._onError(s);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = Ca.requestsCount++, Ca.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(e) {
    this.emitReserved("error", e, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(e) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = pB, e)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Ca.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const e = this._xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
hs.requestsCount = 0;
hs.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", $m);
  else if (typeof addEventListener == "function") {
    const i = "onpagehide" in Lt ? "pagehide" : "unload";
    addEventListener(i, $m, !1);
  }
}
function $m() {
  for (let i in hs.requests)
    hs.requests.hasOwnProperty(i) && hs.requests[i].abort();
}
const mB = function() {
  const i = By({
    xdomain: !1
  });
  return i && i.responseType !== null;
}();
class vB extends gB {
  constructor(e) {
    super(e);
    const t = e && e.forceBase64;
    this.supportsBinary = mB && !t;
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd }, this.opts), new hs(By, this.uri(), e);
  }
}
function By(i) {
  const e = i.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || OB))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new Lt[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const Xy = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class SB extends Cd {
  get name() {
    return "websocket";
  }
  doOpen() {
    const e = this.uri(), t = this.opts.protocols, r = Xy ? {} : My(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(e, t, r);
    } catch (s) {
      return this.emitReserved("error", s);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      xd(r, this.supportsBinary, (n) => {
        try {
          this.doWrite(r, n);
        } catch {
        }
        s && jl(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "wss" : "ws", t = this.query || {};
    return this.opts.timestampRequests && (t[this.opts.timestampParam] = Dy()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t);
  }
}
const uh = Lt.WebSocket || Lt.MozWebSocket;
class _B extends SB {
  createSocket(e, t, r) {
    return Xy ? new uh(e, t, r) : t ? new uh(e, t) : new uh(e);
  }
  doWrite(e, t) {
    this.ws.send(t);
  }
}
class bB extends Cd {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (e) {
      return this.emitReserved("error", e);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((e) => {
      this.onError("webtransport error", e);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((e) => {
        const t = iB(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = e.readable.pipeThrough(t).getReader(), s = tB();
        s.readable.pipeTo(e.writable), this._writer = s.writable.getWriter();
        const n = () => {
          r.read().then(({ done: a, value: l }) => {
            a || (this.onPacket(l), n());
          }).catch((a) => {
          });
        };
        n();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      this._writer.write(r).then(() => {
        s && jl(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this._transport) === null || e === void 0 || e.close();
  }
}
const yB = {
  websocket: _B,
  webtransport: bB,
  polling: vB
}, wB = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, xB = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function Jf(i) {
  if (i.length > 8e3)
    throw "URI too long";
  const e = i, t = i.indexOf("["), r = i.indexOf("]");
  t != -1 && r != -1 && (i = i.substring(0, t) + i.substring(t, r).replace(/:/g, ";") + i.substring(r, i.length));
  let s = wB.exec(i || ""), n = {}, o = 14;
  for (; o--; )
    n[xB[o]] = s[o] || "";
  return t != -1 && r != -1 && (n.source = e, n.host = n.host.substring(1, n.host.length - 1).replace(/;/g, ":"), n.authority = n.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), n.ipv6uri = !0), n.pathNames = kB(n, n.path), n.queryKey = CB(n, n.query), n;
}
function kB(i, e) {
  const t = /\/{2,9}/g, r = e.replace(t, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function CB(i, e) {
  const t = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, n) {
    s && (t[s] = n);
  }), t;
}
const eu = typeof addEventListener == "function" && typeof removeEventListener == "function", Qa = [];
eu && addEventListener("offline", () => {
  Qa.forEach((i) => i());
}, !1);
class rr extends Ve {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(e, t) {
    if (super(), this.binaryType = sB, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && typeof e == "object" && (t = e, e = null), e) {
      const r = Jf(e);
      t.hostname = r.host, t.secure = r.protocol === "https" || r.protocol === "wss", t.port = r.port, r.query && (t.query = r.query);
    } else t.host && (t.hostname = Jf(t.host).host);
    Nl(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, t.transports.forEach((r) => {
      const s = r.prototype.name;
      this.transports.push(s), this._transportsByName[s] = r;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = fB(this.opts.query)), eu && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, Qa.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    t.EIO = Ly, t.transport = e, this.id && (t.sid = this.id);
    const r = Object.assign({}, this.opts, {
      query: t,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[e]);
    return new this._transportsByName[e](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const e = this.opts.rememberUpgrade && rr.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const t = this.createTransport(e);
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (t) => this._onClose("transport close", t));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", rr.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const t = new Error("server error");
          t.code = e.data, this._onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const e = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this._getWritablePackets();
      this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let t = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const s = this.writeBuffer[r].data;
      if (s && (t += lB(s)), r > 0 && t > this._maxPayload)
        return this.writeBuffer.slice(0, r);
      t += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const e = Date.now() > this._pingTimeoutTime;
    return e && (this._pingTimeoutTime = 0, jl(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), e;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(e, t, r) {
    return this._sendPacket("message", e, t, r), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(e, t, r) {
    return this._sendPacket("message", e, t, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(e, t, r, s) {
    if (typeof t == "function" && (s = t, t = void 0), typeof r == "function" && (s = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const n = {
      type: e,
      data: t,
      options: r
    };
    this.emitReserved("packetCreate", n), this.writeBuffer.push(n), s && this.once("flush", s), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const e = () => {
      this._onClose("forced close"), this.transport.close();
    }, t = () => {
      this.off("upgrade", t), this.off("upgradeError", t), e();
    }, r = () => {
      this.once("upgrade", t), this.once("upgradeError", t);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : e();
    }) : this.upgrading ? r() : e()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(e) {
    if (rr.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", e), this._onClose("transport error", e);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(e, t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), eu && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const r = Qa.indexOf(this._offlineEventListener);
        r !== -1 && Qa.splice(r, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
rr.protocol = Ly;
class QB extends rr {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let e = 0; e < this._upgrades.length; e++)
        this._probe(this._upgrades[e]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(e) {
    let t = this.createTransport(e), r = !1;
    rr.priorWebsocketSuccess = !1;
    const s = () => {
      r || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", (f) => {
        if (!r)
          if (f.type === "pong" && f.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", t), !t)
              return;
            rr.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (h(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush());
            });
          } else {
            const u = new Error("probe error");
            u.transport = t.name, this.emitReserved("upgradeError", u);
          }
      }));
    };
    function n() {
      r || (r = !0, h(), t.close(), t = null);
    }
    const o = (f) => {
      const u = new Error("probe error: " + f);
      u.transport = t.name, n(), this.emitReserved("upgradeError", u);
    };
    function a() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function c(f) {
      t && f.name !== t.name && n();
    }
    const h = () => {
      t.removeListener("open", s), t.removeListener("error", o), t.removeListener("close", a), this.off("close", l), this.off("upgrading", c);
    };
    t.once("open", s), t.once("error", o), t.once("close", a), this.once("close", l), this.once("upgrading", c), this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
      r || t.open();
    }, 200) : t.open();
  }
  onHandshake(e) {
    this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(e) {
    const t = [];
    for (let r = 0; r < e.length; r++)
      ~this.transports.indexOf(e[r]) && t.push(e[r]);
    return t;
  }
}
let PB = class extends QB {
  constructor(e, t = {}) {
    const r = typeof e == "object" ? e : t;
    (!r.transports || r.transports && typeof r.transports[0] == "string") && (r.transports = (r.transports || ["polling", "websocket", "webtransport"]).map((s) => yB[s]).filter((s) => !!s)), super(e, r);
  }
};
function $B(i, e = "", t) {
  let r = i;
  t = t || typeof location < "u" && location, i == null && (i = t.protocol + "//" + t.host), typeof i == "string" && (i.charAt(0) === "/" && (i.charAt(1) === "/" ? i = t.protocol + i : i = t.host + i), /^(https?|wss?):\/\//.test(i) || (typeof t < "u" ? i = t.protocol + "//" + i : i = "https://" + i), r = Jf(i)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const n = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + n + ":" + r.port + e, r.href = r.protocol + "://" + n + (t && t.port === r.port ? "" : ":" + r.port), r;
}
const TB = typeof ArrayBuffer == "function", RB = (i) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i.buffer instanceof ArrayBuffer, Iy = Object.prototype.toString, EB = typeof Blob == "function" || typeof Blob < "u" && Iy.call(Blob) === "[object BlobConstructor]", AB = typeof File == "function" || typeof File < "u" && Iy.call(File) === "[object FileConstructor]";
function Qd(i) {
  return TB && (i instanceof ArrayBuffer || RB(i)) || EB && i instanceof Blob || AB && i instanceof File;
}
function Pa(i, e) {
  if (!i || typeof i != "object")
    return !1;
  if (Array.isArray(i)) {
    for (let t = 0, r = i.length; t < r; t++)
      if (Pa(i[t]))
        return !0;
    return !1;
  }
  if (Qd(i))
    return !0;
  if (i.toJSON && typeof i.toJSON == "function" && arguments.length === 1)
    return Pa(i.toJSON(), !0);
  for (const t in i)
    if (Object.prototype.hasOwnProperty.call(i, t) && Pa(i[t]))
      return !0;
  return !1;
}
function LB(i) {
  const e = [], t = i.data, r = i;
  return r.data = tu(t, e), r.attachments = e.length, { packet: r, buffers: e };
}
function tu(i, e) {
  if (!i)
    return i;
  if (Qd(i)) {
    const t = { _placeholder: !0, num: e.length };
    return e.push(i), t;
  } else if (Array.isArray(i)) {
    const t = new Array(i.length);
    for (let r = 0; r < i.length; r++)
      t[r] = tu(i[r], e);
    return t;
  } else if (typeof i == "object" && !(i instanceof Date)) {
    const t = {};
    for (const r in i)
      Object.prototype.hasOwnProperty.call(i, r) && (t[r] = tu(i[r], e));
    return t;
  }
  return i;
}
function MB(i, e) {
  return i.data = iu(i.data, e), delete i.attachments, i;
}
function iu(i, e) {
  if (!i)
    return i;
  if (i && i._placeholder === !0) {
    if (typeof i.num == "number" && i.num >= 0 && i.num < e.length)
      return e[i.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(i))
    for (let t = 0; t < i.length; t++)
      i[t] = iu(i[t], e);
  else if (typeof i == "object")
    for (const t in i)
      Object.prototype.hasOwnProperty.call(i, t) && (i[t] = iu(i[t], e));
  return i;
}
const DB = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], qB = 5;
var ve;
(function(i) {
  i[i.CONNECT = 0] = "CONNECT", i[i.DISCONNECT = 1] = "DISCONNECT", i[i.EVENT = 2] = "EVENT", i[i.ACK = 3] = "ACK", i[i.CONNECT_ERROR = 4] = "CONNECT_ERROR", i[i.BINARY_EVENT = 5] = "BINARY_EVENT", i[i.BINARY_ACK = 6] = "BINARY_ACK";
})(ve || (ve = {}));
class BB {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(e) {
    this.replacer = e;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(e) {
    return (e.type === ve.EVENT || e.type === ve.ACK) && Pa(e) ? this.encodeAsBinary({
      type: e.type === ve.EVENT ? ve.BINARY_EVENT : ve.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(e) {
    let t = "" + e.type;
    return (e.type === ve.BINARY_EVENT || e.type === ve.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(e) {
    const t = LB(e), r = this.encodeAsString(t.packet), s = t.buffers;
    return s.unshift(r), s;
  }
}
function Tm(i) {
  return Object.prototype.toString.call(i) === "[object Object]";
}
class Pd extends Ve {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(e) {
    super(), this.reviver = e;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(e) {
    let t;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      t = this.decodeString(e);
      const r = t.type === ve.BINARY_EVENT;
      r || t.type === ve.BINARY_ACK ? (t.type = r ? ve.EVENT : ve.ACK, this.reconstructor = new XB(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t);
    } else if (Qd(e) || e.base64)
      if (this.reconstructor)
        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(e) {
    let t = 0;
    const r = {
      type: Number(e.charAt(0))
    };
    if (ve[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === ve.BINARY_EVENT || r.type === ve.BINARY_ACK) {
      const n = t + 1;
      for (; e.charAt(++t) !== "-" && t != e.length; )
        ;
      const o = e.substring(n, t);
      if (o != Number(o) || e.charAt(t) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(o);
    }
    if (e.charAt(t + 1) === "/") {
      const n = t + 1;
      for (; ++t && !(e.charAt(t) === "," || t === e.length); )
        ;
      r.nsp = e.substring(n, t);
    } else
      r.nsp = "/";
    const s = e.charAt(t + 1);
    if (s !== "" && Number(s) == s) {
      const n = t + 1;
      for (; ++t; ) {
        const o = e.charAt(t);
        if (o == null || Number(o) != o) {
          --t;
          break;
        }
        if (t === e.length)
          break;
      }
      r.id = Number(e.substring(n, t + 1));
    }
    if (e.charAt(++t)) {
      const n = this.tryParse(e.substr(t));
      if (Pd.isPayloadValid(r.type, n))
        r.data = n;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case ve.CONNECT:
        return Tm(t);
      case ve.DISCONNECT:
        return t === void 0;
      case ve.CONNECT_ERROR:
        return typeof t == "string" || Tm(t);
      case ve.EVENT:
      case ve.BINARY_EVENT:
        return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && DB.indexOf(t[0]) === -1);
      case ve.ACK:
      case ve.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class XB {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const t = MB(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const IB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: Pd,
  Encoder: BB,
  get PacketType() {
    return ve;
  },
  protocol: qB
}, Symbol.toStringTag, { value: "Module" }));
function Vt(i, e, t) {
  return i.on(e, t), function() {
    i.off(e, t);
  };
}
const ZB = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Zy extends Ve {
  /**
   * `Socket` constructor.
   */
  constructor(e, t, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      Vt(e, "open", this.onopen.bind(this)),
      Vt(e, "packet", this.onpacket.bind(this)),
      Vt(e, "error", this.onerror.bind(this)),
      Vt(e, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(e, ...t) {
    var r, s, n;
    if (ZB.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(t), this;
    const o = {
      type: ve.EVENT,
      data: t
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") {
      const h = this.ids++, f = t.pop();
      this._registerAckCallback(h, f), o.id = h;
    }
    const a = (s = (r = this.io.engine) === null || r === void 0 ? void 0 : r.transport) === null || s === void 0 ? void 0 : s.writable, l = this.connected && !(!((n = this.io.engine) === null || n === void 0) && n._hasPingExpired());
    return this.flags.volatile && !a || (l ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(e, t) {
    var r;
    const s = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (s === void 0) {
      this.acks[e] = t;
      return;
    }
    const n = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === e && this.sendBuffer.splice(a, 1);
      t.call(this, new Error("operation has timed out"));
    }, s), o = (...a) => {
      this.io.clearTimeoutFn(n), t.apply(this, a);
    };
    o.withError = !0, this.acks[e] = o;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(e, ...t) {
    return new Promise((r, s) => {
      const n = (o, a) => o ? s(o) : r(a);
      n.withError = !0, t.push(n), this.emit(e, ...t);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(e) {
    let t;
    typeof e[e.length - 1] == "function" && (t = e.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e.push((s, ...n) => r !== this._queue[0] ? void 0 : (s !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), t && t(s)) : (this._queue.shift(), t && t(null, ...n)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const t = this._queue[0];
    t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(e) {
    this.packet({
      type: ve.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(e, t) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((e) => {
      if (!this.sendBuffer.some((r) => String(r.id) === e)) {
        const r = this.acks[e];
        delete this.acks[e], r.withError && r.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case ve.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case ve.EVENT:
        case ve.BINARY_EVENT:
          this.onevent(e);
          break;
        case ve.ACK:
        case ve.BINARY_ACK:
          this.onack(e);
          break;
        case ve.DISCONNECT:
          this.ondisconnect();
          break;
        case ve.CONNECT_ERROR:
          this.destroy();
          const r = new Error(e.data.message);
          r.data = e.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const r of t)
        r.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(e) {
    const t = this;
    let r = !1;
    return function(...s) {
      r || (r = !0, t.packet({
        type: ve.ACK,
        id: e,
        data: s
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(e) {
    const t = this.acks[e.id];
    typeof t == "function" && (delete this.acks[e.id], t.withError && e.data.unshift(null), t.apply(this, e.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(e, t) {
    this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: ve.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(e) {
    return this.flags.compress = e, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const t = this._anyListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const r of t)
        r.apply(this, e.data);
    }
  }
}
function $s(i) {
  i = i || {}, this.ms = i.min || 100, this.max = i.max || 1e4, this.factor = i.factor || 2, this.jitter = i.jitter > 0 && i.jitter <= 1 ? i.jitter : 0, this.attempts = 0;
}
$s.prototype.duration = function() {
  var i = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), t = Math.floor(e * this.jitter * i);
    i = (Math.floor(e * 10) & 1) == 0 ? i - t : i + t;
  }
  return Math.min(i, this.max) | 0;
};
$s.prototype.reset = function() {
  this.attempts = 0;
};
$s.prototype.setMin = function(i) {
  this.ms = i;
};
$s.prototype.setMax = function(i) {
  this.max = i;
};
$s.prototype.setJitter = function(i) {
  this.jitter = i;
};
class ru extends Ve {
  constructor(e, t) {
    var r;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, Nl(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new $s({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
    const s = t.parser || IB;
    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new PB(this.uri, this.opts);
    const t = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const s = Vt(t, "open", function() {
      r.onopen(), e && e();
    }), n = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), e ? e(a) : this.maybeReconnectOnOpen();
    }, o = Vt(t, "error", n);
    if (this._timeout !== !1) {
      const a = this._timeout, l = this.setTimeoutFn(() => {
        s(), n(new Error("timeout")), t.close();
      }, a);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(s), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(e) {
    return this.open(e);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(
      Vt(e, "ping", this.onping.bind(this)),
      Vt(e, "data", this.ondata.bind(this)),
      Vt(e, "error", this.onerror.bind(this)),
      Vt(e, "close", this.onclose.bind(this)),
      // @ts-ignore
      Vt(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (t) {
      this.onclose("parse error", t);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(e) {
    jl(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(e) {
    this.emitReserved("error", e);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(e, t) {
    let r = this.nsps[e];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new Zy(this, e, t), this.nsps[e] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const r of t)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let r = 0; r < t.length; r++)
      this.engine.write(t[r], e.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(e, t) {
    var r;
    this.cleanup(), (r = this.engine) === null || r === void 0 || r.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const t = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((s) => {
          s ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect();
        }));
      }, t);
      this.opts.autoUnref && r.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const Ns = {};
function pn(i, e) {
  typeof i == "object" && (e = i, i = void 0), e = e || {};
  const t = $B(i, e.path || "/socket.io"), r = t.source, s = t.id, n = t.path, o = Ns[s] && n in Ns[s].nsps, a = e.forceNew || e["force new connection"] || e.multiplex === !1 || o;
  let l;
  return a ? l = new ru(r, e) : (Ns[s] || (Ns[s] = new ru(r, e)), l = Ns[s]), t.query && !e.query && (e.query = t.queryKey), l.socket(t.path, e);
}
Object.assign(pn, {
  Manager: ru,
  Socket: Zy,
  io: pn,
  connect: pn
});
var WB = /* @__PURE__ */ Y('<div class="p-2 h-full"><div class="h-full focus:outline-none"tabindex=0>');
function zB(i) {
  let e;
  const [t, r] = ie(), [s, n] = ie(), [o, a] = ie("~"), l = [];
  let c = -1, h = "";
  const f = () => {
    s()?.write(`\x1B[1;32m${o()}\x1B[0m $ `);
  }, u = (S) => {
    t()?.emit("exec", S);
  }, g = (S) => {
    const v = s();
    if (v)
      switch (S) {
        case "\r":
          v.write(`\r
`), u(h), l.push(h), c = l.length, h = "";
          break;
        case "":
          h.length > 0 && (v.write("\b \b"), h = h.slice(0, -1));
          break;
        case "\x1B[A":
          if (c > 0) {
            c--;
            const d = l[c];
            v.write("\x1B[2K\r"), f(), v.write(d), h = d;
          }
          break;
        case "\x1B[B":
          if (c < l.length - 1) {
            c++;
            const d = l[c];
            v.write("\x1B[2K\r"), f(), v.write(d), h = d;
          } else
            c = l.length, v.write("\x1B[2K\r"), f(), h = "";
          break;
        default:
          v.write(S), h += S;
      }
  };
  return kt(() => {
    const S = new jq.Terminal({
      cursorBlink: !0,
      fontFamily: "monospace",
      convertEol: !0,
      fontSize: i.fontSize ?? 12,
      theme: {
        background: "#030712"
      }
    }), v = new Yq.FitAddon();
    S.loadAddon(v), n(S), S.open(e), v.fit(), window.addEventListener("resize", () => v.fit()), S.onData(g), f(), e.focus(), e.addEventListener("paste", (p) => {
      p.preventDefault();
      const m = p.clipboardData?.getData("text");
      m && S.write(m);
    }), e.addEventListener("copy", (p) => {
      const m = S.getSelection();
      m && (p.preventDefault(), p.clipboardData?.setData("text/plain", m));
    });
    const d = localStorage.getItem("token"), O = pn("http://localhost:5000/terminal", {
      auth: {
        token: `Bearer ${d}`
      }
      //withCredentials: true,
    });
    r(O), O.on("connect", () => {
      console.log("[✔] Terminal connected");
    }), O.on("output", (p) => {
      S.writeln(p), f();
    }), O.on("prompt", ({
      cwd: p
    }) => {
      a(p);
    }), O.on("error", (p) => {
      S.writeln(`\x1B[1;31mError:\x1B[0m ${p}`), f();
    }), ft(() => {
      window.removeEventListener("resize", () => v.fit()), O.disconnect(), S.dispose();
    });
  }), (() => {
    var S = WB(), v = S.firstChild;
    return mi((d) => e = d, v), S;
  })();
}
var VB = /* @__PURE__ */ Y('<div><button aria-label="Close Drawer"class="absolute -top-8 right-2 rounded-md p-1 cursor-alias focus:ring-2 focus:ring-indigo-500 focus:outline-none dark:focus:ring-indigo-400"><svg class="h-5 w-5"viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round><path d="M6 18L18 6M6 6l12 12">'), UB = /* @__PURE__ */ Y('<button class="fixed -bottom-2 right-2 p-2 z-60 shadow-lg cursor-pointer">');
function jB(i) {
  const [e, t] = ie(!1), r = () => {
    switch (i.position) {
      case "left":
        return "left-0 top-0 bottom-0 h-full";
      case "right":
        return "right-0 top-0 bottom-0 h-full";
      case "bottom":
      default:
        return "bottom-0 left-0 right-0 w-full";
    }
  }, s = () => {
    switch (i.position) {
      case "left":
      case "right":
        return `width: ${i.size ?? "400px"};`;
      case "bottom":
      default:
        return `height: ${i.size ?? "300px"};`;
    }
  }, n = () => {
    switch (i.position) {
      case "left":
        return "transition-transform duration-300 transform translate-x-0";
      case "right":
        return "transition-transform duration-300 transform translate-x-0";
      case "bottom":
      default:
        return "transition-transform duration-300 transform translate-y-0";
    }
  };
  return [B(pe, {
    get when() {
      return e();
    },
    get children() {
      var o = VB(), a = o.firstChild;
      return a.$$click = () => t(!1), X(o, B(zB, {
        get fontSize() {
          return i.fontSize;
        }
      }), null), ce((l) => {
        var c = `fixed bottom-4 z-50 dark:bg-gray-950 shadow-lg mb-4 border-t border-gray-800/50 pt-4 ${r()} ${n()}`, h = `${s()}; font-size: ${i.fontSize ?? "14px"};`;
        return c !== l.e && Fe(o, l.e = c), l.t = Sn(o, h, l.t), l;
      }, {
        e: void 0,
        t: void 0
      }), o;
    }
  }), (() => {
    var o = UB();
    return o.$$click = () => t(!e()), X(o, B(Ae, {
      icon: "mdi:code-greater-than-or-equal",
      width: "1.4em",
      height: "1.4em"
    })), o;
  })()];
}
He(["click"]);
var NB = /* @__PURE__ */ Y('<div class="flex items-center border-b border-gray-900/50"><button class="px-2 hover:bg-gray-700 disabled:opacity-50"aria-label="Scroll Left"></button><div class="flex overflow-x-auto scrollbar-hide flex-1"></div><button class="px-2 hover:bg-gray-700 disabled:opacity-50"aria-label="Scroll Right">'), YB = /* @__PURE__ */ Y('<div><span class="truncate max-w-[150px]">');
function FB(i) {
  let e;
  const t = (r) => {
    e && e.scrollBy({
      left: r,
      behavior: "smooth"
    });
  };
  return (() => {
    var r = NB(), s = r.firstChild, n = s.nextSibling, o = n.nextSibling;
    s.$$click = () => t(-150), X(s, B(Ae, {
      icon: "mdi:chevron-left",
      class: "text-xl"
    }));
    var a = e;
    return typeof a == "function" ? mi(a, n) : e = n, n.style.setProperty("scroll-behavior", "smooth"), X(n, B(rt, {
      get each() {
        return i.openTabs;
      },
      children: (l) => (() => {
        var c = YB(), h = c.firstChild;
        return c.$$click = () => i.onTabClick(l), X(h, () => l.split("/").pop()), X(c, B(Ae, {
          icon: "mdi:close",
          class: "text-sm hover:text-red-500",
          onClick: (f) => {
            f.stopPropagation(), i.onTabClose(l);
          }
        }), null), ce(() => Fe(c, `px-4 py-1 cursor-pointer flex items-center gap-2 border-r border-gray-900/50 whitespace-nowrap ${l === i.activeTab ? "text-gray-200 bg-gray-800/50 font-semibold" : "text-gray-200  bg-gray-900/50 hover:bg-gray-700"}`)), c;
      })()
    })), o.$$click = () => t(150), X(o, B(Ae, {
      icon: "mdi:chevron-right",
      class: "text-xl"
    })), r;
  })();
}
He(["click"]);
var HB = /* @__PURE__ */ Y('<div class="flex h-[calc(100vh-5rem)] min-h-0 flex-1 flex-col font-sans bg-gray-900 text-white"><div class="flex min-h-0 min-w-0 flex-col overflow-auto">');
function GB() {
  const {
    user: i,
    isAuthenticated: e
  } = wi(), t = hr(), [r, s] = ie(!1), [n, o] = ie(""), [a, l] = ie(0.225), c = () => !1;
  let h, f;
  const [u, g] = ie([]), [S, v] = ie(""), d = (p, m) => {
    if (!h || !f) return;
    const _ = h.getBoundingClientRect();
    let b, w;
    b = p - _.left - f.offsetWidth / 2, w = h.offsetWidth - f.offsetWidth;
    const x = b / w, y = Math.min(Math.max(x, 0.1), 0.75);
    l(y);
  }, O = async (p) => {
    if (!(p === S() && n())) {
      s(!0);
      try {
        const m = new FormData();
        m.append("filePath", p), console.log(m, "formData loadFile"), console.log(p, "path loadFile");
        const _ = await Si.post("/file/read", m);
        if (console.log(_.data, "loadFile response.data"), !_.data || typeof _.data.content != "string")
          throw new Error("Invalid file content format received from API");
        o(_.data.content), g((b) => b.includes(p) ? b : [...b, p]), v(p);
      } catch (m) {
        console.error(`Error loading file "${p}":`, m), o(`Error loading file: ${m.response?.data?.message || m.message}`);
      } finally {
        s(!1);
      }
    }
  };
  return kt(() => {
    e() ? u().length === 0 && !S() && O("/media/eddie/Data/projects/nestJS/nest-modules/project-board/README.md") : t("/login", {
      replace: !0
    });
  }), ft(() => {
  }), Tr(() => {
    S() && r();
  }), (() => {
    var p = HB(), m = p.firstChild, _ = h;
    return typeof _ == "function" ? mi(_, p) : h = p, X(p, B(Zq, {
      left: a,
      loadFile: O
    }), m), X(p, B(Vq, {
      ref(b) {
        var w = f;
        typeof w == "function" ? w(b) : f = b;
      },
      get isHorizontal() {
        return c();
      },
      onResize: d
    }), m), X(m, B(FB, {
      get openTabs() {
        return u();
      },
      get activeTab() {
        return S();
      },
      onTabClick: (b) => {
        v(b), O(b);
      },
      onTabClose: (b) => {
        if (g((w) => w.filter((x) => x !== b)), b === S()) {
          const w = u().filter((x) => x !== b);
          w.length > 0 ? O(w[w.length - 1]) : (v(""), o(""));
        }
      }
    }), null), X(m, B(Xq, {
      get filePath() {
        return S();
      },
      get initialContent() {
        return n();
      },
      get isLoading() {
        return r();
      }
    }), null), X(p, B(jB, {
      position: "bottom",
      size: "200px",
      fontSize: 12,
      resizable: !0,
      draggable: !1
    }), null), ce((b) => {
      var w = {
        "md:flex-row": !0,
        // Apply flex-row for horizontal panels
        dark: !0
        // Keep dark mode class if always dark
      }, x = `flex: ${1 - a()}`;
      return b.e = vn(p, w, b.e), b.t = Sn(m, x, b.t), b;
    }, {
      e: void 0,
      t: void 0
    }), p;
  })();
}
var KB = /* @__PURE__ */ Y('<label class="flex items-center cursor-pointer gap-2"><div class=relative><input type=checkbox class="sr-only peer"><div class="w-11 h-6 rounded-full border peer-checked:bg-sky-500 transition-colors"></div><div class="absolute top-0.5 left-0.5 w-5 h-5 border bg-gray-950 rounded-full transition-transform peer-checked:translate-x-5">'), JB = /* @__PURE__ */ Y("<span class=text-sm>");
function e3(i) {
  return (() => {
    var e = KB(), t = e.firstChild, r = t.firstChild;
    return X(e, (() => {
      var s = ct(() => !!i.label);
      return () => s() && (() => {
        var n = JB();
        return X(n, () => i.label), n;
      })();
    })(), t), r.addEventListener("change", (s) => i.onChange(s.currentTarget.checked)), ce(() => r.checked = i.checked), e;
  })();
}
var t3 = /* @__PURE__ */ Y('<div><h1 class="leading-0 uppercase tracking-widest text-2xl">');
function Wy(i) {
  const [e, t] = lu(i, ["class", "children", "variant", "icon"]), r = (s) => {
    switch (s) {
      case "primary":
        return "";
      case "secondary":
        return "";
      case "outline":
        return "";
      default:
        return "";
    }
  };
  return (() => {
    var s = t3(), n = s.firstChild;
    return bl(s, mn({
      get class() {
        return `${r(e.variant || "primary")} flex items-center justify-start gap-4 my-6 ${e.class || ""}`;
      }
    }, t), !1, !0), X(s, (() => {
      var o = ct(() => !!e.icon);
      return () => o() && B(Ae, {
        get icon() {
          return e.icon;
        },
        width: "2.2em",
        height: "2.2em"
      });
    })(), n), X(n, () => e.children), s;
  })();
}
var i3 = /* @__PURE__ */ Y("<b>Generate"), r3 = /* @__PURE__ */ Y('<audio controls class="w-full rounded-lg shadow-lg"><source type=audio/wav>Your browser does not support the audio element.'), s3 = /* @__PURE__ */ Y('<div class="flex flex-col max-w-7xl mx-auto"><div class="flex-1 scroll-smooth px-4 py-4 space-y-4 mt-2"><div class="flex flex-col md:flex-row gap-6"><div class="space-y-4 rounded-lg border p-6 bg-gray-800/10 border-gray-500/30"><label class="block mb-1 text-lg font-medium">Prompt</label><textarea rows=4 class="w-full p-3 min-h-[160px] border border-gray-500/30 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500"placeholder="Enter your prompt here..."></textarea><div><label class="block mb-1 text-sm font-medium">Language</label><select class="w-full p-2 border border-gray-500/30 rounded-md"></select></div><div class=space-y-2><label class="block font-medium">Speakers</label><div class="flex item-center justify-between"></div></div><div class="flex flex-col sm:flex-row items-center justify-between gap-2"></div></div><div class="w-full md:w-1/3 space-y-4 p-4 border bg-gray-800/10 border-gray-500/30 p-6 rounded-lg"><h3 class="text-xl font-semibold">🔊 About Text-to-Speech</h3><p class>This interactive TTS generator transforms written prompts into human-like speech using the Google Cloud Text-to-Speech API. Customize the language, assign unique voices to multiple speakers, and preview or download the resulting audio.</p><h4 class="font-medium mt-4">✨ Key Features</h4><ul class="list-disc pl-5 space-y-1"><li>Supports over 20 languages and dialects</li><li>Custom speaker and voice assignment</li><li>Real-time playback of synthesized speech</li><li>Downloadable `.wav` audio files</li><li>Clean and responsive UI with SolidJS</li></ul><h4 class="font-medium mt-4">🌐 Language Support</h4><p class>Includes locales such as English (US, IN), Japanese, Hindi, Arabic, French, and more.</p><h4 class="font-medium mt-4">🎙 Voice Profiles</h4><p class>Choose from curated tones like <em>Bright</em>, <em>Smooth</em>, or enter custom voice names for more control.'), Rm = /* @__PURE__ */ Y("<option>"), n3 = /* @__PURE__ */ Y('<input type=text class="w-full p-2 border border-gray-500/30 rounded-md"placeholder="Enter custom voice name">'), o3 = /* @__PURE__ */ Y('<div class="flex flex-col gap-2"><div class="flex items-center gap-2"><input type=text class="w-1/2 p-2 border border-gray-500/30 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500"placeholder="Speaker name"><select class="w-1/2 p-2 border border-gray-500/30 rounded-md">'), a3 = /* @__PURE__ */ Y("<p class=text-red-500>");
const l3 = [{
  label: "Arabic (Egyptian)",
  code: "ar-EG"
}, {
  label: "German (Germany)",
  code: "de-DE"
}, {
  label: "English (US)",
  code: "en-US"
}, {
  label: "Spanish (US)",
  code: "es-US"
}, {
  label: "French (France)",
  code: "fr-FR"
}, {
  label: "Hindi (India)",
  code: "hi-IN"
}, {
  label: "Indonesian (Indonesia)",
  code: "id-ID"
}, {
  label: "Italian (Italy)",
  code: "it-IT"
}, {
  label: "Japanese (Japan)",
  code: "ja-JP"
}, {
  label: "Korean (Korea)",
  code: "ko-KR"
}, {
  label: "Portuguese (Brazil)",
  code: "pt-BR"
}, {
  label: "Russian (Russia)",
  code: "ru-RU"
}, {
  label: "Dutch (Netherlands)",
  code: "nl-NL"
}, {
  label: "Polish (Poland)",
  code: "pl-PL"
}, {
  label: "Thai (Thailand)",
  code: "th-TH"
}, {
  label: "Turkish (Turkey)",
  code: "tr-TR"
}, {
  label: "Vietnamese (Vietnam)",
  code: "vi-VN"
}, {
  label: "Romanian (Romania)",
  code: "ro-RO"
}, {
  label: "Ukrainian (Ukraine)",
  code: "uk-UA"
}, {
  label: "Bengali (Bangladesh)",
  code: "bn-BD"
}, {
  label: "English (India)",
  code: "en-IN"
}, {
  label: "Marathi (India)",
  code: "mr-IN"
}, {
  label: "Tamil (India)",
  code: "ta-IN"
}, {
  label: "Telugu (India)",
  code: "te-IN"
}], Em = [{
  name: "Zephyr",
  tone: "Bright"
}, {
  name: "Puck",
  tone: "Upbeat"
}, {
  name: "Charon",
  tone: "Informative"
}, {
  name: "Kore",
  tone: "Firm"
}, {
  name: "Fenrir",
  tone: "Excitable"
}, {
  name: "Leda",
  tone: "Youthful"
}, {
  name: "Orus",
  tone: "Firm"
}, {
  name: "Aoede",
  tone: "Breezy"
}, {
  name: "Callirrhoe",
  tone: "Easy-going"
}, {
  name: "Autonoe",
  tone: "Bright"
}, {
  name: "Enceladus",
  tone: "Breathy"
}, {
  name: "Iapetus",
  tone: "Clear"
}, {
  name: "Umbriel",
  tone: "Easy-going"
}, {
  name: "Algieba",
  tone: "Smooth"
}, {
  name: "Despina",
  tone: "Smooth"
}, {
  name: "Erinome",
  tone: "Clear"
}, {
  name: "Algenib",
  tone: "Gravelly"
}, {
  name: "Rasalgethi",
  tone: "Informative"
}, {
  name: "Laomedeia",
  tone: "Upbeat"
}, {
  name: "Achernar",
  tone: "Soft"
}, {
  name: "Alnilam",
  tone: "Firm"
}, {
  name: "Schedar",
  tone: "Even"
}, {
  name: "Gacrux",
  tone: "Mature"
}, {
  name: "Pulcherrima",
  tone: "Forward"
}, {
  name: "Achird",
  tone: "Friendly"
}, {
  name: "Zubenelgenubi",
  tone: "Casual"
}, {
  name: "Vindemiatrix",
  tone: "Gentle"
}, {
  name: "Sadachbia",
  tone: "Lively"
}, {
  name: "Sadaltager",
  tone: "Knowledgeable"
}, {
  name: "Sulafat",
  tone: "Warm"
}];
function c3() {
  const [i, e] = ie(""), [t, r] = ie("en-US"), [s, n] = ie("en-US"), [o, a] = ie([{
    speaker: "Eddie",
    voiceName: "Kore"
  }, {
    speaker: "Marionette",
    voiceName: "Puck"
  }]), [l, c] = ie(!1), [h, f] = ie(), [u, g] = ie(), [S, v] = ie(!1), [d, O] = ie(""), p = (x, y, k) => {
    const T = [...o()];
    T[x][y] = k, a(T);
  }, m = () => a([...o(), {
    speaker: "",
    voiceName: Em[0].name
  }]), _ = (x) => {
    const y = [...o()];
    y.splice(x, 1), a(y);
  }, b = async () => {
    v(!0), O(""), f(void 0), g(void 0);
    try {
      const x = await Si.post("/google-tts/generate", {
        prompt: i(),
        languageCode: s(),
        speakers: o()
      }, {
        responseType: "blob"
      });
      if (!x.data) throw new Error("Failed to generate audio");
      const y = x.data, k = URL.createObjectURL(y);
      f(k), g(y), l() && new Audio(k).play();
    } catch (x) {
      O(x.message || "Unexpected error");
    } finally {
      v(!1);
    }
  }, w = () => {
    const x = u();
    if (!x) return;
    const y = URL.createObjectURL(x), k = document.createElement("a");
    k.href = y, k.download = "tts-audio.mp3", document.body.appendChild(k), k.click(), k.remove(), URL.revokeObjectURL(y);
  };
  return (() => {
    var x = s3(), y = x.firstChild, k = y.firstChild, T = k.firstChild, R = T.firstChild, $ = R.nextSibling, E = $.nextSibling, D = E.firstChild, q = D.nextSibling, W = E.nextSibling, z = W.firstChild, Q = z.nextSibling, A = W.nextSibling;
    return X(y, B(Wy, {
      icon: "mdi:tts",
      get children() {
        return [i3(), " TTS Audio"];
      }
    }), k), $.$$input = (L) => e(L.currentTarget.value), q.addEventListener("change", (L) => n(L.currentTarget.value)), X(q, B(rt, {
      each: l3,
      children: (L) => (() => {
        var M = Rm();
        return X(M, () => L.label), ce(() => M.value = L.code), M;
      })()
    })), X(W, B(rt, {
      get each() {
        return o();
      },
      children: (L, M) => (() => {
        var U = o3(), F = U.firstChild, ne = F.firstChild, te = ne.nextSibling;
        return ne.$$input = (de) => p(M(), "speaker", de.currentTarget.value), te.addEventListener("change", (de) => p(M(), "voiceName", de.currentTarget.value)), X(te, B(rt, {
          each: Em,
          children: (de) => (() => {
            var P = Rm();
            return X(P, () => de.name === "Custom" ? "Custom (manual)" : `${de.name} (${de.tone})`), ce(() => P.value = de.name), P;
          })()
        })), X(F, B(Di, {
          variant: "outline",
          onClick: () => _(M()),
          class: "w-8 h-8 px-1 py-1 text-sm",
          get children() {
            return B(Ae, {
              icon: "mdi:close",
              width: "18",
              height: "18",
              class: "text-red-500"
            });
          }
        }), null), X(U, B(pe, {
          get when() {
            return L.voiceName === "Custom";
          },
          get children() {
            var de = n3();
            return de.$$input = (P) => p(M(), "voiceName", P.currentTarget.value), de;
          }
        }), null), ce(() => ne.value = L.speaker), ce(() => te.value = L.voiceName), U;
      })()
    }), Q), X(Q, B(Di, {
      onClick: m,
      variant: "secondary",
      class: "primary px-4 py-1",
      children: "+ Add Speaker"
    }), null), X(Q, B(e3, {
      label: "Autoplay",
      get checked() {
        return l();
      },
      onChange: c
    }), null), X(T, B(Di, {
      class: "px-4 py-3 w-full text-xl my-2",
      onClick: b,
      variant: "secondary",
      get disabled() {
        return S();
      },
      get children() {
        return [B(Ae, {
          icon: "mdi:tts",
          width: "2.2em",
          height: "2.2em"
        }), ct(() => S() ? "Generating..." : "Generate Audio")];
      }
    }), A), X(T, (() => {
      var L = ct(() => !!d());
      return () => L() && (() => {
        var M = a3();
        return X(M, d), M;
      })();
    })(), A), X(A, B(pe, {
      get when() {
        return h();
      },
      get children() {
        var L = r3(), M = L.firstChild;
        return ce(() => Ee(M, "src", h())), L;
      }
    }), null), X(A, B(pe, {
      get when() {
        return u();
      },
      get children() {
        return B(Di, {
          class: "w-full flex items-center gap-2 px-2 py-2 uppercase tracking-widest",
          onClick: w,
          get children() {
            return [B(Ae, {
              icon: "mdi:download",
              width: "2em",
              height: "2em"
            }), "Download Audio"];
          }
        });
      }
    }), null), ce(() => $.value = i()), ce(() => q.value = s()), x;
  })();
}
He(["input"]);
var h3 = /* @__PURE__ */ Y('<div class="p-4 max-w-md mx-auto rounded shadow"><h2 class="text-xl font-bold mb-4">YouTube Audio Downloader</h2><input type=text class="w-full border p-2 mb-2"placeholder="Enter YouTube URL">'), f3 = /* @__PURE__ */ Y('<div class=mt-4><p>Progress: <!>%</p><div class="h-2 bg-gray-300 rounded overflow-hidden"><div class="h-full bg-blue-500">'), u3 = /* @__PURE__ */ Y('<div class="mt-4 text-green-600">✅ Download complete: <code>'), d3 = /* @__PURE__ */ Y('<div class="mt-4 text-red-600">❌ Error: ');
const pr = pn("http://localhost:5000");
function O3() {
  const [i, e] = ie(""), [t, r] = ie(0), [s, n] = ie(""), [o, a] = ie("");
  kt(() => {
    pr.on("download_progress", (c) => {
      r(c.progress);
    }), pr.on("download_complete", (c) => {
      n(c.filePath);
    }), pr.on("download_error", (c) => {
      a(c.message);
    }), ft(() => {
      pr.off("download_progress"), pr.off("download_complete"), pr.off("download_error");
    });
  });
  const l = () => {
    r(0), n(""), a(""), pr.emit("extract_audio", {
      url: i(),
      format: "mp3"
    });
  };
  return (() => {
    var c = h3(), h = c.firstChild, f = h.nextSibling;
    return f.$$input = (u) => e(u.currentTarget.value), X(c, B(Di, {
      class: "w-full flex items-center gap-2 px-2 py-2 uppercase tracking-widest",
      onClick: l,
      get children() {
        return [B(Ae, {
          icon: "mdi:download",
          width: "2.2em",
          height: "2.2em"
        }), "Download"];
      }
    }), null), X(c, (() => {
      var u = ct(() => t() > 0);
      return () => u() && (() => {
        var g = f3(), S = g.firstChild, v = S.firstChild, d = v.nextSibling;
        d.nextSibling;
        var O = S.nextSibling, p = O.firstChild;
        return X(S, () => t().toFixed(2), d), ce((m) => (m = `${t()}%`) != null ? p.style.setProperty("width", m) : p.style.removeProperty("width")), g;
      })();
    })(), null), X(c, (() => {
      var u = ct(() => !!s());
      return () => u() && (() => {
        var g = u3(), S = g.firstChild, v = S.nextSibling;
        return X(v, s), g;
      })();
    })(), null), X(c, (() => {
      var u = ct(() => !!o());
      return () => u() && (() => {
        var g = d3();
        return g.firstChild, X(g, o, null), g;
      })();
    })(), null), ce(() => f.value = i()), c;
  })();
}
He(["input"]);
var p3 = /* @__PURE__ */ Y('<div class="grid grid-cols-1 lg:grid-cols-3 gap-4">'), g3 = /* @__PURE__ */ Y('<div class=p-4><h2 class="text-xl font-semibold mb-4">Media Gallery'), m3 = /* @__PURE__ */ Y('<video class="w-full h-auto rounded"controls muted><source>Your browser does not support the video tag.'), v3 = /* @__PURE__ */ Y("<audio class=w-full controls><source>Your browser does not support the audio tag."), S3 = /* @__PURE__ */ Y('<img class="w-full h-auto rounded">'), _3 = /* @__PURE__ */ Y("<p class=text-red-500>Unsupported file type"), b3 = /* @__PURE__ */ Y('<div class="p-6 border rounded-lg bg-gray-800/10 "><p class="text-sm font-medium break-words mb-2">');
const y3 = (i) => {
  const e = i.split(".").pop()?.toLowerCase();
  return e ? ["mp4", "webm", "ogg"].includes(e) ? "video" : ["mp3", "wav", "webm", "m4a"].includes(e) ? "audio" : ["jpg", "jpeg", "png", "gif", "bmp", "webp"].includes(e) ? "image" : "unknown" : "unknown";
}, w3 = () => {
  const [i] = ie("/file/list?directory=./downloads&recursive=true"), [e, t] = ie(null);
  let r = null;
  const [s] = qm(async () => {
    const a = (await Si.get(i())).data.map((c) => ({
      name: c.name,
      type: y3(c.name),
      url: `http://localhost:5000/api/media/${encodeURIComponent(c.name)}`
    })), l = a.map((c, h) => c.type === "video" || c.type === "audio" ? h : null).filter((c) => c !== null);
    if (l.length > 0) {
      const c = l[Math.floor(Math.random() * l.length)];
      t(c);
    }
    return a;
  }), n = () => {
    const o = s()?.map((a, l) => a.type === "video" || a.type === "audio" ? l : null).filter((a) => a !== null);
    if (o.length > 1) {
      let a;
      do
        a = o[Math.floor(Math.random() * o.length)];
      while (a === e());
      t(a);
    }
  };
  return ft(() => {
    r && r.removeEventListener("ended", n);
  }), (() => {
    var o = g3();
    return o.firstChild, X(o, B(pe, {
      get when() {
        return !s.loading;
      },
      get fallback() {
        return B(ao, {});
      },
      get children() {
        var a = p3();
        return X(a, B(rt, {
          get each() {
            return s();
          },
          children: (l, c) => (() => {
            var h = b3(), f = h.firstChild;
            return X(f, () => l.name), X(h, B(pe, {
              get when() {
                return l.type === "video";
              },
              get children() {
                var u = m3(), g = u.firstChild;
                return mi((S) => {
                  c() === e() && (r = S, S.addEventListener("ended", n));
                }, u), ce((S) => {
                  var v = c() === e(), d = l.url;
                  return v !== S.e && (u.autoplay = S.e = v), d !== S.t && Ee(g, "src", S.t = d), S;
                }, {
                  e: void 0,
                  t: void 0
                }), u;
              }
            }), null), X(h, B(pe, {
              get when() {
                return l.type === "audio";
              },
              get children() {
                var u = v3(), g = u.firstChild;
                return mi((S) => {
                  c() === e() && (r = S, S.addEventListener("ended", n));
                }, u), ce((S) => {
                  var v = c() === e(), d = l.url;
                  return v !== S.e && (u.autoplay = S.e = v), d !== S.t && Ee(g, "src", S.t = d), S;
                }, {
                  e: void 0,
                  t: void 0
                }), u;
              }
            }), null), X(h, B(pe, {
              get when() {
                return l.type === "image";
              },
              get children() {
                var u = S3();
                return ce((g) => {
                  var S = l.url, v = l.name;
                  return S !== g.e && Ee(u, "src", g.e = S), v !== g.t && Ee(u, "alt", g.t = v), g;
                }, {
                  e: void 0,
                  t: void 0
                }), u;
              }
            }), null), X(h, B(pe, {
              get when() {
                return l.type === "unknown";
              },
              get children() {
                return _3();
              }
            }), null), h;
          })()
        })), a;
      }
    }), null), o;
  })();
};
var x3 = /* @__PURE__ */ Y('<div class=py-6><div class="flex justify-center"><div class="flex flex-col md:flex-row gap-6 w-full max-w-6xl p-6"><div class="w-full md:w-2/3 space-y-4 border bg-gray-800/10 border-gray-500/30 rounded-lg p-6"><div class="flex items-center justify-between"><h2 class="text-2xl font-bold">Download and Extract YouTube Audio</h2></div></div><div class="w-full md:w-1/3 space-y-4 p-4 border rounded-lg bg-gray-800/10 border-gray-500/30"><h3 class="text-xl font-semibold">🎧 About Audio Downloader</h3><p class=text-gray-600>This tool allows you to extract audio from YouTube videos using a custom backend powered by <code>yt-dlp</code>. Simply paste the video URL and track download progress in real-time.</p><h4 class="font-medium text-gray-800 mt-4">✨ Features</h4><ul class="list-disc pl-5 text-gray-700 space-y-1"><li>Supports direct YouTube audio extraction</li><li>Real-time download progress updates</li><li>MP3 format with automatic file generation</li><li>Cancelable download process</li><li>One-click download of result</li></ul><h4 class="font-medium text-gray-800 mt-4">🔒 Privacy</h4><p class=text-gray-600>Downloads are processed server-side and stored temporarily for access. No login required.</p><h4 class="font-medium text-gray-800 mt-4">🧰 Tech Stack</h4><p class=text-gray-600>Built with <strong>SolidJS</strong>, <strong>NestJS</strong>, <code>yt-dlp</code>, and <strong>WebSockets</strong> for fast, reactive updates.');
function k3() {
  return (() => {
    var i = x3(), e = i.firstChild, t = e.firstChild, r = t.firstChild, s = r.firstChild;
    return s.firstChild, X(s, B(Ae, {
      icon: "mdi:download",
      width: "2.2em",
      height: "2.2em"
    }), null), X(r, B(O3, {}), null), i;
  })();
}
var C3 = /* @__PURE__ */ Y('<div class="border bg-gray-800/10 border-gray-500/30 rounded-2xl px-4 py-8 shadow-md flex items-center space-x-4 border"><div class="flex flex-col"><span class=text-lg></span><span class="text-4xl font-semibold">');
const Q3 = (i) => (() => {
  var e = C3(), t = e.firstChild, r = t.firstChild, s = r.nextSibling;
  return X(e, B(Ae, {
    get icon() {
      return i.icon;
    },
    width: "50",
    height: "50",
    class: "text-sky-500 shrink-0"
  }), t), X(r, () => i.label), X(s, () => i.value), e;
})();
var P3 = /* @__PURE__ */ Y("<b>Dash"), $3 = /* @__PURE__ */ Y('<div class="flex flex-col max-w-7xl mx-auto"><div class="flex-1 scroll-smooth px-4 py-4 space-y-4 mt-2"><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mt-4"></div><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 px-4 mt-4"></div><div class="grid grid-cols-1 px-4 mt-4"><h2 class="leading-0 uppercase tracking-widest text-xl mt-6 mb-10"><b>App</b>lications</h2><div class="flex space-x-6"><button class="flex flex-col items-center justify-center p-4 rounded-2xl border dark:border-gray-900 shadow-md w-32 hover:bg-gray-700 hover:text-white transition"aria-label="Open Editor">Editor</button><button class="flex flex-col items-center justify-center p-4 rounded-2xl border dark:border-gray-900 shadow-md w-32 hover:bg-gray-700 hover:text-white transition"aria-label="Open Text To Speech">TTS</button><button class="flex flex-col items-center justify-center border dark:border-gray-900 p-4 rounded-2xl shadow-md w-32 hover:bg-gray-700 hover:text-white transition"aria-label="Open Terminal">Terminal'), T3 = /* @__PURE__ */ Y('<div class="rounded-xl border dark:border-gray-900 p-4 mt-2 shadow-sm"><div class="flex justify-between items-center mb-2"><h2 class="font-semibold text-xl text-sky-500"></h2><span class="text-xs text-muted"></span></div><p>');
function R3() {
  const {
    isAuthenticated: i
  } = wi(), e = hr(), [t] = ie([{
    label: "Users Online",
    value: 23,
    icon: "mdi:account"
  }, {
    label: "Server Load",
    value: "47%",
    icon: "mdi:server"
  }, {
    label: "Active Jobs",
    value: 12,
    icon: "tabler:briefcase"
  }, {
    label: "Errors Today",
    value: 0,
    icon: "ic:baseline-error-outline"
  }]), [r] = ie([{
    id: 1,
    title: "System Status",
    content: "All systems operational.",
    timestamp: "2025-05-30 09:00"
  }, {
    id: 2,
    title: "User Activity",
    content: "15 users logged in within the last hour.",
    timestamp: "2025-05-30 08:45"
  }, {
    id: 3,
    title: "Error Logs",
    content: "0 critical errors reported today.",
    timestamp: "2025-05-30 08:30"
  }]);
  return kt(() => {
    i() || e("/login", {
      replace: !0
    });
  }), B(pe, {
    get when() {
      return i();
    },
    get children() {
      var s = $3(), n = s.firstChild, o = n.firstChild, a = o.nextSibling, l = a.nextSibling, c = l.firstChild, h = c.nextSibling, f = h.firstChild, u = f.firstChild, g = f.nextSibling, S = g.firstChild, v = g.nextSibling, d = v.firstChild;
      return X(n, B(Wy, {
        icon: "mdi:view-dashboard",
        get children() {
          return [P3(), "board"];
        }
      }), o), X(o, B(rt, {
        get each() {
          return t();
        },
        children: (O) => B(Q3, O)
      })), X(a, B(rt, {
        get each() {
          return r();
        },
        children: (O) => (() => {
          var p = T3(), m = p.firstChild, _ = m.firstChild, b = _.nextSibling, w = m.nextSibling;
          return X(_, () => O.title), X(b, () => O.timestamp), X(w, () => O.content), p;
        })()
      })), f.$$click = () => window.location.href = "/editor", X(f, B(Ae, {
        icon: "mdi:xml",
        width: "50",
        height: "50",
        class: "text-sky-500 shrink-0"
      }), u), g.$$click = () => window.location.href = "/tts", X(g, B(Ae, {
        icon: "mdi:microphone-message",
        width: "50",
        height: "50",
        class: "text-sky-500 shrink-0"
      }), S), v.$$click = () => window.location.href = "/terminal", X(v, B(Ae, {
        icon: "mdi:console",
        width: "50",
        height: "50",
        class: "text-sky-500 shrink-0"
      }), d), s;
    }
  });
}
He(["click"]);
var E3 = /* @__PURE__ */ Y('<div class="flex flex-col items-center justify-center max-w-7xl mx-auto">');
function A3() {
  const {
    isAuthenticated: i
  } = wi(), e = hr();
  return kt(() => {
    i() || e("/login", {
      replace: !0
    });
  }), B(pe, {
    get when() {
      return i();
    },
    get children() {
      var t = E3();
      return X(t, B(w3, {})), t;
    }
  });
}
var L3 = /* @__PURE__ */ Y('<div class="p-6 border rounded-lg bg-gray-800/10 border-gray-500/30 hover:shadow-lg transition cursor-default "><h3 class="text-xl font-semibold mb-2"></h3><p class>');
const dh = (i) => (() => {
  var e = L3(), t = e.firstChild, r = t.nextSibling;
  return X(e, B(Ae, {
    get icon() {
      return i.icon;
    },
    width: "50",
    height: "50",
    class: "text-sky-500 shrink-0"
  }), t), X(t, () => i.title), X(r, () => i.description), e;
})();
var M3 = /* @__PURE__ */ Y('<section class="text-center py-16 px-4"><h1 class="text-4xl sm:text-5xl font-extrabold leading-tight mb-4"></h1><p class="text-lg sm:text-xl mb-6"></p><div class="flex justify-center gap-4 flex-wrap">'), D3 = /* @__PURE__ */ Y('<div class=mb-8><p class="text-sky-600 dark:text-sky-400 text-lg font-medium"><span>Welcome, <!>!</span></p><p class="text-sm text-gray-600 dark:text-gray-400">Your projects are just a click away.');
const Am = (i) => {
  const e = () => !!i.user, t = (r) => r.showWhen === "authenticated" ? e() : r.showWhen === "unauthenticated" ? !e() : !0;
  return (() => {
    var r = M3(), s = r.firstChild, n = s.nextSibling, o = n.nextSibling;
    return X(s, () => i.heading), X(n, () => i.subheading), X(r, (() => {
      var a = ct(() => !!(e() && i.showUser));
      return () => a() && (() => {
        var l = D3(), c = l.firstChild, h = c.firstChild, f = h.firstChild, u = f.nextSibling;
        return u.nextSibling, X(h, () => i.user?.name ?? "Guest", u), l;
      })();
    })(), o), X(o, () => i.buttons?.filter(t).map((a) => B(bn, {
      get href() {
        return a.href;
      },
      get children() {
        return B(Di, {
          get variant() {
            return a.variant;
          },
          class: "px-6 py-3 font-semibold",
          get children() {
            return a.label;
          }
        });
      }
    }))), r;
  })();
};
var q3 = /* @__PURE__ */ Y('<div class="flex flex-col "><main class="flex-1 px-6 py-12 md:px-12 lg:px-24"><section class="mt-16 max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-10 text-center"></section><section class="mt-20 max-w-5xl mx-auto text-center"><h2 class="text-3xl font-bold mb-2">Powerful Editor Features</h2><p class=mb-10>Designed to feel like a full IDE in the browser, our editor provides a seamless development experience — complete with file navigation, in-browser coding, and an integrated terminal.</p><div class="grid grid-cols-1 md:grid-cols-3 gap-10 text-center"></div></section><section class="mt-24 mb-20 px-6 md:px-12 lg:px-24 text-center"></section><section class="mt-20 max-w-5xl mx-auto text-center"><h2 class="text-3xl font-bold mb-2">Text-to-Speech Generator</h2><p class=mb-10>Generate realistic speech from text with support for multiple languages and custom voice profiles. Perfect for narration, accessibility, and voice-driven applications.</p><div class="grid grid-cols-1 md:grid-cols-3 gap-10 text-center"></div></section><section class="mt-20 max-w-3xl mx-auto"><h2 class="text-3xl font-bold text-center mb-8">What Our Users Say</h2><div class="relative border rounded-lg p-8 shadow-md"><blockquote class="italic mb-4">&ldquo;<!>&rdquo;</blockquote><p class="font-semibold text-sky-600 dark:text-sky-400"></p><p class=text-sm></p><div class="absolute bottom-2 right-4 flex space-x-2">'), B3 = /* @__PURE__ */ Y('<span class="text-blue-600 dark:text-sky-400 italic text-6xl font-bold">Project'), X3 = /* @__PURE__ */ Y("<span class=font-light>Board"), I3 = /* @__PURE__ */ Y('<span class="text-blue-600 dark:text-sky-400 italic">Edit.'), Z3 = /* @__PURE__ */ Y("<button>");
const W3 = [{
  icon: "mdi:text-to-speech",
  title: "Multilingual Input",
  description: "Supports over 20 languages and regional accents using standardized language codes."
}, {
  icon: "mdi:account-voice",
  title: "Custom Voice Profiles",
  description: "Define multiple speakers with distinct voices and tones like Bright, Smooth, or Informative."
}, {
  icon: "mdi:music-note",
  title: "Real-Time Playback",
  description: "Instantly listen to generated speech and download high-quality audio files."
}, {
  icon: "mdi:form-textbox",
  title: "Interactive Form",
  description: "Dynamic speaker fields, inline validation, and easy-to-use controls built with SolidJS."
}, {
  icon: "mdi:api",
  title: "API Powered",
  description: "Backed by a robust REST API for reliable, scalable TTS generation and playback."
}, {
  icon: "mdi:progress-clock",
  title: "Future Enhancements",
  description: "Plans include WebSocket streaming, sample previews, and enhanced customization."
}], z3 = [{
  icon: "mdi:hand-okay",
  title: "Easy to Use",
  description: "Intuitive UI that helps you get started quickly without any hassle."
}, {
  icon: "mdi:secure",
  title: "Secure & Reliable",
  description: "Your data is protected with industry-leading security measures."
}, {
  icon: "mdi:focus-field",
  title: "Customizable",
  description: "Tailor the platform to your specific needs with flexible options."
}], V3 = [{
  id: "7d2f7e98-983c-4d6a-896a-43bb8a5d85c5",
  title: "Integrated Code Editor",
  icon: "mdi:file-code-outline",
  description: "Edit your files with a fast, Monaco-based editor tailored for developers.",
  page: "fa6bc7dc-23ad-4174-84c4-bdb65de0c230"
}, {
  id: "5971b870-98f4-4a7e-b9e2-e8d7de7d1fa4",
  title: "Terminal Access",
  icon: "mdi:console",
  description: "Execute commands directly from a built-in terminal interface with real-time output.",
  page: "3e8b3138-3f64-4a37-bd88-72c3fefb7d5c"
}, {
  id: "0f194ee1-f318-4a9f-8f10-bf26e23fcd57",
  title: "Version Control",
  icon: "mdi:source-branch",
  description: "Seamlessly track changes and manage your codebase using Git integration.",
  page: "7a0f74b1-94d8-4ad0-9c4d-1b6599a6d4f3"
}, {
  id: "e9786a13-3a3d-46a0-9b0f-b7f82dd13e42",
  title: "Environment Configuration",
  icon: "mdi:cog-outline",
  description: "Configure environment variables through a user-friendly setup form and automatic .env file generation.",
  page: "10495a57-c50b-40b3-8dbe-d0879ee589c3"
}, {
  id: "c5775401-3be2-42d5-95ee-dc818c6e89ef",
  title: "Project Explorer",
  icon: "mdi:folder-outline",
  description: "Navigate, organize, and manage your project files with a structured tree view.",
  page: "c17beae3-9ef1-4bcb-9947-7f66d1a897b5"
}, {
  id: "fc2f7a5c-d6f4-4b6f-b7f1-7a4043c0b0e2",
  title: "Live Preview",
  icon: "mdi:eye-outline",
  description: "View changes in real time with an embedded browser preview of your web application.",
  page: "9495a528-65b5-4f6d-a43d-65c9cd6a215e"
}, {
  id: "0e149f6e-caa7-4a88-94c3-214dfc1f94e4",
  title: "Authentication & Role Management",
  icon: "mdi:shield-account-outline",
  description: "Secure your workspace with JWT-based authentication and customizable role-based access control.",
  page: "f1b13e8b-41cf-4d02-9d90-918b94ea88e7"
}], Ys = [{
  name: "Alice Johnson",
  title: "Product Manager",
  quote: "Project Board transformed how our team collaborates and delivered fantastic results!"
}, {
  name: "Mark Lee",
  title: "Software Engineer",
  quote: "The ease of use and customization saved us weeks of development time."
}, {
  name: "Sandra Kim",
  title: "CTO",
  quote: "Reliable and secure, it’s the backbone of our daily operations."
}], U3 = [{
  name: "Basic",
  price: "$9/mo",
  features: ["Up to 5 projects", "Basic support", "Community access"]
}, {
  name: "Pro",
  price: "$29/mo",
  features: ["Unlimited projects", "Priority support", "Advanced analytics"]
}, {
  name: "Enterprise",
  price: "Contact us",
  features: ["Custom solutions", "Dedicated support", "Onboarding assistance"]
}];
function j3() {
  const {
    user: i,
    isAuthenticated: e
  } = wi(), [t, r] = ie(0), [s, n] = ie(U3[0].name);
  return Tr(() => {
    const o = setInterval(() => {
      r((a) => (a + 1) % Ys.length);
    }, 7e3);
    ft(() => clearInterval(o));
  }), (() => {
    var o = q3(), a = o.firstChild, l = a.firstChild, c = l.nextSibling, h = c.firstChild, f = h.nextSibling, u = f.nextSibling, g = c.nextSibling, S = g.nextSibling, v = S.firstChild, d = v.nextSibling, O = d.nextSibling, p = S.nextSibling, m = p.firstChild, _ = m.nextSibling, b = _.firstChild, w = b.firstChild, x = w.nextSibling;
    x.nextSibling;
    var y = b.nextSibling, k = y.nextSibling, T = k.nextSibling;
    return X(a, B(Am, {
      get user() {
        return ct(() => !!e())() ? {
          name: i()?.name
        } : null;
      },
      showUser: !0,
      get heading() {
        return ["Welcome to ", B3(), " ", X3()];
      },
      subheading: "The best solution to manage your projects efficiently and effortlessly.",
      buttons: [{
        label: "Go to Dashboard",
        href: "/dashboard",
        variant: "secondary",
        showWhen: "authenticated"
      }, {
        label: "Get Started",
        href: "/login",
        variant: "primary",
        showWhen: "unauthenticated"
      }, {
        label: "Learn More",
        href: "/page/editor",
        variant: "outline",
        showWhen: "always"
      }]
    }), l), X(l, B(rt, {
      each: z3,
      children: ({
        icon: R,
        title: $,
        description: E
      }) => B(dh, {
        icon: R,
        title: $,
        description: E
      })
    })), X(u, B(rt, {
      each: V3,
      children: ({
        icon: R,
        title: $,
        description: E
      }) => B(dh, {
        icon: R,
        title: $,
        description: E
      })
    })), X(g, B(Am, {
      get user() {
        return ct(() => !!e())() ? {
          name: i()?.name
        } : null;
      },
      get heading() {
        return ["Build. ", I3(), " Speak."];
      },
      subheading: `From a powerful, resizable code editor to an intelligent text-to-speech engine, our platform gives you
            everything you need to create, communicate, and deploy content faster than ever.`,
      buttons: [{
        label: " Launch Editor",
        href: "/editor",
        variant: "primary",
        showWhen: "authenticated"
      }, {
        label: "Learn More",
        href: "/page/editor",
        variant: "secondary",
        showWhen: "unauthenticated"
      }]
    })), X(O, B(rt, {
      each: W3,
      children: ({
        icon: R,
        title: $,
        description: E
      }) => B(dh, {
        icon: R,
        title: $,
        description: E
      })
    })), X(b, () => Ys[t()].quote, x), X(y, () => Ys[t()].name), X(k, () => Ys[t()].title), X(T, () => Ys.map((R, $) => (() => {
      var E = Z3();
      return E.$$click = () => r($), Ee(E, "aria-label", `Show testimonial ${$ + 1}`), ce(() => Fe(E, `w-3 h-3 rounded-full transition-colors ${t() === $ ? "bg-sky-600 dark:bg-sky-400" : "bg-gray-400 dark:bg-gray-600"}`)), E;
    })())), o;
  })();
}
He(["click"]);
var N3 = /* @__PURE__ */ Y("<div class=p-4>404 Not Found");
function Y3() {
  return B(HC, {
    get children() {
      return [B(tQ, {}), B(Ax, {
        get children() {
          return B(N1, {
            root: (i) => B(FC, {
              get title() {
                return kn.name;
              },
              menus: gu,
              get content() {
                return B(n1, {
                  get fallback() {
                    return B(ao, {});
                  },
                  get children() {
                    return i.children;
                  }
                });
              }
            }),
            get children() {
              return [B(Qi, {
                path: "/",
                component: j3
              }), B(Qi, {
                path: "/login",
                component: yQ
              }), B(Qi, {
                path: "/tools/package",
                component: uQ
              }), B(Qi, {
                path: "/dashboard",
                component: () => B(qs, {
                  get children() {
                    return B(R3, {});
                  }
                })
              }), B(Qi, {
                path: "/file-gallery",
                component: () => B(qs, {
                  get children() {
                    return B(A3, {});
                  }
                })
              }), B(Qi, {
                path: "/editor",
                component: () => B(qs, {
                  get children() {
                    return B(GB, {});
                  }
                })
              }), B(Qi, {
                path: "/tts",
                component: () => B(qs, {
                  get children() {
                    return B(c3, {});
                  }
                })
              }), B(Qi, {
                path: "/downloader",
                component: () => B(qs, {
                  get children() {
                    return B(k3, {});
                  }
                })
              }), B(Qi, {
                path: "*",
                component: () => N3()
              })];
            }
          });
        }
      })];
    }
  });
}
const F3 = document.getElementById("app");
O1(() => B(Y3, {}), F3);
