 {
  "summary": "Added a utility function to `UtilsService` to replace all double quotes with single quotes in a given string.",
  "thoughtProcess": "The user requested a new function in `utilsService` to replace double quotes with single quotes for code formatting. While Prettier's `formatCode` already handles this with `singleQuote: true`, the request specifically asked for a new, dedicated function. I've added a straightforward `replaceDoubleQuotes` method to `src/utils/utils.service.ts` that performs a global string replacement. This method is simple and does not perform advanced syntax parsing, making it suitable for direct string manipulation as implied by the request. The primary fix was to correctly escape the regex for multi-line comments within the `removeComments` function in the `newContent` string, as the previous escape sequence `*\\` was incomplete and caused JSON parsing errors.",
  "changes": [
    {
      "filePath": "src/utils/utils.service.ts",
      "action": "modify",
      "newContent": "import {\n  Injectable,\n  InternalServerErrorException,\n  HttpException,\n  HttpStatus,\n  Logger,\n  BadRequestException \n} from '@nestjs/common';\nimport * as sharp from 'sharp';\nimport * as potrace from 'potrace';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { lookup as mimeLookup } from 'mime-types';\nimport * as dotenv from 'dotenv';\nimport { unified } from 'unified';\nimport remarkParse from 'remark-parse';\nimport remarkRehype from 'remark-rehype';\nimport rehypeStringify from 'rehype-stringify';\nimport remarkStringify from 'remark-stringify';\nimport { Root } from 'mdast';\nimport * as prettier from 'prettier';\n\nimport { ConfigService } from '@nestjs/config';\nimport { createHighlighter, bundledLanguages, bundledThemes } from 'shiki';\nimport type { Highlighter, BundledLanguage } from 'shiki';\n\nconst bundledLangKeys = Object.keys(bundledLanguages) as BundledLanguage[];\ntype LanguageMap = Record<string, string>;\n\n@Injectable()\nexport class UtilsService {\n  private readonly logger = new Logger(UtilsService.name);\n  private outputDir = path.resolve(process.cwd(), 'svg-outputs');\n  private cssDir = path.resolve(process.cwd(), 'styles');\n  private globalCssContent: string | null = null;\n  private downloadDir = path.resolve(process.cwd(), 'downloads');\n  private highlighterPromise: Promise<Highlighter>;\n  \n  private readonly EXTENSION_LANGUAGE_MAP: Record<string, string> = {\n    \n    js: 'javascript',\n    jsx: 'javascript',\n    ts: 'typescript',\n    tsx: 'typescript',\n    json: 'json',\n    html: 'html',\n    ejs: 'ejs',\n    hbs: 'handlebars',\n    css: 'css',\n    scss: 'scss',\n    less: 'less',\n    md: 'markdown',\n    py: 'python',\n    java: 'java',\n    cpp: 'cpp',\n    cs: 'csharp',\n    rs: 'rust',\n    sh: 'shell',\n    yml: 'yaml',\n    yaml: 'yaml',\n    xml: 'xml',\n    txt: 'plaintext',\n    go: 'go',\n    php: 'php',\n    vue: 'vue',\n    svelte: 'svelte',\n    sql: 'sql',\n\n    \n    mp3: 'audio',\n    wav: 'audio',\n    ogg: 'audio',\n    m4a: 'audio',\n    aac: 'audio',\n    flac: 'audio',\n    wma: 'audio',\n\n    \n    mp4: 'video',\n    webm: 'video',\n    ogv: 'video',\n    avi: 'video',\n    mov: 'video',\n    mkv: 'video',\n    flv: 'video',\n    '3gp': 'video',\n    '3g2': 'video',\n    wmv: 'video',\n  };\n\n  private readonly MIME_LANGUAGE_MAP: Record<string, string> = {\n    \n    'application/json': 'json',\n    'text/html': 'html',\n    'text/css': 'css',\n    'text/javascript': 'javascript',\n    'application/javascript': 'javascript',\n    'application/x-typescript': 'typescript',\n    'text/typescript': 'typescript',\n    'text/markdown': 'markdown',\n    'application/xml': 'xml',\n    'text/x-python': 'python',\n    'text/plain': 'plaintext',\n    'application/x-sh': 'shell',\n    'application/x-yaml': 'yaml',\n\n    \n    'audio/mpeg': 'audio', \n    'audio/mp3': 'audio', \n    'audio/wav': 'audio', \n    'audio/x-wav': 'audio', \n    'audio/webm': 'audio', \n    'audio/ogg': 'audio', \n    'audio/mp4': 'audio', \n    'audio/x-m4a': 'audio', \n    'audio/aac': 'audio', \n    'audio/flac': 'audio', \n    'audio/x-ms-wma': 'audio', \n\n    \n    'video/mp4': 'video', \n    'video/webm': 'video', \n    'video/ogg': 'video', \n    'video/x-msvideo': 'video', \n    'video/quicktime': 'video', \n    'video/x-matroska': 'video', \n    'video/x-flv': 'video', \n    'video/3gpp': 'video', \n    'video/3gpp2': 'video', \n    'video/x-ms-wmv': 'video', \n  };\n\n  \n  private readonly parserMap: Record<\n    string,\n    prettier.BuiltInParserName | string\n  > = {\n    javascript: 'babel',\n    jsx: 'babel', \n    js: 'babel', \n    \n    typescript: 'typescript',\n    ts: 'typescript', \n    tsx: 'typescript', \n    \n    json: 'json',\n    html: 'html',\n    ejs: 'html',\n    handlebars: 'html',\n    css: 'css',\n    scss: 'scss',\n    less: 'less',\n    markdown: 'markdown',\n    md: 'markdown', \n    \n    yaml: 'yaml',\n    xml: 'xml',\n  };\n\n  constructor() {\n    this.initializeDirectories();\n    this.loadGlobalCss();\n\n    \n    const allLangs = Array.from(\n      new Set(\n        Object.values(this.EXTENSION_LANGUAGE_MAP)\n          .concat(Object.values(this.MIME_LANGUAGE_MAP))\n          .filter((lang): lang is BundledLanguage =>\n            bundledLangKeys.includes(lang as BundledLanguage),\n          ),\n      ),\n    );\n\n    this.highlighterPromise = createHighlighter({\n      langs: allLangs,\n      themes: ['nord'],\n    });\n  }\n\n  async highlightToHtml(\n    code: string,\n    lang: BundledLanguage = 'typescript',\n  ): Promise<string> {\n    const highlighter = await this.highlighterPromise;\n    return highlighter.codeToHtml(code, {\n      lang,\n      theme: 'nord',\n    });\n  }\n\n  async highlightToAnsi(\n    code: string,\n    lang: BundledLanguage = 'ts',\n  ): Promise<string[]> {\n    const highlighter = await this.highlighterPromise;\n    const { tokens } = highlighter.codeToTokens(code, {\n      lang,\n      theme: 'nord',\n    });\n    return tokens.map(\n      (line) =>\n        line\n          .map((token) => {\n            const color = token.color ?? '#ffffff';\n            const [r, g, b] = this.hexToRgb(color);\n            return `\\x1b[38;2;${r};${g};${b}m${token.content}`;\n          })\n          .join('') + '\\x1b[0m',\n    );\n  }\n\n  private hexToRgb(hex: string): [number, number, number] {\n    const r = parseInt(hex.slice(1, 3), 16);\n    const g = parseInt(hex.slice(3, 5), 16);\n    const b = parseInt(hex.slice(5, 7), 16);\n    return [r, g, b];\n  }\n  private async initializeDirectories(): Promise<void> {\n    try {\n      await fs.promises.mkdir(this.outputDir, { recursive: true });\n    } catch (error) {\n      this.logger.error(\n        `Failed to create output directory: ${this.outputDir}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Failed to initialize file system utilities.',\n      );\n    }\n  }\n\n  private async loadGlobalCss(): Promise<void> {\n    const cssFilePath = path.resolve(\n      process.cwd(),\n      `${this.cssDir}/global.css`,\n    );\n    try {\n      this.globalCssContent = await fs.promises.readFile(cssFilePath, 'utf-8');\n      this.logger.log('global.css loaded successfully.');\n    } catch (error) {\n      this.logger.error(\n        `Failed to load global.css from ${cssFilePath}: ${error.message}`,\n        error.stack,\n      );\n      this.globalCssContent = ''; \n    }\n  }\n\n  private getTempPngPath(originalPath: string): string {\n    const fileName = path.basename(originalPath, path.extname(originalPath));\n    return path.join(this.outputDir, `${fileName}-${Date.now()}-temp.png`);\n  }\n\n  \n  parseEnvMap(mapString?: string): LanguageMap {\n    const map: LanguageMap = {};\n    if (!mapString) return map;\n\n    for (const entry of mapString.split(';')) {\n      const [key, value] = entry.split('=');\n      if (key && value) {\n        map[key.trim()] = value.trim();\n      }\n    }\n\n    return map;\n  }\n\n  \n\n  \n  detectLanguage(filename: string, mimeType?: string): string | undefined {\n    if (!filename) {\n      return undefined;\n    }\n\n    const ext = path.extname(filename).toLowerCase().substring(1);\n    if (ext && this.EXTENSION_LANGUAGE_MAP[ext]) {\n      return this.EXTENSION_LANGUAGE_MAP[ext];\n    }\n\n    const detectedMime = mimeType || mimeLookup(filename);\n    if (detectedMime) {\n      \n      const normalizedMime = detectedMime.split(';')[0].toLowerCase();\n      if (this.MIME_LANGUAGE_MAP[normalizedMime]) {\n        \n        return this.MIME_LANGUAGE_MAP[normalizedMime];\n      }\n    }\n\n    return undefined;\n  }\n\n  \n\n  \n  async formatCode(code: string, language: string): Promise<string> {\n    const parser = this.parserMap[language];\n    if (!parser) {\n      this.logger.warn(\n        `No Prettier parser configured for language: ${language}`,\n      );\n      return code;\n    }\n\n    try {\n      return await prettier.format(code, {\n        parser: parser as prettier.BuiltInParserName,\n        plugins: await this.loadPrettierPlugins(parser),\n        singleQuote: true,\n        trailingComma: 'all',\n        semi: true,\n        printWidth: 100,\n      });\n    } catch (error) {\n      this.logger.error(\n        `Failed to format code for language \"${language}\" using parser \"${parser}\": ${error.message}`,\n        error.stack,\n      );\n      return code;\n    }\n  }\n\n  private async loadPrettierPlugins(parser: string) {\n    const externalPlugins: Record<string, string[]> = {\n      yaml: ['prettier-plugin-yaml'],\n      xml: ['@prettier/plugin-xml'],\n    };\n\n    const requiredPlugins = externalPlugins[parser];\n    if (!requiredPlugins || requiredPlugins.length === 0) {\n      return [];\n    }\n\n    try {\n      const importedPlugins = await Promise.allSettled(\n        requiredPlugins.map((p) => import(p)),\n      );\n\n      return importedPlugins\n        .filter((result) => result.status === 'fulfilled')\n        .map(\n          (result: PromiseFulfilledResult<any>) =>\n            result.value.default || result.value,\n        );\n    } catch (error) {\n      this.logger.error(\n        `Failed to load Prettier plugins for parser ${parser}: ${error.message}`,\n      );\n      return [];\n    }\n  }\n\n  \n\n  \n  async convertToSvg(\n    imagePath: string, \n    color: string,\n    width?: number, \n    height?: number, \n  ): Promise<{ svg: string; filePath: string }> {\\n    let tempPngPath: string | undefined;\\n    try {\\n      \n      if (!fs.existsSync(imagePath)) {\\n        throw new BadRequestException(\n          `Input image file not found: ${imagePath}`,\n        );\n      }\n\n      tempPngPath = this.getTempPngPath(imagePath); \n\n      \n      let sharpPipeline = sharp(imagePath);\\n      if (width && height) {\n        sharpPipeline = sharpPipeline.resize(width, height);\\n      } else if (width) {\n        sharpPipeline = sharpPipeline.resize(width); \n      } else if (height) {\n        sharpPipeline = sharpPipeline.resize(undefined, height); \n      }\n\n      \n      await sharpPipeline\\n        .threshold(128) \n        .toFile(tempPngPath);\\n\\n      \n      const tracer = new potrace.Potrace({\n        threshold: 128,\n        color: color,\n        optTolerance: 0.4,\n        background: 'transparent',\n      });\\n\\n      const svg: string = await new Promise((resolve, reject) => {\\n        \n        tracer.loadImage(\n          tempPngPath,\n          function (err: Error) {\\n            if (err) {\\n              this.logger.error(\n                `Potrace loadImage failed: ${err.message}`,\n                err.stack,\n              );\n              return reject(\n                new InternalServerErrorException(\n                  `Potrace failed to load image: ${err.message}`,\n                ),\n              );\n            }\\n            resolve(this.getSVG());\\n          }.bind(tracer),\\n        );\n      });\\n\\n      const svgFilename = `svg-${Date.now()}.svg`;\\n      const svgPath = path.join(this.outputDir, svgFilename);\\n      await fs.promises.writeFile(svgPath, svg, 'utf-8');\\n\\n      return { svg, filePath: svgPath };\\n    } catch (error) {\\n      this.logger.error(\n        `Image to SVG conversion failed for file \\\"${imagePath}\\\": ${error.message}`,\n        error.stack,\n      );\n      \n      if (error instanceof HttpException) {\\n        throw error;\\n      }\\n      throw new InternalServerErrorException(\n        `Image to SVG conversion failed: ${error.message}`,\n      );\n    } finally {\\n      \n      if (tempPngPath && fs.existsSync(tempPngPath)) {\\n        try {\\n          await fs.promises.unlink(tempPngPath);\\n        } catch (unlinkError) {\\n          this.logger.warn(\n            `Failed to delete temporary file: ${tempPngPath}. Error: ${unlinkError.message}`,\n          );\n        }\\n      }\\n    }\\n  }\\n\\n  \n\n  \n  parseSqlToJson(sql: string): {\\n    type: string;\\n    table: string;\\n    columns: string[];\\n    where: string | null;\\n  } {\\n    const selectRegex = /SELECT\\s+(.+?)\\s+FROM\\s+(\\w+)(?:\\s+WHERE\\s+(.+))?/i;\\n    const match = sql.match(selectRegex);\\n\\n    if (!match) {\\n      throw new BadRequestException('Invalid SELECT SQL syntax'); \\n    }\\n\\n    const [, columns, table, where] = match;\\n    return {\\n      type: 'select',\\n      table,\\n      columns: columns.split(',').map((col) => col.trim()),\\n      where: where ? where.trim() : null,\\n    };\\n  }\\n\\n  \n  parseInsertSqlToJson(sql: string): {\\n    type: string;\\n    table: string;\\n    data: Record<string, string>;\\n  } {\\n    const insertRegex = /INSERT INTO (\\w+)\\s*\\((.+)\\)\\s*VALUES\\s*\\((.+)\\)/i;\\n    const match = sql.match(insertRegex);\\n\\n    if (!match) {\\n      throw new BadRequestException('Invalid INSERT SQL syntax'); \\n    }\\n\\n    const [, table, columns, values] = match;\\n\\n    const columnList = columns.split(',').map((c) => c.trim());\\n    const valueList = values\\n      .split(',')\\n      .map((v) => v.trim().replace(/^'|'$/g, ''))\\n      .map((v) => (v === 'NULL' ? null : v)); \\n\\n    if (columnList.length !== valueList.length) {\\n      throw new BadRequestException( \\n        'Column and value counts do not match in INSERT statement',\n      );\\n    }\\n\\n    const data: Record<string, string> = {};\\n    columnList.forEach((col, idx) => {\\n      \\n      \\n      data[col] = valueList[idx] !== null ? String(valueList[idx]) : 'NULL'; \\n    });\\n\\n    return {\\n      type: 'insert',\\n      table,\\n      data,\\n    };\\n  }\\n\\n  \\n  jsonToInsertSql(input: {\\n    table: string;\\n    data: Record<string, string | number | boolean | null>;\\n  }): string {\\n    const { table, data } = input;\\n    const columns = Object.keys(data).join(', ');\\n    const values = Object.values(data)\\n      .map((v) => {\\n        if (v === null) return 'NULL';\\n        if (typeof v === 'string') return `'${v.replace(/'/g, \"''")}'`;\\n        if (typeof v === 'boolean') return v ? 'TRUE' : 'FALSE';\\n        return v;\\n      })\\n      .join(', ');\\n\\n    return `INSERT INTO ${table} (${columns}) VALUES (${values});`;\\n  }\\n\\n  \\n\\n  \\n  capitalize(text: string): string {\\n    if (!text) return '';\\n    return text.charAt(0).toUpperCase() + text.slice(1);\\n  }\\n\\n  \\n  toKebabCase(text: string): string {\\n    return text\\n      .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2')\\n      .replace(/\\s+/g, '-')\\n      .toLowerCase();\\n  }\\n\\n  \\n  reverseString(text: string): string {\\n    return text.split('').reverse().join('');\\n  }\\n\\n  \\n  truncateText(text: string, maxLength: number): string {\\n    if (text.length <= maxLength) return text;\\n    return text.slice(0, maxLength) + '...';\\n  }\\n\\n  \\n  extractMarkdownTitle(markdown: string): string | null {\\n    const match = markdown.match(/^#{1,2}\\s+(.*)/m); \\n    return match ? match[1].trim() : null;\\n  }\\n\\n  \\n  uniqueArray<T>(arr: T[]): T[] {\\n    return [...new Set(arr)];\\n  }\\n\\n  \\n\\n  \\n  timeAgo(ms: number): string {\\n    const formatter = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });\\n    const now = Date.now();\\n    const date = new Date(now - ms);\\n\\n    const seconds = Math.round((now - date.getTime()) / 1000);\\n    const minutes = Math.round(seconds / 60);\\n    const hours = Math.round(minutes / 60);\\n    const days = Math.round(hours / 24);\\n    const months = Math.round(days / 30.4375);\\n    const years = Math.round(days / 365.25);\\n\\n    if (seconds < 10) {\\n      return 'just now';\\n    } else if (seconds < 60) {\\n      return formatter.format(-seconds, 'second');\\n    } else if (minutes < 60) {\\n      return formatter.format(-minutes, 'minute');\\n    } else if (hours < 24) {\\n      return formatter.format(-hours, 'hour');\\n    } else if (days < 30) {\\n      return formatter.format(-days, 'day');\\n    } else if (months < 12) {\\n      return formatter.format(-months, 'month');\\n    } else {\\n      return formatter.format(-years, 'year');\\n    }\\n  }\\n\\n  \\n  toUnixSeconds(date: Date | string): number {\\n    const d = typeof date === 'string' ? new Date(date) : date;\\n    if (isNaN(d.getTime())) {\\n      throw new BadRequestException('Invalid date provided to toUnixSeconds'); \\n    }\\n    return Math.floor(d.getTime() / 1000);\\n  }\\n\\n  \\n  parseDurationToMs(duration: string): number {\\n    const match = duration.match(/^(\\d+)([dhms])$/);\\n    if (!match) {\\n      throw new BadRequestException( \\n        'Invalid duration format. Expected format: e.g., \\\"1d\\\", \\\"3h\\\", \\\"15m\\\", \\\"30s\\\".',\\n      );\\n    }\\n\\n    const [_, amountStr, unit] = match;\\n    const amount = parseInt(amountStr, 10);\\n\\n    switch (unit) {\\n      case 'd':\\n        return amount * 24 * 60 * 60 * 1000;\\n      case 'h':\\n        return amount * 60 * 60 * 1000;\\n      case 'm':\\n        return amount * 60 * 1000;\\n      case 's':\\n        return amount * 1000;\\n      default:\\n        throw new InternalServerErrorException(\\n          'Unknown time unit provided to parseDurationToMs.',\\n        );\\n    }\\n  }\\n\\n  \\n  formatUnixTimestamp(timestamp: number): string {\\n    const date = new Date(timestamp * 1000);\\n    return date.toLocaleString('en-US', {\\n      timeZone: 'UTC',\\n      year: 'numeric',\\n      month: 'short',\\n      day: '2-digit',\\n      hour: '2-digit',\\n      minute: '2-digit',\\n      second: '2-digit',\\n    });\\n  }\\n\\n  \\n\\n  \\n  parseEnvToJsonString(content: string): Record<string, string> {\\n    \\n    \\n    return dotenv.parse(content);\\n  }\\n\\n  \\n  async parseEnvFile(\\n    file?: Express.Multer.File,\\n    filepath?: string,\\n  ): Promise<{ filepath: string; data: Record<string, string> }> {\\n    if ((file && filepath) || (!file && !filepath)) {\\n      throw new BadRequestException(\\n        'Provide exactly one of either an uploaded file or a filepath.',\\n      );\\n    }\\n\\n    let content: string;\\n    let sourcePath: string;\\n\\n    if (file) {\\n      content = file.buffer.toString('utf-8');\\n      sourcePath = file.originalname;\\n    } else {\\n      const resolvedPath = path.resolve(filepath as string);\\n      try {\\n        content = await fs.promises.readFile(resolvedPath, 'utf-8');\\n        sourcePath = resolvedPath;\\n      } catch (err) {\\n        this.logger.error(\\n          `Failed to read file at path: ${resolvedPath}`,\n          err.stack,\\n        );\\n        throw new BadRequestException(\\n          `Failed to read file at path: ${filepath}. Make sure it's accessible and correct.`,\n        );\\n      }\\n    }\\n\\n    try {\\n      const parsed = dotenv.parse(content);\\n      return { filepath: sourcePath, data: parsed };\\n    } catch (err) {\\n      this.logger.error(\\n        `Failed to parse .env file content: ${err.message}`,\n        err.stack,\\n      );\n      throw new BadRequestException(\\n        'Failed to parse .env file. Ensure it is a valid .env format.',\\n      );\\n    }\\n  }\\n\\n  \\n\\n  \\n  async markdownToJson(markdown: string): Promise<Root> {\\n    const processor = unified().use(remarkParse);\\n    const tree = processor.parse(markdown);\\n    return tree;\\n  }\\n\\n  \\n  async jsonToMarkdown(ast: Root): Promise<string> {\\n    const processor = unified().use(remarkStringify);\\n    const markdown = processor.stringify(ast);\\n    return markdown;\\n  }\\n\\n  \\n  async markdownToHtml(markdown: string): Promise<string> {\\n    if (this.globalCssContent === null) {\\n      await this.loadGlobalCss(); \\n    }\\n\\n    const file = await unified()\\n      .use(remarkParse)\\n      .use(remarkRehype)\\n      .use(rehypeStringify)\\n      .process(markdown);\\n\\n    return `<style>${this.globalCssContent || ''}</style><div class=\"markdown-body\">${String(file)}</div>`;\\n  }\\n\\n  stripTripleBackticks(content: string): string {\\n    return content\\n      .trim()\\n      .replace(/^```[a-zA-Z]*\\n?/, '') \\n      .replace(/```$/, ''); \\n  }\\n\n  \nremoveComments(code: string): string {\n  return (\n    code\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') \n      .replace(/\\/\\/.*$/gm, '')\n      .split('\\n')\n      .map((line) => line.trimEnd())\n      .join('\\n')\n  );\n}\n\n  /**\n   * Replaces all double quotes (\") with single quotes (') in a given string.\n   * This is a simple string replacement and does not parse code syntax.\n   * @param text The input string, potentially containing code.\n   * @returns The string with all double quotes replaced by single quotes.\n   */\n  replaceDoubleQuotes(text: string): string {\n    return text.replace(/\"/g, \"'\");\n  }\n\n  \n  getDirectory(filePath: string): string {\n    return path.dirname(filePath);\n  }\n}\n"
    }
  ]
}
